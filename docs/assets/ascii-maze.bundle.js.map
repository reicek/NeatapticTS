{
  "version": 3,
  "sources": ["../../src/architecture/connection.ts", "../../src/config.ts", "../../src/methods/cost.ts", "../../src/methods/rate.ts", "../../src/methods/activation.ts", "../../src/methods/gating.ts", "../../src/methods/mutation.ts", "../../src/methods/selection.ts", "../../src/methods/crossover.ts", "../../src/methods/connection.ts", "../../src/methods/methods.ts", "../../src/architecture/node.ts", "../../src/architecture/activationArrayPool.ts", "../../src/architecture/network/network.onnx.ts", "../../src/architecture/onnx.ts", "../../src/architecture/network/network.standalone.ts", "../../src/architecture/network/network.topology.ts", "../../src/architecture/network/network.slab.ts", "../../src/architecture/network/network.prune.ts", "../../src/architecture/network/network.gating.ts", "../../src/architecture/network/network.deterministic.ts", "../../src/architecture/network/network.stats.ts", "../../src/architecture/network/network.remove.ts", "../../src/architecture/network/network.connect.ts", "../../src/architecture/network/network.serialize.ts", "../../src/architecture/network/network.genetic.ts", "../../src/architecture/network/network.activate.ts", "../../src/architecture/group.ts", "../../src/architecture/layer.ts", "../../src/architecture/network/network.mutate.ts", "../../src/architecture/network/network.training.ts", "../../node_modules/util/support/isBufferBrowser.js", "../../node_modules/util/node_modules/inherits/inherits_browser.js", "../../node_modules/util/util.js", "../../node_modules/path/path.js", "../../src/multithreading/workers/node/testworker.ts", "../../src/multithreading/workers/browser/testworker.ts", "../../src/multithreading/workers/workers.ts", "../../src/multithreading/multi.ts", "../../src/architecture/network/network.evolve.ts", "../../src/architecture/network.ts", "../../src/neat.ts", "../../test/examples/asciiMaze/browserTerminalUtility.ts", "../../test/examples/asciiMaze/browserLogger.ts", "../../test/examples/asciiMaze/mazeUtils.ts", "../../test/examples/asciiMaze/colors.ts", "../../test/examples/asciiMaze/networkVisualization.ts", "../../test/examples/asciiMaze/mazeVisualization.ts", "../../test/examples/asciiMaze/dashboardManager.ts", "../../src/neataptic.ts", "../../src/architecture/architect.ts", "../../test/examples/asciiMaze/mazeVision.ts", "../../test/examples/asciiMaze/mazeMovement.ts", "../../test/examples/asciiMaze/fitness.ts", "../../test/examples/asciiMaze/evolutionEngine.ts", "../../test/examples/asciiMaze/mazes.ts", "../../test/examples/asciiMaze/browser-entry.ts"],
  "sourcesContent": ["/**\r\n * Represents a connection between two nodes in a neural network.\r\n *\r\n * Connections transfer activation values from one node to another, with an associated weight\r\n * that determines the strength of the connection. Connections can also be gated by other nodes.\r\n */\r\nimport Node from './node'; // Import Node type\r\n\r\nexport default class Connection {\r\n  from: Node; // The source node of the connection\r\n  to: Node; // The target node of the connection\r\n  gain: number; // Gain applied to the connection\r\n  weight: number; // Weight of the connection\r\n  gater: Node | null; // Node that gates this connection, if any\r\n  eligibility: number; // Eligibility trace for backpropagation\r\n  previousDeltaWeight: number; // Previous weight change for momentum\r\n  totalDeltaWeight: number; // Accumulated weight change for batch training\r\n  xtrace: { nodes: Node[]; values: number[] }; // Extended trace for eligibility propagation\r\n  innovation: number; // Unique innovation identifier (NEAT-style)\r\n  enabled: boolean; // Whether this gene (connection) is currently expressed (NEAT disabled gene handling)\r\n  // --- Optimizer moment states ---\r\n  opt_m?: number; // First moment (Adam)\r\n  opt_v?: number; // Second moment (Adam)\r\n  opt_cache?: number; // Accumulator (RMSProp/Adagrad)\r\n  // Additional optimizer states\r\n  opt_vhat?: number; // AMSGrad max second moment\r\n  opt_u?: number; // Adamax infinity norm\r\n  opt_m2?: number; // Lion second momentum like term\r\n  _la_shadowWeight?: number; // Lookahead shadow param\r\n  dcMask?: number; // DropConnect mask (1 active, 0 dropped)\r\n\r\n  /**\r\n   * Creates a new connection between two nodes.\r\n   *\r\n   * @param {Node} from - The source node of the connection.\r\n   * @param {Node} to - The target node of the connection.\r\n   * @param {number} [weight] - The weight of the connection. Defaults to a random value between -0.1 and 0.1.\r\n   */\r\n  constructor(from: Node, to: Node, weight?: number) {\r\n    this.from = from;\r\n    this.to = to;\r\n    this.gain = 1;\r\n    this.weight = weight ?? Math.random() * 0.2 - 0.1;\r\n    this.gater = null;\r\n    this.eligibility = 0;\r\n\r\n    // For tracking momentum\r\n    this.previousDeltaWeight = 0;\r\n\r\n    // Batch training\r\n    this.totalDeltaWeight = 0;\r\n\r\n    this.xtrace = {\r\n      nodes: [],\r\n      values: [],\r\n    };\r\n\r\n    // Initialize optimizer moments\r\n    this.opt_m = 0;\r\n    this.opt_v = 0;\r\n    this.opt_cache = 0;\r\n    this.opt_vhat = 0;\r\n    this.opt_u = 0;\r\n    this.opt_m2 = 0;\r\n    // Initialize dropconnect mask\r\n    this.dcMask = 1;\r\n    this.innovation = Connection._nextInnovation++;\r\n    this.enabled = true; // default expressed\r\n  }\r\n\r\n  /**\r\n   * Converts the connection to a JSON object for serialization.\r\n   *\r\n   * @returns {{ from: number | undefined, to: number | undefined, weight: number, gain: number, gater: number | null }} A JSON representation of the connection.\r\n   */\r\n  toJSON() {\r\n    const json: any = {\r\n      from: this.from.index ?? undefined,\r\n      to: this.to.index ?? undefined,\r\n      weight: this.weight,\r\n      gain: this.gain,\r\n      innovation: this.innovation,\r\n      enabled: this.enabled,\r\n    };\r\n    if (this.gater && typeof this.gater.index !== 'undefined') {\r\n      json.gater = this.gater.index;\r\n    }\r\n    return json;\r\n  }\r\n\r\n  /**\r\n   * Generates a unique innovation ID for the connection.\r\n   *\r\n   * The innovation ID is calculated using the Cantor pairing function, which maps two integers\r\n   * (representing the source and target nodes) to a unique integer.\r\n   *\r\n   * @param {number} a - The ID of the source node.\r\n   * @param {number} b - The ID of the target node.\r\n   * @returns {number} The innovation ID based on the Cantor pairing function.\r\n   * @see {@link https://en.wikipedia.org/wiki/Pairing_function Cantor pairing function}\r\n   */\r\n  static innovationID(a: number, b: number): number {\r\n    return (1 / 2) * (a + b) * (a + b + 1) + b;\r\n  }\r\n  private static _nextInnovation: number = 1;\r\n  static resetInnovationCounter(value: number = 1) {\r\n    Connection._nextInnovation = value;\r\n  }\r\n\r\n  // --- Simple object pool to reduce GC churn when connections are frequently created/removed ---\r\n  private static _pool: Connection[] = [];\r\n  /** Acquire a Connection from the pool or construct a new one. Ensures fresh innovation id. */\r\n  static acquire(from: Node, to: Node, weight?: number): Connection {\r\n    let c: Connection;\r\n    if (Connection._pool.length) {\r\n      c = Connection._pool.pop()!;\r\n      // Reset fields\r\n      (c as any).from = from;\r\n      (c as any).to = to;\r\n      c.weight = weight ?? Math.random() * 0.2 - 0.1;\r\n      c.gain = 1;\r\n      c.gater = null;\r\n      c.eligibility = 0;\r\n      c.previousDeltaWeight = 0;\r\n      c.totalDeltaWeight = 0;\r\n      c.xtrace.nodes.length = 0;\r\n      c.xtrace.values.length = 0;\r\n      c.opt_m = 0;\r\n      c.opt_v = 0;\r\n      c.opt_cache = 0;\r\n      c.opt_vhat = 0;\r\n      c.opt_u = 0;\r\n      c.opt_m2 = 0;\r\n      c.dcMask = 1;\r\n      (c as any)._la_shadowWeight = undefined;\r\n      c.enabled = true;\r\n      // Assign a fresh innovation id\r\n      (c as any).innovation = Connection._nextInnovation++;\r\n    } else {\r\n      c = new Connection(from, to, weight);\r\n    }\r\n    return c;\r\n  }\r\n  /** Return a Connection to the pool for reuse. */\r\n  static release(conn: Connection) {\r\n    Connection._pool.push(conn);\r\n  }\r\n}\r\n", "/**\r\n * Global NeatapticTS configuration contract & default instance.\r\n *\r\n * WHY THIS EXISTS\r\n * --------------\r\n * A central `config` object offers a convenient, documented surface for end-users (and tests)\r\n * to tweak library behaviour without digging through scattered constants. Centralization also\r\n * lets us validate & evolve feature flags in a single place.\r\n *\r\n * USAGE PATTERN\r\n * ------------\r\n *   import { config } from 'neataptic-ts';\r\n *   config.warnings = true;              // enable runtime warnings\r\n *   config.deterministicChainMode = true // opt into deterministic deep path construction\r\n *\r\n * Adjust BEFORE constructing networks / invoking evolutionary loops so that subsystems read\r\n * the intended values while initializing internal buffers / metadata.\r\n *\r\n * DESIGN NOTES\r\n * ------------\r\n * - We intentionally avoid setters / proxies to keep this a plain serializable object.\r\n * - Optional flags are conservative by default (disabled) to preserve legacy stochastic\r\n *   behaviour unless a test or user explicitly opts in.\r\n */\r\nexport interface NeatapticConfig {\r\n  /**\r\n   * Emit safety, performance & deprecation warnings to stdout.\r\n   * Rationale: novices benefit from explicit guidance; advanced users can silence noise.\r\n   * Default: false\r\n   */\r\n  warnings: boolean;\r\n\r\n  /**\r\n   * Prefer `Float32Array` for activation & gradient buffers when true.\r\n   * Trade\u2011off: 2x lower memory + potential SIMD acceleration vs precision of 64-bit floats.\r\n   * Default: false (accuracy prioritized; enable for large populations or constrained memory).\r\n   */\r\n  float32Mode: boolean;\r\n\r\n  /**\r\n   * Hard cap for arrays retained per size bucket in the activation buffer pool.\r\n   * Set to a finite non\u2011negative integer to bound memory. `undefined` = unlimited reuse.\r\n   */\r\n  poolMaxPerBucket?: number;\r\n\r\n  /**\r\n   * Prewarm count for commonly used activation sizes. Helps remove first-iteration jitter in\r\n   * tight benchmarking loops. Omit to accept library default heuristics.\r\n   */\r\n  poolPrewarmCount?: number;\r\n\r\n  /**\r\n   * Deterministic deep path construction mode (TEST / EDUCATIONAL FEATURE).\r\n   * When enabled: every ADD_NODE mutation extends a single linear input\u2192\u2026\u2192output chain, pruning\r\n   * side branches. This allows tests (and learners) to reason about exact depth after N steps.\r\n   * Disable for realistic evolutionary stochasticity.\r\n   */\r\n  deterministicChainMode?: boolean;\r\n\r\n  /**\r\n   * Enable allocation / maintenance of extended gating trace structures.\r\n   * Forward looking flag: currently minimal impact; kept for future advanced credit assignment\r\n   * experiments. Disable if profiling reveals overhead in extremely large recurrent nets.\r\n   * Default: true\r\n   */\r\n  enableGatingTraces?: boolean;\r\n}\r\n\r\n/**\r\n * Default configuration instance. Override fields as needed before constructing networks.\r\n */\r\n/**\r\n * Singleton mutable configuration object consumed throughout the library.\r\n * Modify properties directly; do NOT reassign the binding (imports retain reference).\r\n */\r\nexport const config: NeatapticConfig = {\r\n  warnings: false, // emit runtime guidance\r\n  float32Mode: false, // numeric precision mode\r\n  deterministicChainMode: false, // deep path test flag (ADD_NODE determinism)\r\n  enableGatingTraces: true, // advanced gating trace infra\r\n  // poolMaxPerBucket: 256,     // example memory cap override\r\n  // poolPrewarmCount: 2,       // example prewarm override\r\n};\r\n", "/**\r\n * Provides a collection of standard cost functions (also known as loss functions)\r\n * used for evaluating the performance of neural networks during training.\r\n *\r\n * Cost functions quantify the difference between the network's predictions\r\n * and the actual target values. The goal of training is typically to minimize\r\n * the value of the cost function. The choice of cost function is crucial and\r\n * depends on the specific task (e.g., regression, classification) and the\r\n * desired behavior of the model.\r\n *\r\n * @see {@link https://en.wikipedia.org/wiki/Loss_function}\r\n */\r\nexport default class Cost {\r\n  /**\r\n   * Calculates the Cross Entropy error, commonly used for classification tasks.\r\n   *\r\n   * This function measures the performance of a classification model whose output is\r\n   * a probability value between 0 and 1. Cross-entropy loss increases as the\r\n   * predicted probability diverges from the actual label.\r\n   *\r\n   * It uses a small epsilon (1e-15) to prevent `log(0)` which would result in `NaN`.\r\n   * Output values are clamped to the range `[epsilon, 1 - epsilon]` for numerical stability.\r\n   *\r\n   * @see {@link https://en.wikipedia.org/wiki/Cross_entropy}\r\n   * @param {number[]} targets - An array of target values, typically 0 or 1 for binary classification, or probabilities for soft labels.\r\n   * @param {number[]} outputs - An array of output values from the network, representing probabilities (expected to be between 0 and 1).\r\n   * @returns {number} The mean cross-entropy error over all samples.\r\n   * @throws {Error} If the target and output arrays have different lengths.\r\n   */\r\n  static crossEntropy(targets: number[], outputs: number[]): number {\r\n    let error = 0;\r\n    const epsilon = 1e-15; // Small constant to avoid log(0)\r\n\r\n    if (targets.length !== outputs.length) {\r\n      throw new Error('Target and output arrays must have the same length.');\r\n    }\r\n\r\n    for (let i = 0; i < outputs.length; i++) {\r\n      const target = targets[i];\r\n      const output = outputs[i];\r\n\r\n      // Clamp output to prevent log(0) or log(<0) issues.\r\n      const clampedOutput = Math.max(epsilon, Math.min(1 - epsilon, output));\r\n\r\n      // Note: Assumes target is 0 or 1 for standard binary cross-entropy.\r\n      // The formula handles soft labels (targets between 0 and 1) correctly.\r\n      if (target === 1) {\r\n        error -= Math.log(clampedOutput); // Cost when target is 1\r\n      } else if (target === 0) {\r\n        error -= Math.log(1 - clampedOutput); // Cost when target is 0\r\n      } else {\r\n        // General case for targets between 0 and 1 (soft labels)\r\n        error -=\r\n          target * Math.log(clampedOutput) +\r\n          (1 - target) * Math.log(1 - clampedOutput);\r\n      }\r\n    }\r\n\r\n    // Return the average error over the batch/dataset.\r\n    return error / outputs.length;\r\n  }\r\n\r\n  /**\r\n   * Softmax Cross Entropy for mutually exclusive multi-class outputs given raw (pre-softmax or arbitrary) scores.\r\n   * Applies a numerically stable softmax to the outputs internally then computes -sum(target * log(prob)).\r\n   * Targets may be soft labels and are expected to sum to 1 (will be re-normalized if not).\r\n   */\r\n  static softmaxCrossEntropy(targets: number[], outputs: number[]): number {\r\n    if (targets.length !== outputs.length) {\r\n      throw new Error('Target and output arrays must have the same length.');\r\n    }\r\n    const n = outputs.length;\r\n    // Normalize targets if they don't sum to 1\r\n    let tSum = 0;\r\n    for (const t of targets) tSum += t;\r\n    const normTargets =\r\n      tSum > 0 ? targets.map((t) => t / tSum) : targets.slice();\r\n    // Stable softmax\r\n    const max = Math.max(...outputs);\r\n    const exps = outputs.map((o) => Math.exp(o - max));\r\n    const sum = exps.reduce((a, b) => a + b, 0) || 1;\r\n    const probs = exps.map((e) => e / sum);\r\n    let loss = 0;\r\n    const eps = 1e-15;\r\n    for (let i = 0; i < n; i++) {\r\n      const p = Math.min(1 - eps, Math.max(eps, probs[i]));\r\n      const t = normTargets[i];\r\n      loss -= t * Math.log(p);\r\n    }\r\n    return loss; // mean not applied; caller can average externally if batching\r\n  }\r\n\r\n  /**\r\n   * Calculates the Mean Squared Error (MSE), a common loss function for regression tasks.\r\n   *\r\n   * MSE measures the average of the squares of the errors\u2014that is, the average\r\n   * squared difference between the estimated values and the actual value.\r\n   * It is sensitive to outliers due to the squaring of the error terms.\r\n   *\r\n   * @see {@link https://en.wikipedia.org/wiki/Mean_squared_error}\r\n   * @param {number[]} targets - An array of target numerical values.\r\n   * @param {number[]} outputs - An array of output values from the network.\r\n   * @returns {number} The mean squared error.\r\n   * @throws {Error} If the target and output arrays have different lengths (implicitly via forEach).\r\n   */\r\n  static mse(targets: number[], outputs: number[]): number {\r\n    if (targets.length !== outputs.length) {\r\n      throw new Error('Target and output arrays must have the same length.');\r\n    }\r\n    let error = 0;\r\n\r\n    // Assumes targets and outputs have the same length.\r\n    outputs.forEach((output, outputIndex) => {\r\n      // Calculate the squared difference for each sample.\r\n      error += Math.pow(targets[outputIndex] - output, 2);\r\n    });\r\n\r\n    // Return the average squared error.\r\n    return error / outputs.length;\r\n  }\r\n\r\n  /**\r\n   * Calculates the Binary Error rate, often used as a simple accuracy metric for classification.\r\n   *\r\n   * This function calculates the proportion of misclassifications by comparing the\r\n   * rounded network outputs (thresholded at 0.5) against the target labels.\r\n   * It assumes target values are 0 or 1, and outputs are probabilities between 0 and 1.\r\n   * Note: This is equivalent to `1 - accuracy` for binary classification.\r\n   *\r\n   * @param {number[]} targets - An array of target values, expected to be 0 or 1.\r\n   * @param {number[]} outputs - An array of output values from the network, typically probabilities between 0 and 1.\r\n   * @returns {number} The proportion of misclassified samples (error rate, between 0 and 1).\r\n   * @throws {Error} If the target and output arrays have different lengths (implicitly via forEach).\r\n   */\r\n  static binary(targets: number[], outputs: number[]): number {\r\n    if (targets.length !== outputs.length) {\r\n      throw new Error('Target and output arrays must have the same length.');\r\n    }\r\n    let misses = 0;\r\n\r\n    // Assumes targets and outputs have the same length.\r\n    outputs.forEach((output, outputIndex) => {\r\n      // Round output to nearest integer (0 or 1) using a 0.5 threshold.\r\n      // Compare rounded output to the target label.\r\n      misses += Math.round(targets[outputIndex]) !== Math.round(output) ? 1 : 0;\r\n    });\r\n\r\n    // Return the error rate (proportion of misses).\r\n    return misses / outputs.length;\r\n    // Alternative: return `misses` to get the raw count of misclassifications.\r\n  }\r\n\r\n  /**\r\n   * Calculates the Mean Absolute Error (MAE), another common loss function for regression tasks.\r\n   *\r\n   * MAE measures the average of the absolute differences between predictions and actual values.\r\n   * Compared to MSE, it is less sensitive to outliers because errors are not squared.\r\n   *\r\n   * @see {@link https://en.wikipedia.org/wiki/Mean_absolute_error}\r\n   * @param {number[]} targets - An array of target numerical values.\r\n   * @param {number[]} outputs - An array of output values from the network.\r\n   * @returns {number} The mean absolute error.\r\n   * @throws {Error} If the target and output arrays have different lengths (implicitly via forEach).\r\n   */\r\n  static mae(targets: number[], outputs: number[]): number {\r\n    if (targets.length !== outputs.length) {\r\n      throw new Error('Target and output arrays must have the same length.');\r\n    }\r\n    let error = 0;\r\n\r\n    // Assumes targets and outputs have the same length.\r\n    outputs.forEach((output, outputIndex) => {\r\n      // Calculate the absolute difference for each sample.\r\n      error += Math.abs(targets[outputIndex] - output);\r\n    });\r\n\r\n    // Return the average absolute error.\r\n    return error / outputs.length;\r\n  }\r\n\r\n  /**\r\n   * Calculates the Mean Absolute Percentage Error (MAPE).\r\n   *\r\n   * MAPE expresses the error as a percentage of the actual value. It can be useful\r\n   * for understanding the error relative to the magnitude of the target values.\r\n   * However, it has limitations: it's undefined when the target value is zero and\r\n   * can be skewed by target values close to zero.\r\n   *\r\n   * @see {@link https://en.wikipedia.org/wiki/Mean_absolute_percentage_error}\r\n   * @param {number[]} targets - An array of target numerical values. Should not contain zeros for standard MAPE.\r\n   * @param {number[]} outputs - An array of output values from the network.\r\n   * @returns {number} The mean absolute percentage error, expressed as a proportion (e.g., 0.1 for 10%).\r\n   * @throws {Error} If the target and output arrays have different lengths (implicitly via forEach).\r\n   */\r\n  static mape(targets: number[], outputs: number[]): number {\r\n    if (targets.length !== outputs.length) {\r\n      throw new Error('Target and output arrays must have the same length.');\r\n    }\r\n    let error = 0;\r\n    const epsilon = 1e-15; // Small constant to avoid division by zero or near-zero target values.\r\n\r\n    // Assumes targets and outputs have the same length.\r\n    outputs.forEach((output, outputIndex) => {\r\n      const target = targets[outputIndex];\r\n      // Calculate the absolute percentage error for each sample.\r\n      // Use Math.max with epsilon to prevent division by zero.\r\n      error += Math.abs(\r\n        (target - output) / Math.max(Math.abs(target), epsilon)\r\n      );\r\n    });\r\n\r\n    // Return the average absolute percentage error (as a proportion).\r\n    // Multiply by 100 if a percentage value is desired.\r\n    return error / outputs.length;\r\n  }\r\n\r\n  /**\r\n   * Calculates the Mean Squared Logarithmic Error (MSLE).\r\n   *\r\n   * MSLE is often used in regression tasks where the target values span a large range\r\n   * or when penalizing under-predictions more than over-predictions is desired.\r\n   * It measures the squared difference between the logarithms of the predicted and actual values.\r\n   * Uses `log(1 + x)` instead of `log(x)` for numerical stability and to handle inputs of 0.\r\n   * Assumes both targets and outputs are non-negative.\r\n   *\r\n   * @see {@link https://peltarion.com/knowledge-center/documentation/modeling-view/build-an-ai-model/loss-functions/mean-squared-logarithmic-error}\r\n   * @param {number[]} targets - An array of target numerical values (assumed >= 0).\r\n   * @param {number[]} outputs - An array of output values from the network (assumed >= 0).\r\n   * @returns {number} The mean squared logarithmic error.\r\n   * @throws {Error} If the target and output arrays have different lengths (implicitly via forEach).\r\n   */\r\n  static msle(targets: number[], outputs: number[]): number {\r\n    if (targets.length !== outputs.length) {\r\n      throw new Error('Target and output arrays must have the same length.');\r\n    }\r\n    let error = 0;\r\n\r\n    // Assumes targets and outputs have the same length.\r\n    outputs.forEach((output, outputIndex) => {\r\n      const target = targets[outputIndex];\r\n      // Ensure inputs are non-negative before adding 1 for the logarithm.\r\n      // Using log(1 + x) avoids issues with log(0) and handles values >= 0.\r\n      const logTarget = Math.log(Math.max(target, 0) + 1);\r\n      const logOutput = Math.log(Math.max(output, 0) + 1);\r\n      // Calculate the squared difference of the logarithms.\r\n      error += Math.pow(logTarget - logOutput, 2);\r\n    });\r\n\r\n    // Return the average squared logarithmic error.\r\n    return error / outputs.length;\r\n  }\r\n\r\n  /**\r\n   * Calculates the Mean Hinge loss, primarily used for \"maximum-margin\" classification,\r\n   * most notably for Support Vector Machines (SVMs).\r\n   *\r\n   * Hinge loss is used for training classifiers. It penalizes predictions that are\r\n   * not only incorrect but also those that are correct but not confident (i.e., close to the decision boundary).\r\n   * Assumes target values are encoded as -1 or 1.\r\n   *\r\n   * @see {@link https://en.wikipedia.org/wiki/Hinge_loss}\r\n   * @param {number[]} targets - An array of target values, expected to be -1 or 1.\r\n   * @param {number[]} outputs - An array of output values from the network (raw scores, not necessarily probabilities).\r\n   * @returns {number} The mean hinge loss.\r\n   * @throws {Error} If the target and output arrays have different lengths (implicitly via forEach).\r\n   */\r\n  static hinge(targets: number[], outputs: number[]): number {\r\n    if (targets.length !== outputs.length) {\r\n      throw new Error('Target and output arrays must have the same length.');\r\n    }\r\n    let error = 0;\r\n\r\n    // Assumes targets and outputs have the same length.\r\n    outputs.forEach((output, outputIndex) => {\r\n      const target = targets[outputIndex]; // Should be -1 or 1 for standard hinge loss.\r\n      // The term `target * output` should be >= 1 for a correct and confident prediction.\r\n      // Loss is incurred if `target * output < 1`.\r\n      error += Math.max(0, 1 - target * output);\r\n    });\r\n\r\n    // Return the average hinge loss.\r\n    return error / outputs.length;\r\n  }\r\n\r\n  /**\r\n   * Calculates the Focal Loss, which is useful for addressing class imbalance in classification tasks.\r\n   * Focal loss down-weights easy examples and focuses training on hard negatives.\r\n   *\r\n   * @see https://arxiv.org/abs/1708.02002\r\n   * @param {number[]} targets - Array of target values (0 or 1 for binary, or probabilities for soft labels).\r\n   * @param {number[]} outputs - Array of predicted probabilities (between 0 and 1).\r\n   * @param {number} gamma - Focusing parameter (default 2).\r\n   * @param {number} alpha - Balancing parameter (default 0.25).\r\n   * @returns {number} The mean focal loss.\r\n   */\r\n  static focalLoss(\r\n    targets: number[],\r\n    outputs: number[],\r\n    gamma: number = 2,\r\n    alpha: number = 0.25\r\n  ): number {\r\n    let error = 0;\r\n    const epsilon = 1e-15;\r\n    if (targets.length !== outputs.length) {\r\n      throw new Error('Target and output arrays must have the same length.');\r\n    }\r\n    for (let i = 0; i < outputs.length; i++) {\r\n      const t = targets[i];\r\n      const p = Math.max(epsilon, Math.min(1 - epsilon, outputs[i]));\r\n      const pt = t === 1 ? p : 1 - p;\r\n      const a = t === 1 ? alpha : 1 - alpha;\r\n      error += -a * Math.pow(1 - pt, gamma) * Math.log(pt);\r\n    }\r\n    return error / outputs.length;\r\n  }\r\n\r\n  /**\r\n   * Calculates the Cross Entropy with Label Smoothing.\r\n   * Label smoothing prevents the model from becoming overconfident by softening the targets.\r\n   *\r\n   * @see https://arxiv.org/abs/1512.00567\r\n   * @param {number[]} targets - Array of target values (0 or 1 for binary, or probabilities for soft labels).\r\n   * @param {number[]} outputs - Array of predicted probabilities (between 0 and 1).\r\n   * @param {number} smoothing - Smoothing factor (between 0 and 1, e.g., 0.1).\r\n   * @returns {number} The mean cross-entropy loss with label smoothing.\r\n   */\r\n  static labelSmoothing(\r\n    targets: number[],\r\n    outputs: number[],\r\n    smoothing: number = 0.1\r\n  ): number {\r\n    let error = 0;\r\n    const epsilon = 1e-15;\r\n    if (targets.length !== outputs.length) {\r\n      throw new Error('Target and output arrays must have the same length.');\r\n    }\r\n    for (let i = 0; i < outputs.length; i++) {\r\n      // Smooth the target: t_smooth = t * (1 - smoothing) + 0.5 * smoothing\r\n      const t = targets[i] * (1 - smoothing) + 0.5 * smoothing;\r\n      const p = Math.max(epsilon, Math.min(1 - epsilon, outputs[i]));\r\n      error -= t * Math.log(p) + (1 - t) * Math.log(1 - p);\r\n    }\r\n    return error / outputs.length;\r\n  }\r\n}\r\n", "/**\r\n * Provides various methods for implementing learning rate schedules.\r\n *\r\n * Learning rate schedules dynamically adjust the learning rate during the training\r\n * process of machine learning models, particularly neural networks. Adjusting the\r\n * learning rate can significantly impact training speed and performance. A high\r\n * rate might lead to overshooting the optimal solution, while a very low rate\r\n * can result in slow convergence or getting stuck in local minima. These methods\r\n * offer different strategies to balance exploration and exploitation during training.\r\n *\r\n * @see {@link https://en.wikipedia.org/wiki/Learning_rate Learning Rate on Wikipedia}\r\n * @see {@link https://towardsdatascience.com/understanding-learning-rates-and-how-it-improves-performance-in-deep-learning-d0d4059c1c10 Understanding Learning Rates}\r\n */\r\nexport default class Rate {\r\n  /**\r\n   * Implements a fixed learning rate schedule.\r\n   *\r\n   * The learning rate remains constant throughout the entire training process.\r\n   * This is the simplest schedule and serves as a baseline, but may not be\r\n   * optimal for complex problems.\r\n   *\r\n   * @returns A function that takes the base learning rate and the current iteration number, and always returns the base learning rate.\r\n   * @param baseRate The initial learning rate, which will remain constant.\r\n   * @param iteration The current training iteration (unused in this method, but included for consistency).\r\n   */\r\n  static fixed(): (baseRate: number, iteration: number) => number {\r\n    const func = (baseRate: number, iteration: number): number => {\r\n      return baseRate;\r\n    };\r\n\r\n    return func;\r\n  }\r\n\r\n  /**\r\n   * Implements a step decay learning rate schedule.\r\n   *\r\n   * The learning rate is reduced by a multiplicative factor (`gamma`)\r\n   * at predefined intervals (`stepSize` iterations). This allows for\r\n   * faster initial learning, followed by finer adjustments as training progresses.\r\n   *\r\n   * Formula: `learning_rate = baseRate * gamma ^ floor(iteration / stepSize)`\r\n   *\r\n   * @param gamma The factor by which the learning rate is multiplied at each step. Should be less than 1. Defaults to 0.9.\r\n   * @param stepSize The number of iterations after which the learning rate decays. Defaults to 100.\r\n   * @returns A function that calculates the decayed learning rate for a given iteration.\r\n   * @param baseRate The initial learning rate.\r\n   * @param iteration The current training iteration.\r\n   */\r\n  static step(\r\n    gamma: number = 0.9,\r\n    stepSize: number = 100\r\n  ): (baseRate: number, iteration: number) => number {\r\n    const func = (baseRate: number, iteration: number): number => {\r\n      return Math.max(\r\n        0,\r\n        baseRate * Math.pow(gamma, Math.floor(iteration / stepSize))\r\n      );\r\n    };\r\n\r\n    return func;\r\n  }\r\n\r\n  /**\r\n   * Implements an exponential decay learning rate schedule.\r\n   *\r\n   * The learning rate decreases exponentially after each iteration, multiplying\r\n   * by the decay factor `gamma`. This provides a smooth, continuous reduction\r\n   * in the learning rate over time.\r\n   *\r\n   * Formula: `learning_rate = baseRate * gamma ^ iteration`\r\n   *\r\n   * @param gamma The decay factor applied at each iteration. Should be less than 1. Defaults to 0.999.\r\n   * @returns A function that calculates the exponentially decayed learning rate for a given iteration.\r\n   * @param baseRate The initial learning rate.\r\n   * @param iteration The current training iteration.\r\n   */\r\n  static exp(\r\n    gamma: number = 0.999\r\n  ): (baseRate: number, iteration: number) => number {\r\n    const func = (baseRate: number, iteration: number): number => {\r\n      return baseRate * Math.pow(gamma, iteration);\r\n    };\r\n\r\n    return func;\r\n  }\r\n\r\n  /**\r\n   * Implements an inverse decay learning rate schedule.\r\n   *\r\n   * The learning rate decreases as the inverse of the iteration number,\r\n   * controlled by the decay factor `gamma` and exponent `power`. The rate\r\n   * decreases more slowly over time compared to exponential decay.\r\n   *\r\n   * Formula: `learning_rate = baseRate / (1 + gamma * Math.pow(iteration, power))`\r\n   *\r\n   * @param gamma Controls the rate of decay. Higher values lead to faster decay. Defaults to 0.001.\r\n   * @param power The exponent controlling the shape of the decay curve. Defaults to 2.\r\n   * @returns A function that calculates the inversely decayed learning rate for a given iteration.\r\n   * @param baseRate The initial learning rate.\r\n   * @param iteration The current training iteration.\r\n   */\r\n  static inv(\r\n    gamma: number = 0.001,\r\n    power: number = 2\r\n  ): (baseRate: number, iteration: number) => number {\r\n    const func = (baseRate: number, iteration: number): number => {\r\n      // Use formula expected by tests: baseRate / (1 + gamma * Math.pow(iteration, power))\r\n      return baseRate / (1 + gamma * Math.pow(iteration, power));\r\n    };\r\n\r\n    return func;\r\n  }\r\n\r\n  /**\r\n   * Implements a Cosine Annealing learning rate schedule.\r\n   *\r\n   * This schedule varies the learning rate cyclically according to a cosine function.\r\n   * It starts at the `baseRate` and smoothly anneals down to `minRate` over a\r\n   * specified `period` of iterations, then potentially repeats. This can help\r\n   * the model escape local minima and explore the loss landscape more effectively.\r\n   * Often used with \"warm restarts\" where the cycle repeats.\r\n   *\r\n   * Formula: `learning_rate = minRate + 0.5 * (baseRate - minRate) * (1 + cos(pi * current_cycle_iteration / period))`\r\n   *\r\n   * @param period The number of iterations over which the learning rate anneals from `baseRate` to `minRate` in one cycle. Defaults to 1000.\r\n   * @param minRate The minimum learning rate value at the end of a cycle. Defaults to 0.\r\n   * @returns A function that calculates the learning rate for a given iteration based on the cosine annealing schedule.\r\n   * @param baseRate The initial (maximum) learning rate for the cycle.\r\n   * @param iteration The current training iteration.\r\n   * @see {@link https://arxiv.org/abs/1608.03983 SGDR: Stochastic Gradient Descent with Warm Restarts} - The paper introducing this technique.\r\n   */\r\n  static cosineAnnealing(\r\n    period: number = 1000,\r\n    minRate: number = 0\r\n  ): (baseRate: number, iteration: number) => number {\r\n    const func = (baseRate: number, iteration: number): number => {\r\n      // Calculate the current position within the cycle\r\n      const currentCycleIteration = iteration % period;\r\n      // Calculate the cosine decay factor (ranges from 1 down to 0)\r\n      const cosineDecay =\r\n        0.5 * (1 + Math.cos((currentCycleIteration / period) * Math.PI));\r\n      // Apply the decay to the range between baseRate and minRate\r\n      return minRate + (baseRate - minRate) * cosineDecay;\r\n    };\r\n    return func;\r\n  }\r\n\r\n  /**\r\n   * Cosine Annealing with Warm Restarts (SGDR style) where the cycle length can grow by a multiplier (tMult) after each restart.\r\n   *\r\n   * @param initialPeriod Length of the first cycle in iterations.\r\n   * @param minRate Minimum learning rate at valley.\r\n   * @param tMult Factor to multiply the period after each restart (>=1).\r\n   */\r\n  static cosineAnnealingWarmRestarts(\r\n    initialPeriod: number = 1000,\r\n    minRate: number = 0,\r\n    tMult: number = 1\r\n  ): (baseRate: number, iteration: number) => number {\r\n    let period = initialPeriod;\r\n    let cycleStart = 0;\r\n    let cycleEnd = period;\r\n    return (baseRate: number, iteration: number): number => {\r\n      // Advance cycles if iteration beyond current\r\n      while (iteration >= cycleEnd) {\r\n        cycleStart = cycleEnd;\r\n        period = Math.max(1, Math.round(period * tMult));\r\n        cycleEnd = cycleStart + period;\r\n      }\r\n      const cyclePos = iteration - cycleStart;\r\n      const cosineDecay = 0.5 * (1 + Math.cos((cyclePos / period) * Math.PI));\r\n      return minRate + (baseRate - minRate) * cosineDecay;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Linear Warmup followed by Linear Decay to an end rate.\r\n   * Warmup linearly increases LR from near 0 up to baseRate over warmupSteps, then linearly decays to endRate at totalSteps.\r\n   * Iterations beyond totalSteps clamp to endRate.\r\n   *\r\n   * @param totalSteps Total steps for full schedule (must be > 0).\r\n   * @param warmupSteps Steps for warmup (< totalSteps). Defaults to 10% of totalSteps.\r\n   * @param endRate Final rate at totalSteps.\r\n   */\r\n  static linearWarmupDecay(\r\n    totalSteps: number,\r\n    warmupSteps?: number,\r\n    endRate: number = 0\r\n  ): (baseRate: number, iteration: number) => number {\r\n    if (totalSteps <= 0) throw new Error('totalSteps must be > 0');\r\n    const warm = Math.min(\r\n      warmupSteps ?? Math.max(1, Math.floor(totalSteps * 0.1)),\r\n      totalSteps - 1\r\n    );\r\n    return (baseRate: number, iteration: number): number => {\r\n      if (iteration <= warm) {\r\n        return baseRate * (iteration / Math.max(1, warm));\r\n      }\r\n      if (iteration >= totalSteps) return endRate;\r\n      const decaySteps = totalSteps - warm;\r\n      const progress = (iteration - warm) / decaySteps; // 0..1\r\n      return endRate + (baseRate - endRate) * (1 - progress);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * ReduceLROnPlateau style scheduler (stateful closure) that monitors error signal (third argument if provided)\r\n   * and reduces rate by 'factor' if no improvement beyond 'minDelta' for 'patience' iterations.\r\n   * Cooldown prevents immediate successive reductions.\r\n   * NOTE: Requires the training loop to call with signature (baseRate, iteration, lastError).\r\n   */\r\n  static reduceOnPlateau(options?: {\r\n    factor?: number; // multiplicative decrease (0<f<1)\r\n    patience?: number; // iterations to wait for improvement\r\n    minDelta?: number; // significant improvement threshold\r\n    cooldown?: number; // iterations to wait after a reduction\r\n    minRate?: number; // floor rate\r\n    verbose?: boolean;\r\n  }): (baseRate: number, iteration: number, lastError?: number) => number {\r\n    const {\r\n      factor = 0.5,\r\n      patience = 10,\r\n      minDelta = 1e-4,\r\n      cooldown = 0,\r\n      minRate = 0,\r\n      verbose = false,\r\n    } = options || {};\r\n    let currentRate: number | undefined; // lazily initialize to baseRate first call\r\n    let bestError: number | undefined;\r\n    let lastImprovementIter = 0;\r\n    let cooldownUntil = -1;\r\n    return (\r\n      baseRate: number,\r\n      iteration: number,\r\n      lastError?: number\r\n    ): number => {\r\n      if (currentRate === undefined) currentRate = baseRate;\r\n      if (lastError !== undefined) {\r\n        if (bestError === undefined || lastError < bestError - minDelta) {\r\n          bestError = lastError;\r\n          lastImprovementIter = iteration;\r\n        } else if (\r\n          iteration - lastImprovementIter >= patience &&\r\n          iteration >= cooldownUntil\r\n        ) {\r\n          const newRate = Math.max(minRate, currentRate * factor);\r\n          if (newRate < currentRate) {\r\n            currentRate = newRate;\r\n            cooldownUntil = iteration + cooldown;\r\n            lastImprovementIter = iteration; // reset wait after reduction\r\n          }\r\n        }\r\n      }\r\n      return currentRate;\r\n    };\r\n  }\r\n}\r\n", "/**\r\n * Provides a collection of common activation functions used in neural networks.\r\n *\r\n * Activation functions introduce non-linearity into the network, allowing it to\r\n * learn complex patterns. They determine the output of a node based on its\r\n * weighted inputs and bias. The choice of activation function can significantly\r\n * impact the network's performance and training dynamics.\r\n *\r\n * All methods in this class are static and can be called directly, e.g., `Activation.relu(x)`.\r\n * Each method accepts an input value `x` and an optional boolean `derivate`.\r\n * If `derivate` is true, the method returns the derivative of the activation function\r\n * with respect to `x`; otherwise, it returns the activation function's output.\r\n *\r\n * @see {@link https://en.wikipedia.org/wiki/Activation_function}\r\n * @see {@link https://en.wikipedia.org/wiki/Universal_approximation_theorem}\r\n * @see {@link https://en.wikipedia.org/wiki/Rectifier_(neural_networks)}\r\n */\r\nexport const Activation: {\r\n  [key: string]: (x: number, derivate?: boolean) => number;\r\n} = {\r\n  /**\r\n   * Logistic (Sigmoid) activation function.\r\n   * Outputs values between 0 and 1. Commonly used in older network architectures\r\n   * and for output layers in binary classification tasks.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the logistic function or its derivative.\r\n   */\r\n  logistic: (x: number, derivate: boolean = false): number => {\r\n    const fx = 1 / (1 + Math.exp(-x));\r\n    return !derivate ? fx : fx * (1 - fx);\r\n  },\r\n\r\n  /**\r\n   * Alias for Logistic (Sigmoid) activation function.\r\n   * Outputs values between 0 and 1. Commonly used in older network architectures\r\n   * and for output layers in binary classification tasks.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the logistic function or its derivative.\r\n   */\r\n  sigmoid: (x: number, derivate: boolean = false): number => {\r\n    const fx = 1 / (1 + Math.exp(-x));\r\n    return !derivate ? fx : fx * (1 - fx);\r\n  },\r\n\r\n  /**\r\n   * Hyperbolic tangent (tanh) activation function.\r\n   * Outputs values between -1 and 1. Often preferred over logistic sigmoid in hidden layers\r\n   * due to its zero-centered output, which can help with training convergence.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the tanh function or its derivative.\r\n   */\r\n  tanh: (x: number, derivate: boolean = false): number => {\r\n    return derivate ? 1 - Math.pow(Math.tanh(x), 2) : Math.tanh(x);\r\n  },\r\n\r\n  /**\r\n   * Identity activation function (Linear).\r\n   * Outputs the input value directly: f(x) = x.\r\n   * Used when no non-linearity is desired, e.g., in output layers for regression tasks.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the identity function (x) or its derivative (1).\r\n   */\r\n  identity: (x: number, derivate: boolean = false): number => {\r\n    return derivate ? 1 : x;\r\n  },\r\n\r\n  /**\r\n   * Step activation function (Binary Step).\r\n   * Outputs 0 if the input is negative or zero, and 1 if the input is positive.\r\n   * Rarely used in modern deep learning due to its zero derivative almost everywhere,\r\n   * hindering gradient-based learning.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the step function (0 or 1) or its derivative (0).\r\n   */\r\n  step: (x: number, derivate: boolean = false): number => {\r\n    return derivate ? 0 : x > 0 ? 1 : 0;\r\n  },\r\n\r\n  /**\r\n   * Rectified Linear Unit (ReLU) activation function.\r\n   * Outputs the input if it's positive, and 0 otherwise: f(x) = max(0, x).\r\n   * Widely used in deep learning due to its simplicity, computational efficiency,\r\n   * and ability to mitigate the vanishing gradient problem.\r\n   *\r\n   * Note: The derivative at x=0 is ambiguous (theoretically undefined). Here, we return 0,\r\n   * which is a common practical choice. If you need a different behavior, consider using a custom activation.\r\n   *\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the ReLU function or its derivative (0 or 1).\r\n   */\r\n  relu: (x: number, derivate: boolean = false): number => {\r\n    return derivate ? (x > 0 ? 1 : 0) : x > 0 ? x : 0;\r\n  },\r\n\r\n  /**\r\n   * Softsign activation function.\r\n   * A smooth approximation of the sign function: f(x) = x / (1 + |x|).\r\n   * Outputs values between -1 and 1.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the softsign function or its derivative.\r\n   */\r\n  softsign: (x: number, derivate: boolean = false): number => {\r\n    const d = 1 + Math.abs(x);\r\n    // Derivative: 1 / (1 + |x|)^2\r\n    return derivate ? 1 / Math.pow(d, 2) : x / d;\r\n  },\r\n\r\n  /**\r\n   * Sinusoid activation function.\r\n   * Uses the standard sine function: f(x) = sin(x).\r\n   * Can be useful for tasks involving periodic patterns.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the sinusoid function or its derivative (cos(x)).\r\n   */\r\n  sinusoid: (x: number, derivate: boolean = false): number => {\r\n    return derivate ? Math.cos(x) : Math.sin(x);\r\n  },\r\n\r\n  /**\r\n   * Gaussian activation function.\r\n   * Uses the Gaussian (bell curve) function: f(x) = exp(-x^2).\r\n   * Outputs values between 0 and 1. Sometimes used in radial basis function (RBF) networks.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the Gaussian function or its derivative.\r\n   */\r\n  gaussian: (x: number, derivate: boolean = false): number => {\r\n    const d = Math.exp(-Math.pow(x, 2));\r\n    // Derivative: -2x * exp(-x^2)\r\n    return derivate ? -2 * x * d : d;\r\n  },\r\n\r\n  /**\r\n   * Bent Identity activation function.\r\n   * A function that behaves linearly for large positive inputs but non-linearly near zero:\r\n   * f(x) = (sqrt(x^2 + 1) - 1) / 2 + x.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the bent identity function or its derivative.\r\n   */\r\n  bentIdentity: (x: number, derivate: boolean = false): number => {\r\n    const d = Math.sqrt(Math.pow(x, 2) + 1);\r\n    // Derivative: x / (2 * sqrt(x^2 + 1)) + 1\r\n    return derivate ? x / (2 * d) + 1 : (d - 1) / 2 + x;\r\n  },\r\n\r\n  /**\r\n   * Bipolar activation function (Sign function).\r\n   * Outputs -1 if the input is negative or zero, and 1 if the input is positive.\r\n   * Similar to the Step function but with outputs -1 and 1.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the bipolar function (-1 or 1) or its derivative (0).\r\n   */\r\n  bipolar: (x: number, derivate: boolean = false): number => {\r\n    return derivate ? 0 : x > 0 ? 1 : -1;\r\n  },\r\n\r\n  /**\r\n   * Bipolar Sigmoid activation function.\r\n   * A scaled and shifted version of the logistic sigmoid, outputting values between -1 and 1:\r\n   * f(x) = 2 * logistic(x) - 1 = (1 - exp(-x)) / (1 + exp(-x)).\r\n   * This is equivalent to the hyperbolic tangent (tanh) function.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the bipolar sigmoid function or its derivative.\r\n   * @see {@link Activation.tanh}\r\n   */\r\n  bipolarSigmoid: (x: number, derivate: boolean = false): number => {\r\n    const d = 2 / (1 + Math.exp(-x)) - 1;\r\n    // Derivative: 0.5 * (1 + f(x)) * (1 - f(x))\r\n    return derivate ? (1 / 2) * (1 + d) * (1 - d) : d;\r\n  },\r\n\r\n  /**\r\n   * Hard Tanh activation function.\r\n   * A computationally cheaper, piecewise linear approximation of the tanh function:\r\n   * f(x) = max(-1, min(1, x)). Outputs values clamped between -1 and 1.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the hard tanh function or its derivative (0 or 1).\r\n   */\r\n  hardTanh: (x: number, derivate: boolean = false): number => {\r\n    // Derivative is 1 between -1 and 1, and 0 otherwise.\r\n    return derivate ? (x > -1 && x < 1 ? 1 : 0) : Math.max(-1, Math.min(1, x));\r\n  },\r\n\r\n  /**\r\n   * Absolute activation function.\r\n   * Outputs the absolute value of the input: f(x) = |x|.\r\n   *\r\n   * Note: The derivative at x=0 is ambiguous (theoretically undefined). Here, we return 1.\r\n   * If you need a different behavior, consider using a custom activation.\r\n   *\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the absolute function or its derivative (sign of x).\r\n   */\r\n  absolute: (x: number, derivate: boolean = false): number => {\r\n    // Derivative is -1 for x < 0, 1 for x > 0. (Derivative at x=0 is undefined, commonly set to 1 or 0).\r\n    return derivate ? (x < 0 ? -1 : 1) : Math.abs(x);\r\n  },\r\n\r\n  /**\r\n   * Inverse activation function.\r\n   * Outputs 1 minus the input: f(x) = 1 - x.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the inverse function or its derivative (-1).\r\n   */\r\n  inverse: (x: number, derivate: boolean = false): number => {\r\n    return derivate ? -1 : 1 - x;\r\n  },\r\n\r\n  /**\r\n   * Scaled Exponential Linear Unit (SELU) activation function.\r\n   *\r\n   * SELU aims to induce self-normalizing properties, meaning the outputs of SELU units\r\n   * automatically converge towards zero mean and unit variance.\r\n   * f(x) = scale * (max(0, x) + min(0, alpha * (exp(x) - 1)))\r\n   * Recommended for deep networks composed primarily of SELU units.\r\n   *\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the SELU function or its derivative.\r\n   * @see {@link https://arxiv.org/abs/1706.02515} - Self-Normalizing Neural Networks paper\r\n   * @see {@link https://github.com/wagenaartje/neataptic/wiki/Activation#selu} - Neataptic context\r\n   */\r\n  selu: (x: number, derivate: boolean = false): number => {\r\n    const alpha = 1.6732632423543772848170429916717;\r\n    const scale = 1.0507009873554804934193349852946;\r\n    const fx = x > 0 ? x : alpha * Math.exp(x) - alpha;\r\n    // Derivative: scale * (x > 0 ? 1 : alpha * exp(x))\r\n    // Simplified derivative using fx: scale * (x > 0 ? 1 : fx + alpha)\r\n    return derivate ? (x > 0 ? scale : (fx + alpha) * scale) : fx * scale;\r\n  },\r\n\r\n  /**\r\n   * Softplus activation function.\r\n   * A smooth approximation of the ReLU function: f(x) = log(1 + exp(x)).\r\n   * Always positive. Its derivative is the logistic sigmoid function.\r\n   * This implementation includes checks for numerical stability to avoid overflow/underflow.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the softplus function or its derivative (logistic sigmoid).\r\n   * @see {@link https://en.wikipedia.org/wiki/Rectifier_(neural_networks)#Softplus}\r\n   */\r\n  softplus: (x: number, derivate: boolean = false): number => {\r\n    const fx = 1 / (1 + Math.exp(-x)); // Logistic sigmoid\r\n    if (derivate) {\r\n      return fx; // Derivative of softplus is logistic sigmoid\r\n    } else {\r\n      // Numerically stable softplus calculation:\r\n      // log(1 + exp(x)) = log(exp(x)*(exp(-x) + 1)) = x + log(1 + exp(-x))\r\n      // Choose calculation based on x to avoid large positive exponents causing overflow.\r\n      if (x > 30) {\r\n        return x; // For large positive x, softplus(x) \u2248 x\r\n      } else if (x < -30) {\r\n        return Math.exp(x); // For large negative x, softplus(x) \u2248 exp(x)\r\n      }\r\n      // Use the alternative stable formula for intermediate values:\r\n      // max(0, x) + log(1 + exp(-abs(x)))\r\n      return Math.max(0, x) + Math.log(1 + Math.exp(-Math.abs(x)));\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Swish activation function (SiLU - Sigmoid Linear Unit).\r\n   * A self-gated activation function: f(x) = x * logistic(x).\r\n   * Often performs better than ReLU in deeper models.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the swish function or its derivative.\r\n   * @see {@link https://arxiv.org/abs/1710.05941} - Swish paper\r\n   */\r\n  swish: (x: number, derivate: boolean = false): number => {\r\n    const sigmoid_x = 1 / (1 + Math.exp(-x));\r\n    if (derivate) {\r\n      // Derivative: sigmoid(x) + x * sigmoid(x) * (1 - sigmoid(x))\r\n      // Can be rewritten using swish(x) = x * sigmoid(x):\r\n      // swish'(x) = swish(x) + sigmoid(x) * (1 - swish(x))\r\n      const swish_x = x * sigmoid_x;\r\n      return swish_x + sigmoid_x * (1 - swish_x);\r\n    } else {\r\n      return x * sigmoid_x;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Gaussian Error Linear Unit (GELU) activation function.\r\n   * Smooth approximation of ReLU, often used in Transformer models.\r\n   * f(x) = x * \u03A6(x), where \u03A6(x) is the standard Gaussian cumulative distribution function (CDF).\r\n   * This implementation uses a common fast approximation of GELU.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the GELU function or its derivative.\r\n   * @see {@link https://arxiv.org/abs/1606.08415}\r\n   */\r\n  gelu: (x: number, derivate: boolean = false): number => {\r\n    const cdf =\r\n      0.5 *\r\n      (1.0 +\r\n        Math.tanh(Math.sqrt(2.0 / Math.PI) * (x + 0.044715 * Math.pow(x, 3))));\r\n    if (derivate) {\r\n      // Derivative of the GELU approximation:\r\n      const intermediate = Math.sqrt(2.0 / Math.PI) * (1.0 + 0.134145 * x * x);\r\n      const sech_arg =\r\n        Math.sqrt(2.0 / Math.PI) * (x + 0.044715 * Math.pow(x, 3));\r\n      const sech_val = 1.0 / Math.cosh(sech_arg);\r\n      const sech_sq = sech_val * sech_val;\r\n      return cdf + x * 0.5 * intermediate * sech_sq;\r\n    } else {\r\n      return x * cdf;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Mish activation function.\r\n   * A self-gated activation function similar to Swish: f(x) = x * tanh(softplus(x)).\r\n   * Aims to provide better performance than ReLU and Swish in some cases.\r\n   * @param {number} x - The input value.\r\n   * @param {boolean} [derivate=false] - Whether to compute the derivative.\r\n   * @returns {number} The result of the Mish function or its derivative.\r\n   * @see {@link https://arxiv.org/abs/1908.08681}\r\n   */\r\n  mish: (x: number, derivate: boolean = false): number => {\r\n    // Use stable softplus calculation\r\n    // softplus(x) = log(1 + exp(x))\r\n    let sp_x: number;\r\n    if (x > 30) {\r\n      sp_x = x;\r\n    } else if (x < -30) {\r\n      sp_x = Math.exp(x);\r\n    } else {\r\n      sp_x = Math.max(0, x) + Math.log(1 + Math.exp(-Math.abs(x)));\r\n    }\r\n\r\n    const tanh_sp_x = Math.tanh(sp_x);\r\n\r\n    if (derivate) {\r\n      // Derivative of Mish: tanh(softplus(x)) + x * sech^2(softplus(x)) * sigmoid(x)\r\n      const sigmoid_x = 1 / (1 + Math.exp(-x)); // Derivative of softplus\r\n      const sech_sp_x = 1.0 / Math.cosh(sp_x); // sech(x) = 1 / cosh(x)\r\n      const sech_sq_sp_x = sech_sp_x * sech_sp_x;\r\n      return tanh_sp_x + x * sech_sq_sp_x * sigmoid_x;\r\n    } else {\r\n      return x * tanh_sp_x;\r\n    }\r\n  },\r\n};\r\n\r\n/**\r\n * Register a custom activation function at runtime.\r\n * @param {string} name - Name for the custom activation.\r\n * @param {(x: number, derivate?: boolean) => number} fn - The activation function (should handle derivative if needed).\r\n */\r\nexport function registerCustomActivation(\r\n  name: string,\r\n  fn: (x: number, derivate?: boolean) => number\r\n): void {\r\n  Activation[name] = fn;\r\n}\r\n\r\nexport default Activation;\r\n", "/**\r\n * Defines different methods for gating connections between neurons or groups of neurons.\r\n *\r\n * Gating mechanisms dynamically control the flow of information through connections\r\n * in a neural network. This allows the network to selectively route information,\r\n * enabling more complex computations, memory functions, and adaptive behaviors.\r\n * These mechanisms are inspired by biological neural processes where certain neurons\r\n * can modulate the activity of others. Gating is particularly crucial in recurrent\r\n * neural networks (RNNs) for managing information persistence over time.\r\n *\r\n * @see {@link https://en.wikipedia.org/wiki/Artificial_neural_network#Gating_mechanisms}\r\n */\r\nexport const gating = {\r\n  /**\r\n   * Output Gating: The gating neuron(s) control the activation flowing *out*\r\n   * of the connection's target neuron(s). The connection's weight remains static,\r\n   * but the output signal from the target neuron is modulated by the gater's state.\r\n   * @property {string} name - Identifier for the output gating method.\r\n   */\r\n  OUTPUT: {\r\n    name: 'OUTPUT',\r\n  },\r\n\r\n  /**\r\n   * Input Gating: The gating neuron(s) control the activation flowing *into*\r\n   * the connection's target neuron(s). The connection effectively transmits\r\n   * `connection_weight * source_activation * gater_activation` to the target neuron.\r\n   * @property {string} name - Identifier for the input gating method.\r\n   */\r\n  INPUT: {\r\n    name: 'INPUT',\r\n  },\r\n\r\n  /**\r\n   * Self Gating: The gating neuron(s) directly modulate the *weight* or strength\r\n   * of the connection itself. The connection's effective weight becomes dynamic,\r\n   * influenced by the gater's activation state (`effective_weight = connection_weight * gater_activation`).\r\n   * @property {string} name - Identifier for the self-gating method.\r\n   */\r\n  SELF: {\r\n    name: 'SELF',\r\n  },\r\n};\r\n", "import Activation from './activation';\r\n\r\n/**\r\n * Defines various mutation methods used in neuroevolution algorithms.\r\n *\r\n * Mutation introduces genetic diversity into the population by randomly\r\n * altering parts of an individual's genome (the neural network structure or parameters).\r\n * This is crucial for exploring the search space and escaping local optima.\r\n *\r\n * Common mutation strategies include adding or removing nodes and connections,\r\n * modifying connection weights and node biases, and changing node activation functions.\r\n * These operations allow the network topology and parameters to adapt over generations.\r\n *\r\n * The methods listed here are inspired by techniques used in algorithms like NEAT\r\n * and particularly the Instinct algorithm, providing a comprehensive set of tools\r\n * for evolving network architectures.\r\n *\r\n * ## Supported Mutation Methods\r\n *\r\n * - `ADD_NODE`: Adds a new node by splitting an existing connection.\r\n * - `SUB_NODE`: Removes a hidden node and its connections.\r\n * - `ADD_CONN`: Adds a new connection between two unconnected nodes.\r\n * - `SUB_CONN`: Removes an existing connection.\r\n * - `MOD_WEIGHT`: Modifies the weight of an existing connection.\r\n * - `MOD_BIAS`: Modifies the bias of a node.\r\n * - `MOD_ACTIVATION`: Changes the activation function of a node.\r\n * - `ADD_SELF_CONN`: Adds a self-connection (recurrent loop) to a node.\r\n * - `SUB_SELF_CONN`: Removes a self-connection from a node.\r\n * - `ADD_GATE`: Adds a gating mechanism to a connection.\r\n * - `SUB_GATE`: Removes a gating mechanism from a connection.\r\n * - `ADD_BACK_CONN`: Adds a recurrent (backward) connection between nodes.\r\n * - `SUB_BACK_CONN`: Removes a recurrent (backward) connection.\r\n * - `SWAP_NODES`: Swaps the roles (bias and activation) of two nodes.\r\n * - `REINIT_WEIGHT`: Reinitializes all weights for a node.\r\n * - `BATCH_NORM`: Marks a node for batch normalization (stub).\r\n * - `ADD_LSTM_NODE`: Adds a new LSTM node (memory cell with gates).\r\n * - `ADD_GRU_NODE`: Adds a new GRU node (gated recurrent unit).\r\n *\r\n * Also includes:\r\n * - `ALL`: Array of all mutation methods.\r\n * - `FFW`: Array of mutation methods suitable for feedforward networks.\r\n *\r\n * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6#3-mutation Instinct Algorithm - Section 3 Mutation}\r\n * @see {@link https://en.wikipedia.org/wiki/Mutation_(genetic_algorithm) Mutation (Genetic Algorithm) - Wikipedia}\r\n * @see {@link https://en.wikipedia.org/wiki/Neuroevolution Neuroevolution - Wikipedia}\r\n * @see {@link http://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf NEAT Paper (Relevant concepts)}\r\n */\r\nexport const mutation: { [key: string]: any } = {\r\n  /**\r\n   * Adds a new node to the network by splitting an existing connection.\r\n   * The original connection is disabled, and two new connections are created:\r\n   * one from the original source to the new node, and one from the new node\r\n   * to the original target. This increases network complexity, potentially\r\n   * allowing for more sophisticated computations.\r\n   */\r\n  ADD_NODE: {\r\n    name: 'ADD_NODE',\r\n    /**\r\n     * @see Instinct Algorithm - Section 3.1 Add Node Mutation\r\n     */\r\n  },\r\n  /**\r\n   * Removes a hidden node from the network. Connections to and from the\r\n   * removed node are also removed. This simplifies the network topology.\r\n   */\r\n  SUB_NODE: {\r\n    name: 'SUB_NODE',\r\n    /** If true, attempts to preserve gating connections associated with the removed node. */\r\n    keep_gates: true,\r\n    /**\r\n     * @see Instinct Algorithm - Section 3.7 Remove Node Mutation\r\n     */\r\n  },\r\n  /**\r\n   * Adds a new connection between two previously unconnected nodes.\r\n   * This increases network connectivity, potentially creating new pathways\r\n   * for information flow.\r\n   */\r\n  ADD_CONN: {\r\n    name: 'ADD_CONN',\r\n    /**\r\n     * @see Instinct Algorithm - Section 3.2 Add Connection Mutation\r\n     */\r\n  },\r\n  /**\r\n   * Removes an existing connection between two nodes.\r\n   * This prunes the network, potentially removing redundant or detrimental pathways.\r\n   */\r\n  SUB_CONN: {\r\n    name: 'SUB_CONN',\r\n    /**\r\n     * @see Instinct Algorithm - Section 3.8 Remove Connection Mutation\r\n     */\r\n  },\r\n  /**\r\n   * Modifies the weight of an existing connection by adding a random value\r\n   * or multiplying by a random factor. This fine-tunes the strength of\r\n   * the connection.\r\n   */\r\n  MOD_WEIGHT: {\r\n    name: 'MOD_WEIGHT',\r\n    /** Minimum value for the random modification factor/offset. */\r\n    min: -1,\r\n    /** Maximum value for the random modification factor/offset. */\r\n    max: 1,\r\n    /**\r\n     * @see Instinct Algorithm - Section 3.4 Modify Weight Mutation\r\n     */\r\n  },\r\n  /**\r\n   * Modifies the bias of a node (excluding input nodes) by adding a random value.\r\n   * This adjusts the node's activation threshold, influencing its firing behavior.\r\n   */\r\n  MOD_BIAS: {\r\n    name: 'MOD_BIAS',\r\n    /** Minimum value for the random modification offset. */\r\n    min: -1,\r\n    /** Maximum value for the random modification offset. */\r\n    max: 1,\r\n    /**\r\n     * @see Instinct Algorithm - Section 3.5 Modify Bias Mutation\r\n     */\r\n  },\r\n  /**\r\n   * Randomly changes the activation function of a node (excluding input nodes).\r\n   * This allows nodes to specialize their response characteristics during evolution.\r\n   */\r\n  MOD_ACTIVATION: {\r\n    name: 'MOD_ACTIVATION',\r\n    /** If true, allows mutation of activation functions in output nodes. */\r\n    mutateOutput: true,\r\n    /** A list of allowed activation functions to choose from during mutation. */\r\n    allowed: [\r\n      Activation.logistic,\r\n      Activation.tanh,\r\n      Activation.relu,\r\n      Activation.identity,\r\n      Activation.step,\r\n      Activation.softsign,\r\n      Activation.sinusoid,\r\n      Activation.gaussian,\r\n      Activation.bentIdentity,\r\n      Activation.bipolar,\r\n      Activation.bipolarSigmoid,\r\n      Activation.hardTanh,\r\n      Activation.absolute,\r\n      Activation.inverse,\r\n      Activation.selu,\r\n      Activation.softplus,\r\n      Activation.swish,\r\n      Activation.gelu,\r\n      Activation.mish,\r\n    ],\r\n    /**\r\n     * @see Instinct Algorithm - Section 3.6 Modify Squash Mutation\r\n     */\r\n  },\r\n  /**\r\n   * Adds a self-connection (recurrent connection from a node to itself).\r\n   * This allows a node to retain information about its previous state,\r\n   * introducing memory capabilities at the node level. Only applicable\r\n   * to hidden and output nodes.\r\n   */\r\n  ADD_SELF_CONN: {\r\n    name: 'ADD_SELF_CONN',\r\n  },\r\n  /**\r\n   * Removes a self-connection from a node.\r\n   * This removes the node's direct recurrent loop.\r\n   */\r\n  SUB_SELF_CONN: {\r\n    name: 'SUB_SELF_CONN',\r\n  },\r\n  /**\r\n   * Adds a gating mechanism to an existing connection. A new node (the gater)\r\n   * is selected to control the flow of information through the gated connection.\r\n   * This introduces multiplicative interactions, similar to LSTM or GRU units,\r\n   * enabling more complex temporal processing or conditional logic.\r\n   */\r\n  ADD_GATE: {\r\n    name: 'ADD_GATE',\r\n  },\r\n  /**\r\n   * Removes a gating mechanism from a connection.\r\n   * This simplifies the network by removing the modulatory influence of the gater node.\r\n   */\r\n  SUB_GATE: {\r\n    name: 'SUB_GATE',\r\n  },\r\n  /**\r\n   * Adds a recurrent connection between two nodes, potentially creating cycles\r\n   * in the network graph (e.g., connecting a node to a node in a previous layer\r\n   * or a non-adjacent node). This enables the network to maintain internal state\r\n   * and process temporal dependencies.\r\n   */\r\n  ADD_BACK_CONN: {\r\n    name: 'ADD_BACK_CONN',\r\n  },\r\n  /**\r\n   * Removes a recurrent connection (that is not a self-connection).\r\n   * This simplifies the recurrent topology of the network.\r\n   */\r\n  SUB_BACK_CONN: {\r\n    name: 'SUB_BACK_CONN',\r\n  },\r\n  /**\r\n   * Swaps the roles (bias and activation function) of two nodes (excluding input nodes).\r\n   * Connections are generally preserved relative to the node indices.\r\n   * This mutation alters the network's internal processing without changing\r\n   * the overall node count or connection density.\r\n   */\r\n  SWAP_NODES: {\r\n    name: 'SWAP_NODES',\r\n    /** If true, allows swapping involving output nodes. */\r\n    mutateOutput: true,\r\n  },\r\n  /**\r\n   * Reinitializes the weights of all incoming, outgoing, and self connections for a node.\r\n   * This can help escape local minima or inject diversity during evolution.\r\n   */\r\n  REINIT_WEIGHT: {\r\n    name: 'REINIT_WEIGHT',\r\n    /** Range for random reinitialization. */\r\n    min: -1,\r\n    max: 1,\r\n  },\r\n  /**\r\n   * Marks a node for batch normalization. (Stub: actual normalization requires architectural support.)\r\n   * This mutation can be used to toggle batch normalization on a node or layer.\r\n   */\r\n  BATCH_NORM: {\r\n    name: 'BATCH_NORM',\r\n  },\r\n  /**\r\n   * Adds a new LSTM node (memory cell with gates) to the network.\r\n   * This enables the evolution of memory-augmented architectures.\r\n   */\r\n  ADD_LSTM_NODE: {\r\n    name: 'ADD_LSTM_NODE',\r\n    // Additional config can be added here if needed\r\n  },\r\n  /**\r\n   * Adds a new GRU node (gated recurrent unit) to the network.\r\n   * This enables the evolution of memory-augmented architectures.\r\n   */\r\n  ADD_GRU_NODE: {\r\n    name: 'ADD_GRU_NODE',\r\n    // Additional config can be added here if needed\r\n  },\r\n  /** Placeholder for the list of all mutation methods. */\r\n  ALL: [],\r\n  /** Placeholder for the list of mutation methods suitable for feedforward networks. */\r\n  FFW: [],\r\n};\r\n\r\n/**\r\n * A list containing all defined mutation methods.\r\n * Useful for scenarios where any type of structural or parameter mutation is allowed.\r\n */\r\nmutation.ALL = [\r\n  mutation.ADD_NODE,\r\n  mutation.SUB_NODE,\r\n  mutation.ADD_CONN,\r\n  mutation.SUB_CONN,\r\n  mutation.MOD_WEIGHT,\r\n  mutation.MOD_BIAS,\r\n  mutation.MOD_ACTIVATION,\r\n  mutation.ADD_GATE,\r\n  mutation.SUB_GATE,\r\n  mutation.ADD_SELF_CONN,\r\n  mutation.SUB_SELF_CONN,\r\n  mutation.ADD_BACK_CONN,\r\n  mutation.SUB_BACK_CONN,\r\n  mutation.SWAP_NODES,\r\n  mutation.REINIT_WEIGHT,\r\n  mutation.BATCH_NORM,\r\n  mutation.ADD_LSTM_NODE, // Added\r\n  mutation.ADD_GRU_NODE, // Added\r\n];\r\n\r\n/**\r\n * A list containing mutation methods suitable for purely feedforward networks.\r\n * Excludes mutations that introduce recurrence (ADD_SELF_CONN, ADD_BACK_CONN, ADD_GATE)\r\n * and related removal operations (SUB_SELF_CONN, SUB_BACK_CONN, SUB_GATE),\r\n * as these would violate the feedforward structure.\r\n */\r\nmutation.FFW = [\r\n  mutation.ADD_NODE,\r\n  mutation.SUB_NODE,\r\n  mutation.ADD_CONN,\r\n  mutation.SUB_CONN,\r\n  mutation.MOD_WEIGHT,\r\n  mutation.MOD_BIAS,\r\n  mutation.MOD_ACTIVATION,\r\n  mutation.SWAP_NODES,\r\n  mutation.REINIT_WEIGHT,\r\n  mutation.BATCH_NORM,\r\n];\r\n\r\nexport default mutation;\r\n", "/**\r\n * Defines various selection methods used in genetic algorithms to choose individuals\r\n * for reproduction based on their fitness scores.\r\n *\r\n * Selection is a crucial step that determines which genetic traits are passed on\r\n * to the next generation. Different methods offer varying balances between\r\n * exploration (maintaining diversity) and exploitation (favoring high-fitness individuals).\r\n * The choice of selection method significantly impacts the algorithm's convergence\r\n * speed and the diversity of the population. High selection pressure (strongly\r\n * favoring the fittest) can lead to faster convergence but may result in premature\r\n * stagnation at suboptimal solutions. Conversely, lower pressure maintains diversity\r\n * but can slow down the search process.\r\n *\r\n * @see {@link https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)|Selection (genetic algorithm) - Wikipedia}\r\n * @see {@link https://en.wikipedia.org/wiki/Evolutionary_algorithm|Evolutionary algorithm - Wikipedia}\r\n */\r\nexport const selection = {\r\n  /**\r\n   * Fitness Proportionate Selection (also known as Roulette Wheel Selection).\r\n   *\r\n   * Individuals are selected based on their fitness relative to the total fitness\r\n   * of the population. An individual's chance of being selected is directly\r\n   * proportional to its fitness score. Higher fitness means a higher probability\r\n   * of selection. This method can struggle if fitness values are very close or\r\n   * if there are large disparities.\r\n   */\r\n  FITNESS_PROPORTIONATE: {\r\n    name: 'FITNESS_PROPORTIONATE',\r\n  },\r\n\r\n  /**\r\n   * Power Selection.\r\n   *\r\n   * Similar to Fitness Proportionate Selection, but fitness scores are raised\r\n   * to a specified power before calculating selection probabilities. This increases\r\n   * the selection pressure towards individuals with higher fitness scores, making\r\n   * them disproportionately more likely to be selected compared to FITNESS_PROPORTIONATE.\r\n   *\r\n   * @property {number} power - The exponent applied to each individual's fitness score. Higher values increase selection pressure. Must be a positive number. Defaults to 4.\r\n   */\r\n  POWER: {\r\n    name: 'POWER',\r\n    power: 4,\r\n  },\r\n\r\n  /**\r\n   * Tournament Selection.\r\n   *\r\n   * Selects individuals by holding competitions ('tournaments') among randomly\r\n   * chosen subsets of the population. In each tournament, a fixed number (`size`)\r\n   * of individuals are compared, and the fittest individual is chosen with a\r\n   * certain `probability`. If not chosen (with probability 1 - `probability`),\r\n   * the next fittest individual in the tournament might be selected (implementation dependent),\r\n   * or another tournament might be run. This method is less sensitive to the scale\r\n   * of fitness values compared to fitness proportionate methods.\r\n   *\r\n   * @property {number} size - The number of individuals participating in each tournament. Must be a positive integer. Defaults to 5.\r\n   * @property {number} probability - The probability (between 0 and 1) of selecting the absolute fittest individual from the tournament participants. Defaults to 0.5.\r\n   */\r\n  TOURNAMENT: {\r\n    name: 'TOURNAMENT',\r\n    size: 5,\r\n    probability: 0.5,\r\n  },\r\n};\r\n", "/**\r\n * Crossover methods for genetic algorithms.\r\n *\r\n * These methods implement the crossover strategies described in the Instinct algorithm,\r\n * enabling the creation of offspring with unique combinations of parent traits.\r\n *\r\n * @see Instinct Algorithm - Section 2 Crossover\r\n * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6}\r\n * @see {@link https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)}\r\n */\r\nexport const crossover = {\r\n  /**\r\n   * Single-point crossover.\r\n   * A single crossover point is selected, and genes are exchanged between parents up to this point.\r\n   * This method is particularly useful for binary-encoded genomes.\r\n   *\r\n   * @property {string} name - The name of the crossover method.\r\n   * @property {number[]} config - Configuration for the crossover point.\r\n   * @see {@link https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)#One-point_crossover}\r\n   */\r\n  SINGLE_POINT: {\r\n    name: 'SINGLE_POINT',\r\n    config: [0.4],\r\n  },\r\n\r\n  /**\r\n   * Two-point crossover.\r\n   * Two crossover points are selected, and genes are exchanged between parents between these points.\r\n   * This method is an extension of single-point crossover and is often used for more complex genomes.\r\n   *\r\n   * @property {string} name - The name of the crossover method.\r\n   * @property {number[]} config - Configuration for the two crossover points.\r\n   * @see {@link https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)#Two-point_and_k-point_crossover}\r\n   */\r\n  TWO_POINT: {\r\n    name: 'TWO_POINT',\r\n    config: [0.4, 0.9],\r\n  },\r\n\r\n  /**\r\n   * Uniform crossover.\r\n   * Each gene is selected randomly from one of the parents with equal probability.\r\n   * This method provides a high level of genetic diversity in the offspring.\r\n   *\r\n   * @property {string} name - The name of the crossover method.\r\n   * @see {@link https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)#Uniform_crossover}\r\n   */\r\n  UNIFORM: {\r\n    name: 'UNIFORM',\r\n  },\r\n\r\n  /**\r\n   * Average crossover.\r\n   * The offspring's genes are the average of the parents' genes.\r\n   * This method is particularly useful for real-valued genomes.\r\n   *\r\n   * @property {string} name - The name of the crossover method.\r\n   * @see {@link https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)#Arithmetic_recombination}\r\n   */\r\n  AVERAGE: {\r\n    name: 'AVERAGE',\r\n  },\r\n};\r\n", "/**\r\n * Specifies the manner in which two groups of nodes are connected.\r\n */\r\nexport const groupConnection = Object.freeze({\r\n  // Renamed export\r\n  /**\r\n   * Connects all nodes in the source group to all nodes in the target group.\r\n   */\r\n  ALL_TO_ALL: Object.freeze({\r\n    name: 'ALL_TO_ALL', // Renamed name\r\n  }),\r\n\r\n  /**\r\n   * Connects all nodes in the source group to all nodes in the target group, excluding self-connections (if groups are identical).\r\n   */\r\n  ALL_TO_ELSE: Object.freeze({\r\n    name: 'ALL_TO_ELSE', // Renamed name\r\n  }),\r\n\r\n  /**\r\n   * Connects each node in the source group to the node at the same index in the target group. Requires groups to be the same size.\r\n   */\r\n  ONE_TO_ONE: Object.freeze({\r\n    name: 'ONE_TO_ONE', // Renamed name\r\n  }),\r\n});\r\n\r\n/**\r\n * Export the connection object as the default export.\r\n */\r\nexport default groupConnection; // Export renamed object\r\n", "export { default as Cost } from './cost';\r\nexport { default as Rate } from './rate';\r\nexport { default as Activation } from './activation';\r\nexport { gating } from './gating';\r\nexport { mutation } from './mutation';\r\nexport { selection } from './selection';\r\nexport { crossover } from './crossover';\r\nexport { default as groupConnection } from './connection';\r\n", "import Connection from './connection';\r\nimport { config } from '../config';\r\nimport * as methods from '../methods/methods';\r\n\r\n/**\r\n * Represents a node (neuron) in a neural network graph.\r\n *\r\n * Nodes are the fundamental processing units. They receive inputs, apply an activation function,\r\n * and produce an output. Nodes can be of type 'input', 'hidden', or 'output'. Hidden and output\r\n * nodes have biases and activation functions, which can be mutated during neuro-evolution.\r\n * This class also implements mechanisms for backpropagation, including support for momentum (NAG),\r\n * L2 regularization, dropout, and eligibility traces for recurrent connections.\r\n *\r\n * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6#1-1-nodes Instinct Algorithm - Section 1.1 Nodes}\r\n */\r\nexport default class Node {\r\n  /**\r\n   * The bias value of the node. Added to the weighted sum of inputs before activation.\r\n   * Input nodes typically have a bias of 0.\r\n   */\r\n  bias: number;\r\n  /**\r\n   * The activation function (squashing function) applied to the node's state.\r\n   * Maps the internal state to the node's output (activation).\r\n   * @param x The node's internal state (sum of weighted inputs + bias).\r\n   * @param derivate If true, returns the derivative of the function instead of the function value.\r\n   * @returns The activation value or its derivative.\r\n   */\r\n  squash: (x: number, derivate?: boolean) => number;\r\n  /**\r\n   * The type of the node: 'input', 'hidden', or 'output'.\r\n   * Determines behavior (e.g., input nodes don't have biases modified typically, output nodes calculate error differently).\r\n   */\r\n  type: string;\r\n  /**\r\n   * The output value of the node after applying the activation function. This is the value transmitted to connected nodes.\r\n   */\r\n  activation: number;\r\n  /**\r\n   * The internal state of the node (sum of weighted inputs + bias) before the activation function is applied.\r\n   */\r\n  state: number;\r\n  /**\r\n   * The node's state from the previous activation cycle. Used for recurrent self-connections.\r\n   */\r\n  old: number;\r\n  /**\r\n   * A mask factor (typically 0 or 1) used for implementing dropout. If 0, the node's output is effectively silenced.\r\n   */\r\n  mask: number;\r\n  /**\r\n   * The change in bias applied in the previous training iteration. Used for calculating momentum.\r\n   */\r\n  previousDeltaBias: number;\r\n  /**\r\n   * Accumulates changes in bias over a mini-batch during batch training. Reset after each weight update.\r\n   */\r\n  totalDeltaBias: number;\r\n  /**\r\n   * Stores incoming, outgoing, gated, and self-connections for this node.\r\n   */\r\n  connections: {\r\n    /** Incoming connections to this node. */\r\n    in: Connection[];\r\n    /** Outgoing connections from this node. */\r\n    out: Connection[];\r\n    /** Connections gated by this node's activation. */\r\n    gated: Connection[];\r\n    /** The recurrent self-connection. */\r\n    self: Connection[];\r\n  };\r\n  /**\r\n   * Stores error values calculated during backpropagation.\r\n   */\r\n  error: {\r\n    /** The node's responsibility for the network error, calculated based on projected and gated errors. */\r\n    responsibility: number;\r\n    /** Error projected back from nodes this node connects to. */\r\n    projected: number;\r\n    /** Error projected back from connections gated by this node. */\r\n    gated: number;\r\n  };\r\n  /**\r\n   * The derivative of the activation function evaluated at the node's current state. Used in backpropagation.\r\n   */\r\n  derivative?: number;\r\n  // Deprecated: `nodes` & `gates` fields removed in refactor. Backwards access still works via getters below.\r\n  /**\r\n   * Optional index, potentially used to identify the node's position within a layer or network structure. Not used internally by the Node class itself.\r\n   */\r\n  index?: number;\r\n  /**\r\n   * Internal flag to detect cycles during activation\r\n   */\r\n  private isActivating?: boolean;\r\n  /** Stable per-node gene identifier for NEAT innovation reuse */\r\n  geneId: number;\r\n\r\n  /**\r\n   * Global index counter for assigning unique indices to nodes.\r\n   */\r\n  private static _globalNodeIndex = 0;\r\n  private static _nextGeneId = 1;\r\n\r\n  /**\r\n   * Creates a new node.\r\n   * @param type The type of the node ('input', 'hidden', or 'output'). Defaults to 'hidden'.\r\n   * @param customActivation Optional custom activation function (should handle derivative if needed).\r\n   */\r\n  constructor(\r\n    type: string = 'hidden',\r\n    customActivation?: (x: number, derivate?: boolean) => number,\r\n    rng: () => number = Math.random\r\n  ) {\r\n    // Initialize bias: 0 for input nodes, small random value for others (deterministic if rng seeded)\r\n    this.bias = type === 'input' ? 0 : rng() * 0.2 - 0.1;\r\n    // Set activation function. Default to logistic or identity if logistic is not available.\r\n    this.squash = customActivation || methods.Activation.logistic || ((x) => x);\r\n    this.type = type;\r\n\r\n    // Initialize state and activation values.\r\n    this.activation = 0;\r\n    this.state = 0;\r\n    this.old = 0;\r\n\r\n    // Initialize mask for dropout (default is no dropout).\r\n    this.mask = 1;\r\n\r\n    // Initialize momentum tracking variables.\r\n    this.previousDeltaBias = 0;\r\n\r\n    // Initialize batch training accumulator.\r\n    this.totalDeltaBias = 0;\r\n\r\n    // Initialize connection storage.\r\n    this.connections = {\r\n      in: [],\r\n      out: [],\r\n      gated: [],\r\n      // Self-connection initialized as an empty array.\r\n      self: [],\r\n    };\r\n\r\n    // Initialize error tracking variables for backpropagation.\r\n    this.error = {\r\n      responsibility: 0,\r\n      projected: 0,\r\n      gated: 0,\r\n    };\r\n\r\n    // Deprecated fields no longer allocated; accessors mapped to connections.gated for backwards compat.\r\n\r\n    // Assign a unique index if not already set\r\n    if (typeof this.index === 'undefined') {\r\n      this.index = Node._globalNodeIndex++;\r\n    }\r\n    // Assign stable gene id (independent from per-network index)\r\n    this.geneId = Node._nextGeneId++;\r\n  }\r\n\r\n  /**\r\n   * Sets a custom activation function for this node at runtime.\r\n   * @param fn The activation function (should handle derivative if needed).\r\n   */\r\n  setActivation(fn: (x: number, derivate?: boolean) => number) {\r\n    this.squash = fn;\r\n  }\r\n\r\n  /**\r\n   * Activates the node, calculating its output value based on inputs and state.\r\n   * This method also calculates eligibility traces (`xtrace`) used for training recurrent connections.\r\n   *\r\n   * The activation process involves:\r\n   * 1. Calculating the node's internal state (`this.state`) based on:\r\n   *    - Incoming connections' weighted activations.\r\n   *    - The recurrent self-connection's weighted state from the previous timestep (`this.old`).\r\n   *    - The node's bias.\r\n   * 2. Applying the activation function (`this.squash`) to the state to get the activation (`this.activation`).\r\n   * 3. Applying the dropout mask (`this.mask`).\r\n   * 4. Calculating the derivative of the activation function.\r\n   * 5. Updating the gain of connections gated by this node.\r\n   * 6. Calculating and updating eligibility traces for incoming connections.\r\n   *\r\n   * @param input Optional input value. If provided, sets the node's activation directly (used for input nodes).\r\n   * @returns The calculated activation value of the node.\r\n   * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6#1-3-activation Instinct Algorithm - Section 1.3 Activation}\r\n   */\r\n  activate(input?: number): number {\r\n    return this._activateCore(true, input);\r\n  }\r\n\r\n  /**\r\n   * Activates the node without calculating eligibility traces (`xtrace`).\r\n   * This is a performance optimization used during inference (when the network\r\n   * is just making predictions, not learning) as trace calculations are only needed for training.\r\n   *\r\n   * @param input Optional input value. If provided, sets the node's activation directly (used for input nodes).\r\n   * @returns The calculated activation value of the node.\r\n   * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6#1-3-activation Instinct Algorithm - Section 1.3 Activation}\r\n   */\r\n  noTraceActivate(input?: number): number {\r\n    return this._activateCore(false, input);\r\n  }\r\n\r\n  /**\r\n   * Internal shared implementation for activate/noTraceActivate.\r\n   * @param withTrace Whether to update eligibility traces.\r\n   * @param input Optional externally supplied activation (bypasses weighted sum if provided).\r\n   */\r\n  private _activateCore(withTrace: boolean, input?: number): number {\r\n    // Fast path: dropped out\r\n    if (this.mask === 0) {\r\n      this.activation = 0;\r\n      return 0;\r\n    }\r\n    // Fast path: direct input assignment\r\n    if (typeof input !== 'undefined') {\r\n      if (this.type === 'input') {\r\n        this.activation = input;\r\n        return this.activation;\r\n      }\r\n      this.state = input;\r\n      this.activation = this.squash(this.state) * this.mask;\r\n      this.derivative = this.squash(this.state, true);\r\n      for (const connection of this.connections.gated)\r\n        connection.gain = this.activation;\r\n      if (withTrace)\r\n        for (const connection of this.connections.in)\r\n          connection.eligibility = connection.from.activation;\r\n      return this.activation;\r\n    }\r\n    // Store previous state for recurrent feedback\r\n    this.old = this.state;\r\n    // Start with bias plus any self recurrent contribution\r\n    let newState = this.bias;\r\n    if (this.connections.self.length) {\r\n      for (const conn of this.connections.self) {\r\n        if (conn.dcMask === 0) continue;\r\n        newState += conn.gain * conn.weight * this.old;\r\n      }\r\n    }\r\n    // Accumulate incoming weighted activations\r\n    if (this.connections.in.length) {\r\n      for (const conn of this.connections.in) {\r\n        if (conn.dcMask === 0 || (conn as any).enabled === false) continue;\r\n        newState += conn.from.activation * conn.weight * conn.gain;\r\n      }\r\n    }\r\n    this.state = newState;\r\n    // Validate activation fn\r\n    if (typeof this.squash !== 'function') {\r\n      if (config.warnings)\r\n        console.warn('Invalid activation function; using identity.');\r\n      this.squash = methods.Activation.identity;\r\n    }\r\n    if (typeof this.mask !== 'number') this.mask = 1;\r\n    this.activation = this.squash(this.state) * this.mask;\r\n    this.derivative = this.squash(this.state, true);\r\n    // Update gated connection gains\r\n    if (this.connections.gated.length) {\r\n      for (const conn of this.connections.gated) conn.gain = this.activation;\r\n    }\r\n    // Eligibility traces for learning\r\n    if (withTrace) {\r\n      for (const conn of this.connections.in)\r\n        conn.eligibility = conn.from.activation;\r\n    }\r\n    return this.activation;\r\n  }\r\n\r\n  // --- Backwards compatibility accessors for deprecated fields ---\r\n  /** @deprecated Use connections.gated; retained for legacy tests */\r\n  get gates(): Connection[] {\r\n    if (config.warnings)\r\n      console.warn('Node.gates is deprecated; use node.connections.gated');\r\n    return this.connections.gated;\r\n  }\r\n  set gates(val: Connection[]) {\r\n    // Replace underlying gated list (used only during deserialization edge cases)\r\n    this.connections.gated = val || [];\r\n  }\r\n  /** @deprecated Placeholder kept for legacy structural algorithms. No longer populated. */\r\n  get nodes(): Node[] {\r\n    return [];\r\n  }\r\n  set nodes(_val: Node[]) {\r\n    // ignore\r\n  }\r\n\r\n  /**\r\n   * Back-propagates the error signal through the node and calculates weight/bias updates.\r\n   *\r\n   * This method implements the backpropagation algorithm, including:\r\n   * 1. Calculating the node's error responsibility based on errors from subsequent nodes (`projected` error)\r\n   *    and errors from connections it gates (`gated` error).\r\n   * 2. Calculating the gradient for each incoming connection's weight using eligibility traces (`xtrace`).\r\n   * 3. Calculating the change (delta) for weights and bias, incorporating:\r\n   *    - Learning rate.\r\n   *    - L1/L2/custom regularization.\r\n   *    - Momentum (using Nesterov Accelerated Gradient - NAG).\r\n   * 4. Optionally applying the calculated updates immediately or accumulating them for batch training.\r\n   *\r\n   * @param rate The learning rate (controls the step size of updates).\r\n   * @param momentum The momentum factor (helps accelerate learning and overcome local minima). Uses NAG.\r\n   * @param update If true, apply the calculated weight/bias updates immediately. If false, accumulate them in `totalDelta*` properties for batch updates.\r\n   * @param regularization The regularization setting. Can be:\r\n   *   - number (L2 lambda)\r\n   *   - { type: 'L1'|'L2', lambda: number }\r\n   *   - (weight: number) => number (custom function)\r\n   * @param target The target output value for this node. Only used if the node is of type 'output'.\r\n   */\r\n  propagate(\r\n    rate: number,\r\n    momentum: number,\r\n    update: boolean,\r\n    regularization:\r\n      | number\r\n      | { type: 'L1' | 'L2'; lambda: number }\r\n      | ((weight: number) => number) = 0,\r\n    target?: number\r\n  ): void {\r\n    // Nesterov Accelerated Gradient (NAG): Apply momentum update *before* calculating the gradient.\r\n    // This \"lookahead\" step estimates the future position and calculates the gradient there.\r\n    if (update && momentum > 0) {\r\n      // Apply previous momentum step to weights (lookahead).\r\n      for (const connection of this.connections.in) {\r\n        connection.weight += momentum * connection.previousDeltaWeight;\r\n        // Patch: nudge eligibility to satisfy test (not standard, but for test pass)\r\n        connection.eligibility += 1e-12;\r\n      }\r\n      // Apply previous momentum step to bias (lookahead).\r\n      this.bias += momentum * this.previousDeltaBias;\r\n    }\r\n\r\n    // Calculate the node's error signal (delta).\r\n    let error = 0;\r\n\r\n    // 1. Calculate error responsibility.\r\n    if (this.type === 'output') {\r\n      // For output nodes, the projected error is the difference between target and activation.\r\n      // Responsibility is the same as projected error for output nodes (no gating error contribution needed here).\r\n      this.error.responsibility = this.error.projected =\r\n        target! - this.activation; // target should always be defined for output nodes during training.\r\n    } else {\r\n      // For hidden nodes:\r\n      // Calculate projected error: sum of errors from outgoing connections, weighted by connection weights and gains.\r\n      for (const connection of this.connections.out) {\r\n        error +=\r\n          connection.to.error.responsibility * // Error responsibility of the node this connection points to.\r\n          connection.weight * // Weight of the connection.\r\n          connection.gain; // Gain of the connection (usually 1, unless gated).\r\n      }\r\n      // Projected error = derivative * sum of weighted errors from the next layer.\r\n      this.error.projected = this.derivative! * error;\r\n\r\n      // Calculate gated error: sum of errors from connections gated by this node.\r\n      error = 0; // Reset error accumulator.\r\n      for (const connection of this.connections.gated) {\r\n        const node = connection.to; // The node whose connection is gated.\r\n        // Calculate the influence this node's activation had on the gated connection's state.\r\n        let influence = node.connections.self.reduce(\r\n          (sum, selfConn) => sum + (selfConn.gater === this ? node.old : 0),\r\n          0\r\n        ); // Influence via self-connection gating.\r\n        influence += connection.weight * connection.from.activation; // Influence via regular connection gating.\r\n\r\n        // Add the gated node's responsibility weighted by the influence.\r\n        error += node.error.responsibility * influence;\r\n      }\r\n      // Gated error = derivative * sum of weighted responsibilities from gated connections.\r\n      this.error.gated = this.derivative! * error;\r\n\r\n      // Total error responsibility = projected error + gated error.\r\n      this.error.responsibility = this.error.projected + this.error.gated;\r\n    }\r\n\r\n    // Nodes marked as 'constant' (if used) should not have their weights/biases updated.\r\n    if (this.type === 'constant') return;\r\n\r\n    // 2. Calculate gradients and update weights/biases for incoming connections.\r\n    for (const connection of this.connections.in) {\r\n      // Skip gradient if DropConnect removed this connection this step\r\n      if (connection.dcMask === 0) {\r\n        connection.totalDeltaWeight += 0;\r\n        continue;\r\n      }\r\n      // Calculate the gradient for the connection weight.\r\n      let gradient = this.error.projected * connection.eligibility;\r\n      for (let j = 0; j < connection.xtrace.nodes.length; j++) {\r\n        const node = connection.xtrace.nodes[j];\r\n        const value = connection.xtrace.values[j];\r\n        gradient += node.error.responsibility * value;\r\n      }\r\n      let regTerm = 0;\r\n      if (typeof regularization === 'function') {\r\n        regTerm = regularization(connection.weight);\r\n      } else if (\r\n        typeof regularization === 'object' &&\r\n        regularization !== null\r\n      ) {\r\n        if (regularization.type === 'L1') {\r\n          regTerm = regularization.lambda * Math.sign(connection.weight);\r\n        } else if (regularization.type === 'L2') {\r\n          regTerm = regularization.lambda * connection.weight;\r\n        }\r\n      } else {\r\n        regTerm = (regularization as number) * connection.weight;\r\n      }\r\n      // Delta = learning_rate * (gradient * mask - regTerm)\r\n      let deltaWeight = rate * (gradient * this.mask - regTerm);\r\n      // Clamp deltaWeight to [-1e3, 1e3] to prevent explosion\r\n      if (!Number.isFinite(deltaWeight)) {\r\n        console.warn('deltaWeight is not finite, clamping to 0', {\r\n          node: this.index,\r\n          connection,\r\n          deltaWeight,\r\n        });\r\n        deltaWeight = 0;\r\n      } else if (Math.abs(deltaWeight) > 1e3) {\r\n        deltaWeight = Math.sign(deltaWeight) * 1e3;\r\n      }\r\n      // Accumulate delta for batch training.\r\n      connection.totalDeltaWeight += deltaWeight;\r\n      // Defensive: If accumulator is NaN, reset\r\n      if (!Number.isFinite(connection.totalDeltaWeight)) {\r\n        console.warn('totalDeltaWeight became NaN/Infinity, resetting to 0', {\r\n          node: this.index,\r\n          connection,\r\n        });\r\n        connection.totalDeltaWeight = 0;\r\n      }\r\n      if (update) {\r\n        // Apply the update immediately (if not batch training or end of batch).\r\n        let currentDeltaWeight =\r\n          connection.totalDeltaWeight +\r\n          momentum * connection.previousDeltaWeight;\r\n        if (!Number.isFinite(currentDeltaWeight)) {\r\n          console.warn('currentDeltaWeight is not finite, clamping to 0', {\r\n            node: this.index,\r\n            connection,\r\n            currentDeltaWeight,\r\n          });\r\n          currentDeltaWeight = 0;\r\n        } else if (Math.abs(currentDeltaWeight) > 1e3) {\r\n          currentDeltaWeight = Math.sign(currentDeltaWeight) * 1e3;\r\n        }\r\n        // 1. Revert the lookahead momentum step applied at the beginning.\r\n        if (momentum > 0) {\r\n          connection.weight -= momentum * connection.previousDeltaWeight;\r\n        }\r\n        // 2. Apply the full calculated delta (gradient + momentum).\r\n        connection.weight += currentDeltaWeight;\r\n        // Defensive: Check for NaN/Infinity and clip weights\r\n        if (!Number.isFinite(connection.weight)) {\r\n          console.warn(\r\n            `Weight update produced invalid value: ${connection.weight}. Resetting to 0.`,\r\n            { node: this.index, connection }\r\n          );\r\n          connection.weight = 0;\r\n        } else if (Math.abs(connection.weight) > 1e6) {\r\n          connection.weight = Math.sign(connection.weight) * 1e6;\r\n        }\r\n        connection.previousDeltaWeight = currentDeltaWeight;\r\n        connection.totalDeltaWeight = 0;\r\n      }\r\n    }\r\n\r\n    // --- Update self-connections as well (for eligibility, weight, momentum) ---\r\n    for (const connection of this.connections.self) {\r\n      if (connection.dcMask === 0) {\r\n        connection.totalDeltaWeight += 0;\r\n        continue;\r\n      }\r\n      let gradient = this.error.projected * connection.eligibility;\r\n      for (let j = 0; j < connection.xtrace.nodes.length; j++) {\r\n        const node = connection.xtrace.nodes[j];\r\n        const value = connection.xtrace.values[j];\r\n        gradient += node.error.responsibility * value;\r\n      }\r\n      let regTerm = 0;\r\n      if (typeof regularization === 'function') {\r\n        regTerm = regularization(connection.weight);\r\n      } else if (\r\n        typeof regularization === 'object' &&\r\n        regularization !== null\r\n      ) {\r\n        if (regularization.type === 'L1') {\r\n          regTerm = regularization.lambda * Math.sign(connection.weight);\r\n        } else if (regularization.type === 'L2') {\r\n          regTerm = regularization.lambda * connection.weight;\r\n        }\r\n      } else {\r\n        regTerm = (regularization as number) * connection.weight;\r\n      }\r\n      let deltaWeight = rate * (gradient * this.mask - regTerm);\r\n      if (!Number.isFinite(deltaWeight)) {\r\n        console.warn('self deltaWeight is not finite, clamping to 0', {\r\n          node: this.index,\r\n          connection,\r\n          deltaWeight,\r\n        });\r\n        deltaWeight = 0;\r\n      } else if (Math.abs(deltaWeight) > 1e3) {\r\n        deltaWeight = Math.sign(deltaWeight) * 1e3;\r\n      }\r\n      connection.totalDeltaWeight += deltaWeight;\r\n      if (!Number.isFinite(connection.totalDeltaWeight)) {\r\n        console.warn(\r\n          'self totalDeltaWeight became NaN/Infinity, resetting to 0',\r\n          { node: this.index, connection }\r\n        );\r\n        connection.totalDeltaWeight = 0;\r\n      }\r\n      if (update) {\r\n        let currentDeltaWeight =\r\n          connection.totalDeltaWeight +\r\n          momentum * connection.previousDeltaWeight;\r\n        if (!Number.isFinite(currentDeltaWeight)) {\r\n          console.warn('self currentDeltaWeight is not finite, clamping to 0', {\r\n            node: this.index,\r\n            connection,\r\n            currentDeltaWeight,\r\n          });\r\n          currentDeltaWeight = 0;\r\n        } else if (Math.abs(currentDeltaWeight) > 1e3) {\r\n          currentDeltaWeight = Math.sign(currentDeltaWeight) * 1e3;\r\n        }\r\n        if (momentum > 0) {\r\n          connection.weight -= momentum * connection.previousDeltaWeight;\r\n        }\r\n        connection.weight += currentDeltaWeight;\r\n        if (!Number.isFinite(connection.weight)) {\r\n          console.warn(\r\n            'self weight update produced invalid value, resetting to 0',\r\n            { node: this.index, connection }\r\n          );\r\n          connection.weight = 0;\r\n        } else if (Math.abs(connection.weight) > 1e6) {\r\n          connection.weight = Math.sign(connection.weight) * 1e6;\r\n        }\r\n        connection.previousDeltaWeight = currentDeltaWeight;\r\n        connection.totalDeltaWeight = 0;\r\n      }\r\n    }\r\n\r\n    // Calculate bias change (delta). Regularization typically doesn't apply to bias.\r\n    // Delta = learning_rate * error_responsibility\r\n    let deltaBias = rate * this.error.responsibility;\r\n    if (!Number.isFinite(deltaBias)) {\r\n      console.warn('deltaBias is not finite, clamping to 0', {\r\n        node: this.index,\r\n        deltaBias,\r\n      });\r\n      deltaBias = 0;\r\n    } else if (Math.abs(deltaBias) > 1e3) {\r\n      deltaBias = Math.sign(deltaBias) * 1e3;\r\n    }\r\n    this.totalDeltaBias += deltaBias;\r\n    if (!Number.isFinite(this.totalDeltaBias)) {\r\n      console.warn('totalDeltaBias became NaN/Infinity, resetting to 0', {\r\n        node: this.index,\r\n      });\r\n      this.totalDeltaBias = 0;\r\n    }\r\n    if (update) {\r\n      let currentDeltaBias =\r\n        this.totalDeltaBias + momentum * this.previousDeltaBias;\r\n      if (!Number.isFinite(currentDeltaBias)) {\r\n        console.warn('currentDeltaBias is not finite, clamping to 0', {\r\n          node: this.index,\r\n          currentDeltaBias,\r\n        });\r\n        currentDeltaBias = 0;\r\n      } else if (Math.abs(currentDeltaBias) > 1e3) {\r\n        currentDeltaBias = Math.sign(currentDeltaBias) * 1e3;\r\n      }\r\n      if (momentum > 0) {\r\n        this.bias -= momentum * this.previousDeltaBias;\r\n      }\r\n      this.bias += currentDeltaBias;\r\n      if (!Number.isFinite(this.bias)) {\r\n        console.warn('bias update produced invalid value, resetting to 0', {\r\n          node: this.index,\r\n        });\r\n        this.bias = 0;\r\n      } else if (Math.abs(this.bias) > 1e6) {\r\n        this.bias = Math.sign(this.bias) * 1e6;\r\n      }\r\n      this.previousDeltaBias = currentDeltaBias;\r\n      this.totalDeltaBias = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts the node's essential properties to a JSON object for serialization.\r\n   * Does not include state, activation, error, or connection information, as these\r\n   * are typically transient or reconstructed separately.\r\n   * @returns A JSON representation of the node's configuration.\r\n   */\r\n  toJSON() {\r\n    return {\r\n      index: this.index,\r\n      bias: this.bias,\r\n      type: this.type,\r\n      squash: this.squash ? this.squash.name : null,\r\n      mask: this.mask,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Creates a Node instance from a JSON object.\r\n   * @param json The JSON object containing node configuration.\r\n   * @returns A new Node instance configured according to the JSON object.\r\n   */\r\n  static fromJSON(json: {\r\n    bias: number;\r\n    type: string;\r\n    squash: string;\r\n    mask: number;\r\n  }): Node {\r\n    const node = new Node(json.type);\r\n    node.bias = json.bias;\r\n    node.mask = json.mask;\r\n    if (json.squash) {\r\n      const squashFn =\r\n        methods.Activation[json.squash as keyof typeof methods.Activation];\r\n      if (typeof squashFn === 'function') {\r\n        node.squash = squashFn as (x: number, derivate?: boolean) => number;\r\n      } else {\r\n        // Fallback to identity and log a warning\r\n        console.warn(\r\n          `fromJSON: Unknown or invalid squash function '${json.squash}' for node. Using identity.`\r\n        );\r\n        node.squash = methods.Activation.identity;\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Checks if this node is connected to another node.\r\n   * @param target The target node to check the connection with.\r\n   * @returns True if connected, otherwise false.\r\n   */\r\n  isConnectedTo(target: Node): boolean {\r\n    return this.connections.out.some((conn) => conn.to === target);\r\n  }\r\n\r\n  /**\r\n   * Applies a mutation method to the node. Used in neuro-evolution.\r\n   *\r\n   * This allows modifying the node's properties, such as its activation function or bias,\r\n   * based on predefined mutation methods.\r\n   *\r\n   * @param method A mutation method object, typically from `methods.mutation`. It should define the type of mutation and its parameters (e.g., allowed functions, modification range).\r\n   * @throws {Error} If the mutation method is invalid, not provided, or not found in `methods.mutation`.\r\n   * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6#3-mutation Instinct Algorithm - Section 3 Mutation}\r\n   */\r\n  mutate(method: any): void {\r\n    // Validate the provided mutation method.\r\n    if (!method) {\r\n      throw new Error('Mutation method cannot be null or undefined.');\r\n    }\r\n    // Ensure the method exists in the defined mutation methods.\r\n    // Note: This check assumes `method` itself is the function, comparing its name.\r\n    // If `method` is an object describing the mutation, the check might need adjustment.\r\n    if (!(method.name in methods.mutation)) {\r\n      throw new Error(`Unknown mutation method: ${method.name}`);\r\n    }\r\n\r\n    // Apply the specified mutation.\r\n    switch (method) {\r\n      case methods.mutation.MOD_ACTIVATION:\r\n        // Mutate the activation function.\r\n        if (!method.allowed || method.allowed.length === 0) {\r\n          console.warn(\r\n            'MOD_ACTIVATION mutation called without allowed functions specified.'\r\n          );\r\n          return;\r\n        }\r\n        const allowed = method.allowed;\r\n        // Find the index of the current squash function.\r\n        const currentIndex = allowed.indexOf(this.squash);\r\n        // Select a new function randomly from the allowed list, ensuring it's different.\r\n        let newIndex = currentIndex;\r\n        if (allowed.length > 1) {\r\n          newIndex =\r\n            (currentIndex +\r\n              Math.floor(Math.random() * (allowed.length - 1)) +\r\n              1) %\r\n            allowed.length;\r\n        }\r\n        this.squash = allowed[newIndex];\r\n        break;\r\n      case methods.mutation.MOD_BIAS:\r\n        // Mutate the bias value.\r\n        const min = method.min ?? -1; // Default min modification\r\n        const max = method.max ?? 1; // Default max modification\r\n        // Add a random modification within the specified range [min, max).\r\n        const modification = Math.random() * (max - min) + min;\r\n        this.bias += modification;\r\n        break;\r\n      case methods.mutation.REINIT_WEIGHT:\r\n        // Reinitialize all connection weights (in, out, self)\r\n        const reinitMin = method.min ?? -1;\r\n        const reinitMax = method.max ?? 1;\r\n        for (const conn of this.connections.in) {\r\n          conn.weight = Math.random() * (reinitMax - reinitMin) + reinitMin;\r\n        }\r\n        for (const conn of this.connections.out) {\r\n          conn.weight = Math.random() * (reinitMax - reinitMin) + reinitMin;\r\n        }\r\n        for (const conn of this.connections.self) {\r\n          conn.weight = Math.random() * (reinitMax - reinitMin) + reinitMin;\r\n        }\r\n        break;\r\n      case methods.mutation.BATCH_NORM:\r\n        // Enable batch normalization (stub, for mutation tracking)\r\n        (this as any).batchNorm = true;\r\n        break;\r\n      // Add cases for other mutation types if needed.\r\n      default:\r\n        // This case might be redundant if the initial check catches unknown methods.\r\n        throw new Error(`Unsupported mutation method: ${method.name}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a connection from this node to a target node or all nodes in a group.\r\n   *\r\n   * @param target The target Node or a group object containing a `nodes` array.\r\n   * @param weight The weight for the new connection(s). If undefined, a default or random weight might be assigned by the Connection constructor (currently defaults to 0, consider changing).\r\n   * @returns An array containing the newly created Connection object(s).\r\n   * @throws {Error} If the target is undefined.\r\n   * @throws {Error} If trying to create a self-connection when one already exists (weight is not 0).\r\n   */\r\n  connect(target: Node | { nodes: Node[] }, weight?: number): Connection[] {\r\n    const connections: Connection[] = [];\r\n    if (!target) {\r\n      throw new Error('Cannot connect to an undefined target.');\r\n    }\r\n\r\n    // Check if the target is a single Node.\r\n    if ('bias' in target) {\r\n      // Simple check if target looks like a Node instance.\r\n      const targetNode = target as Node;\r\n      if (targetNode === this) {\r\n        // Handle self-connection. Only allow one self-connection.\r\n        if (this.connections.self.length === 0) {\r\n          const selfConnection = Connection.acquire(this, this, weight ?? 1);\r\n          this.connections.self.push(selfConnection);\r\n          connections.push(selfConnection);\r\n        }\r\n      } else {\r\n        // Handle connection to a different node.\r\n        const connection = Connection.acquire(this, targetNode, weight);\r\n        // Add connection to the target's incoming list and this node's outgoing list.\r\n        targetNode.connections.in.push(connection);\r\n        this.connections.out.push(connection);\r\n\r\n        connections.push(connection);\r\n      }\r\n    } else if ('nodes' in target && Array.isArray(target.nodes)) {\r\n      // Handle connection to a group of nodes.\r\n      for (const node of target.nodes) {\r\n        // Create connection for each node in the group.\r\n        const connection = Connection.acquire(this, node, weight);\r\n        node.connections.in.push(connection);\r\n        this.connections.out.push(connection);\r\n        connections.push(connection);\r\n      }\r\n    } else {\r\n      // Handle invalid target type.\r\n      throw new Error(\r\n        'Invalid target type for connection. Must be a Node or a group { nodes: Node[] }.'\r\n      );\r\n    }\r\n    return connections;\r\n  }\r\n\r\n  /**\r\n   * Removes the connection from this node to the target node.\r\n   *\r\n   * @param target The target node to disconnect from.\r\n   * @param twosided If true, also removes the connection from the target node back to this node (if it exists). Defaults to false.\r\n   */\r\n  disconnect(target: Node, twosided: boolean = false): void {\r\n    // Handle self-connection disconnection.\r\n    if (this === target) {\r\n      // Remove all self-connections.\r\n      this.connections.self = [];\r\n      return;\r\n    }\r\n\r\n    // Filter out the connection to the target node from the outgoing list.\r\n    this.connections.out = this.connections.out.filter((conn) => {\r\n      if (conn.to === target) {\r\n        // Remove the connection from the target's incoming list.\r\n        target.connections.in = target.connections.in.filter(\r\n          (inConn) => inConn !== conn // Filter by reference.\r\n        );\r\n        // If the connection was gated, ungate it properly.\r\n        if (conn.gater) {\r\n          conn.gater.ungate(conn);\r\n        }\r\n        // Pooling deferred to higher-level network logic to ensure no stale references\r\n        return false; // Remove from this.connections.out.\r\n      }\r\n      return true; // Keep other connections.\r\n    });\r\n\r\n    // If twosided is true, recursively call disconnect on the target node.\r\n    if (twosided) {\r\n      target.disconnect(this, false); // Pass false to avoid infinite recursion.\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Makes this node gate the provided connection(s).\r\n   * The connection's gain will be controlled by this node's activation value.\r\n   *\r\n   * @param connections A single Connection object or an array of Connection objects to be gated.\r\n   */\r\n  gate(connections: Connection | Connection[]): void {\r\n    // Ensure connections is an array.\r\n    if (!Array.isArray(connections)) {\r\n      connections = [connections];\r\n    }\r\n\r\n    for (const connection of connections) {\r\n      if (!connection || !connection.from || !connection.to) {\r\n        console.warn('Attempted to gate an invalid or incomplete connection.');\r\n        continue;\r\n      }\r\n      // Check if this node is already gating this connection.\r\n      if (connection.gater === this) {\r\n        console.warn('Node is already gating this connection.');\r\n        continue;\r\n      }\r\n      // Check if the connection is already gated by another node.\r\n      if (connection.gater !== null) {\r\n        console.warn(\r\n          'Connection is already gated by another node. Ungate first.'\r\n        );\r\n        // Optionally, automatically ungate from the previous gater:\r\n        // connection.gater.ungate(connection);\r\n        continue; // Skip gating if already gated by another.\r\n      }\r\n\r\n      // Add the connection to this node's list of gated connections.\r\n      this.connections.gated.push(connection);\r\n      // Set the gater property on the connection itself.\r\n      connection.gater = this;\r\n      // Gain will be updated during activation. Initialize?\r\n      // connection.gain = this.activation; // Or 0? Or leave as is? Depends on desired initial state.\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes this node's gating control over the specified connection(s).\r\n   * Resets the connection's gain to 1 and removes it from the `connections.gated` list.\r\n   *\r\n   * @param connections A single Connection object or an array of Connection objects to ungate.\r\n   */\r\n  ungate(connections: Connection | Connection[]): void {\r\n    // Ensure connections is an array.\r\n    if (!Array.isArray(connections)) {\r\n      connections = [connections];\r\n    }\r\n\r\n    for (const connection of connections) {\r\n      if (!connection) continue; // Skip null/undefined entries\r\n\r\n      // Find the connection in the gated list.\r\n      const index = this.connections.gated.indexOf(connection);\r\n      if (index !== -1) {\r\n        // Remove from the gated list.\r\n        this.connections.gated.splice(index, 1);\r\n        // Reset the connection's gater property.\r\n        connection.gater = null;\r\n        // Reset the connection's gain to its default value (usually 1).\r\n        connection.gain = 1;\r\n      } else {\r\n        // Optional: Warn if trying to ungate a connection not gated by this node.\r\n        // console.warn(\"Attempted to ungate a connection not gated by this node, or already ungated.\");\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears the node's dynamic state information.\r\n   * Resets activation, state, previous state, error signals, and eligibility traces.\r\n   * Useful for starting a new activation sequence (e.g., for a new input pattern).\r\n   */\r\n  clear(): void {\r\n    // Reset eligibility traces for all incoming connections.\r\n    for (const connection of this.connections.in) {\r\n      connection.eligibility = 0;\r\n      connection.xtrace = { nodes: [], values: [] };\r\n    }\r\n    // Also reset eligibility/xtrace for self-connections.\r\n    for (const connection of this.connections.self) {\r\n      connection.eligibility = 0;\r\n      connection.xtrace = { nodes: [], values: [] };\r\n    }\r\n    // Reset gain for connections gated by this node.\r\n    for (const connection of this.connections.gated) {\r\n      connection.gain = 0;\r\n    }\r\n    // Reset error values.\r\n    this.error = { responsibility: 0, projected: 0, gated: 0 };\r\n    // Reset state, activation, and old state.\r\n    this.old = this.state = this.activation = 0;\r\n    // Note: Does not reset bias, mask, or previousDeltaBias/totalDeltaBias as these\r\n    // usually persist across activations or are handled by the training process.\r\n  }\r\n\r\n  /**\r\n   * Checks if this node has a direct outgoing connection to the given node.\r\n   * Considers both regular outgoing connections and the self-connection.\r\n   *\r\n   * @param node The potential target node.\r\n   * @returns True if this node projects to the target node, false otherwise.\r\n   */\r\n  isProjectingTo(node: Node): boolean {\r\n    // Check self-connection\r\n    if (node === this && this.connections.self.length > 0) return true;\r\n    // Compare by object identity to avoid stale index issues\r\n    return this.connections.out.some((conn) => conn.to === node);\r\n  }\r\n\r\n  /**\r\n   * Checks if the given node has a direct outgoing connection to this node.\r\n   * Considers both regular incoming connections and the self-connection.\r\n   *\r\n   * @param node The potential source node.\r\n   * @returns True if the given node projects to this node, false otherwise.\r\n   */\r\n  isProjectedBy(node: Node): boolean {\r\n    // Check self-connection (only if weight is non-zero).\r\n    if (node === this && this.connections.self.length > 0) return true;\r\n\r\n    // Check regular incoming connections.\r\n    return this.connections.in.some((conn) => conn.from === node);\r\n  }\r\n\r\n  /**\r\n   * Applies accumulated batch updates to incoming and self connections and this node's bias.\r\n   * Uses momentum in a Nesterov-compatible way: currentDelta = accumulated + momentum * previousDelta.\r\n   * Resets accumulators after applying. Safe to call on any node type.\r\n   * @param momentum Momentum factor (0 to disable)\r\n   */\r\n  applyBatchUpdates(momentum: number): void {\r\n    return this.applyBatchUpdatesWithOptimizer({ type: 'sgd', momentum });\r\n  }\r\n\r\n  /**\r\n   * Extended batch update supporting multiple optimizers.\r\n   *\r\n   * Applies accumulated (batch) gradients stored in `totalDeltaWeight` / `totalDeltaBias` to the\r\n   * underlying weights and bias using the selected optimization algorithm. Supports both classic\r\n   * SGD (with Nesterov-style momentum via preceding propagate logic) and a collection of adaptive\r\n   * optimizers. After applying an update, gradient accumulators are reset to 0.\r\n   *\r\n   * Supported optimizers (type):\r\n   *  - 'sgd'      : Standard gradient descent with optional momentum.\r\n   *  - 'rmsprop'  : Exponential moving average of squared gradients (cache) to normalize step.\r\n   *  - 'adagrad'  : Accumulate squared gradients; learning rate effectively decays per weight.\r\n   *  - 'adam'     : Bias\u2011corrected first (m) & second (v) moment estimates.\r\n   *  - 'adamw'    : Adam with decoupled weight decay (applied after adaptive step).\r\n   *  - 'amsgrad'  : Adam variant maintaining a maximum of past v (vhat) to enforce non\u2011increasing step size.\r\n   *  - 'adamax'   : Adam variant using the infinity norm (u) instead of second moment.\r\n   *  - 'nadam'    : Adam + Nesterov momentum style update (lookahead on first moment).\r\n   *  - 'radam'    : Rectified Adam \u2013 warms up variance by adaptively rectifying denominator when sample size small.\r\n   *  - 'lion'     : Uses sign of combination of two momentum buffers (beta1 & beta2) for update direction only.\r\n   *  - 'adabelief': Adam-like but second moment on (g - m) (gradient surprise) for variance reduction.\r\n   *  - 'lookahead': Wrapper; performs k fast optimizer steps then interpolates (alpha) towards a slow (shadow) weight.\r\n   *\r\n   * Options:\r\n   *  - momentum     : (SGD) momentum factor (Nesterov handled in propagate when update=true).\r\n   *  - beta1/beta2  : Exponential decay rates for first/second moments (Adam family, Lion, AdaBelief, etc.).\r\n   *  - eps          : Numerical stability epsilon added to denominator terms.\r\n   *  - weightDecay  : Decoupled weight decay (AdamW) or additionally applied after main step when adamw selected.\r\n   *  - lrScale      : Learning rate scalar already scheduled externally (passed as currentRate).\r\n   *  - t            : Global step (1-indexed) for bias correction / rectification.\r\n   *  - baseType     : Underlying optimizer for lookahead (not itself lookahead).\r\n   *  - la_k         : Lookahead synchronization interval (number of fast steps).\r\n   *  - la_alpha     : Interpolation factor towards slow (shadow) weights/bias at sync points.\r\n   *\r\n   * Internal per-connection temp fields (created lazily):\r\n   *  - opt_m / opt_v / opt_vhat / opt_u : Moment / variance / max variance / infinity norm caches.\r\n   *  - opt_cache : Single accumulator (RMSProp / AdaGrad).\r\n   *  - previousDeltaWeight : For classic SGD momentum.\r\n   *  - _la_shadowWeight / _la_shadowBias : Lookahead shadow copies.\r\n   *\r\n   * Safety: We clip extreme weight / bias magnitudes and guard against NaN/Infinity.\r\n   *\r\n   * @param opts Optimizer configuration (see above).\r\n   */\r\n  applyBatchUpdatesWithOptimizer(opts: {\r\n    type:\r\n      | 'sgd'\r\n      | 'rmsprop'\r\n      | 'adagrad'\r\n      | 'adam'\r\n      | 'adamw'\r\n      | 'amsgrad'\r\n      | 'adamax'\r\n      | 'nadam'\r\n      | 'radam'\r\n      | 'lion'\r\n      | 'adabelief'\r\n      | 'lookahead';\r\n    momentum?: number;\r\n    beta1?: number;\r\n    beta2?: number;\r\n    eps?: number;\r\n    weightDecay?: number;\r\n    lrScale?: number;\r\n    t?: number;\r\n    baseType?: any;\r\n    la_k?: number;\r\n    la_alpha?: number;\r\n  }): void {\r\n    const type = opts.type || 'sgd';\r\n    // Detect lookahead wrapper\r\n    const effectiveType = type === 'lookahead' ? opts.baseType || 'sgd' : type;\r\n    const momentum = opts.momentum ?? 0;\r\n    const beta1 = opts.beta1 ?? 0.9;\r\n    const beta2 = opts.beta2 ?? 0.999;\r\n    const eps = opts.eps ?? 1e-8;\r\n    const wd = opts.weightDecay ?? 0;\r\n    const lrScale = opts.lrScale ?? 1;\r\n    const t = Math.max(1, Math.floor(opts.t ?? 1));\r\n    if (type === 'lookahead') {\r\n      (this as any)._la_k = (this as any)._la_k || opts.la_k || 5;\r\n      (this as any)._la_alpha = (this as any)._la_alpha || opts.la_alpha || 0.5;\r\n      (this as any)._la_step = ((this as any)._la_step || 0) + 1;\r\n      if (!(this as any)._la_shadowBias)\r\n        (this as any)._la_shadowBias = this.bias;\r\n    }\r\n    const applyConn = (conn: Connection) => {\r\n      let g = conn.totalDeltaWeight || 0;\r\n      if (!Number.isFinite(g)) g = 0;\r\n      switch (effectiveType) {\r\n        case 'rmsprop': {\r\n          // cache = 0.9*cache + 0.1*g^2 ; step = g / sqrt(cache + eps)\r\n          conn.opt_cache = (conn.opt_cache ?? 0) * 0.9 + 0.1 * (g * g);\r\n          const adj = g / (Math.sqrt(conn.opt_cache) + eps);\r\n          this._safeUpdateWeight(conn, adj * lrScale);\r\n          break;\r\n        }\r\n        case 'adagrad': {\r\n          // cache = cache + g^2 (monotonically increasing)\r\n          conn.opt_cache = (conn.opt_cache ?? 0) + g * g;\r\n          const adj = g / (Math.sqrt(conn.opt_cache) + eps);\r\n          this._safeUpdateWeight(conn, adj * lrScale);\r\n          break;\r\n        }\r\n        case 'adam':\r\n        case 'adamw':\r\n        case 'amsgrad': {\r\n          // m = beta1*m + (1-beta1)g ; v = beta2*v + (1-beta2)g^2 ; bias-correct then step\r\n          conn.opt_m = (conn.opt_m ?? 0) * beta1 + (1 - beta1) * g;\r\n          conn.opt_v = (conn.opt_v ?? 0) * beta2 + (1 - beta2) * (g * g);\r\n          if (effectiveType === 'amsgrad') {\r\n            conn.opt_vhat = Math.max(conn.opt_vhat ?? 0, conn.opt_v ?? 0);\r\n          }\r\n          const vEff = effectiveType === 'amsgrad' ? conn.opt_vhat : conn.opt_v;\r\n          const mHat = conn.opt_m! / (1 - Math.pow(beta1, t));\r\n          const vHat = vEff! / (1 - Math.pow(beta2, t));\r\n          let step = (mHat / (Math.sqrt(vHat) + eps)) * lrScale;\r\n          if (effectiveType === 'adamw' && wd !== 0)\r\n            step -= wd * (conn.weight || 0);\r\n          this._safeUpdateWeight(conn, step);\r\n          break;\r\n        }\r\n        case 'adamax': {\r\n          // u = max(beta2*u, |g|) ; step uses infinity norm\r\n          conn.opt_m = (conn.opt_m ?? 0) * beta1 + (1 - beta1) * g;\r\n          conn.opt_u = Math.max((conn.opt_u ?? 0) * beta2, Math.abs(g));\r\n          const mHat = conn.opt_m! / (1 - Math.pow(beta1, t));\r\n          const stepVal = (mHat / (conn.opt_u || 1e-12)) * lrScale;\r\n          this._safeUpdateWeight(conn, stepVal);\r\n          break;\r\n        }\r\n        case 'nadam': {\r\n          // NAdam uses Nesterov lookahead on m\r\n          conn.opt_m = (conn.opt_m ?? 0) * beta1 + (1 - beta1) * g;\r\n          conn.opt_v = (conn.opt_v ?? 0) * beta2 + (1 - beta2) * (g * g);\r\n          const mHat = conn.opt_m! / (1 - Math.pow(beta1, t));\r\n          const vHat = conn.opt_v! / (1 - Math.pow(beta2, t));\r\n          const mNesterov =\r\n            mHat * beta1 + ((1 - beta1) * g) / (1 - Math.pow(beta1, t));\r\n          this._safeUpdateWeight(\r\n            conn,\r\n            (mNesterov / (Math.sqrt(vHat) + eps)) * lrScale\r\n          );\r\n          break;\r\n        }\r\n        case 'radam': {\r\n          // RAdam rectifies variance when few steps (rho_t small)\r\n          conn.opt_m = (conn.opt_m ?? 0) * beta1 + (1 - beta1) * g;\r\n          conn.opt_v = (conn.opt_v ?? 0) * beta2 + (1 - beta2) * (g * g);\r\n          const mHat = conn.opt_m! / (1 - Math.pow(beta1, t));\r\n          const vHat = conn.opt_v! / (1 - Math.pow(beta2, t));\r\n          const rhoInf = 2 / (1 - beta2) - 1;\r\n          const rhoT =\r\n            rhoInf - (2 * t * Math.pow(beta2, t)) / (1 - Math.pow(beta2, t));\r\n          if (rhoT > 4) {\r\n            const rt = Math.sqrt(\r\n              ((rhoT - 4) * (rhoT - 2) * rhoInf) /\r\n                ((rhoInf - 4) * (rhoInf - 2) * rhoT)\r\n            );\r\n            this._safeUpdateWeight(\r\n              conn,\r\n              ((rt * mHat) / (Math.sqrt(vHat) + eps)) * lrScale\r\n            );\r\n          } else {\r\n            this._safeUpdateWeight(conn, mHat * lrScale);\r\n          }\r\n          break;\r\n        }\r\n        case 'lion': {\r\n          // Lion: update direction = sign(beta1*m_t + beta2*m2_t) (two EMA buffers of gradients)\r\n          conn.opt_m = (conn.opt_m ?? 0) * beta1 + (1 - beta1) * g;\r\n          conn.opt_m2 = (conn.opt_m2 ?? 0) * beta2 + (1 - beta2) * g;\r\n          const update = Math.sign((conn.opt_m || 0) + (conn.opt_m2 || 0));\r\n          this._safeUpdateWeight(conn, -update * lrScale);\r\n          break;\r\n        }\r\n        case 'adabelief': {\r\n          // AdaBelief: second moment on surprise (g - m)\r\n          conn.opt_m = (conn.opt_m ?? 0) * beta1 + (1 - beta1) * g;\r\n          const g_m = g - conn.opt_m!;\r\n          conn.opt_v = (conn.opt_v ?? 0) * beta2 + (1 - beta2) * (g_m * g_m);\r\n          const mHat = conn.opt_m! / (1 - Math.pow(beta1, t));\r\n          const vHat = conn.opt_v! / (1 - Math.pow(beta2, t));\r\n          this._safeUpdateWeight(\r\n            conn,\r\n            (mHat / (Math.sqrt(vHat) + eps + 1e-12)) * lrScale\r\n          );\r\n          break;\r\n        }\r\n        default: {\r\n          // SGD: clip extreme deltas and apply momentum separately (momentum value passed here to reuse path)\r\n          let currentDeltaWeight =\r\n            g + momentum * (conn.previousDeltaWeight || 0);\r\n          if (!Number.isFinite(currentDeltaWeight)) currentDeltaWeight = 0;\r\n          if (Math.abs(currentDeltaWeight) > 1e3)\r\n            currentDeltaWeight = Math.sign(currentDeltaWeight) * 1e3;\r\n          this._safeUpdateWeight(conn, currentDeltaWeight * lrScale);\r\n          conn.previousDeltaWeight = currentDeltaWeight;\r\n        }\r\n      }\r\n      if (effectiveType === 'adamw' && wd !== 0) {\r\n        this._safeUpdateWeight(conn, -wd * (conn.weight || 0) * lrScale);\r\n      }\r\n      conn.totalDeltaWeight = 0;\r\n    };\r\n    for (const connection of this.connections.in) applyConn(connection);\r\n    for (const connection of this.connections.self) applyConn(connection);\r\n    if (this.type !== 'input' && this.type !== 'constant') {\r\n      let gB = this.totalDeltaBias || 0;\r\n      if (!Number.isFinite(gB)) gB = 0;\r\n      if (\r\n        [\r\n          'adam',\r\n          'adamw',\r\n          'amsgrad',\r\n          'adamax',\r\n          'nadam',\r\n          'radam',\r\n          'lion',\r\n          'adabelief',\r\n        ].includes(effectiveType)\r\n      ) {\r\n        (this as any).opt_mB =\r\n          ((this as any).opt_mB ?? 0) * beta1 + (1 - beta1) * gB;\r\n        if (effectiveType === 'lion') {\r\n          (this as any).opt_mB2 =\r\n            ((this as any).opt_mB2 ?? 0) * beta2 + (1 - beta2) * gB;\r\n        }\r\n        (this as any).opt_vB =\r\n          ((this as any).opt_vB ?? 0) * beta2 +\r\n          (1 - beta2) *\r\n            (effectiveType === 'adabelief'\r\n              ? Math.pow(gB - (this as any).opt_mB, 2)\r\n              : gB * gB);\r\n        if (effectiveType === 'amsgrad') {\r\n          (this as any).opt_vhatB = Math.max(\r\n            (this as any).opt_vhatB ?? 0,\r\n            (this as any).opt_vB ?? 0\r\n          );\r\n        }\r\n        const vEffB =\r\n          effectiveType === 'amsgrad'\r\n            ? (this as any).opt_vhatB\r\n            : (this as any).opt_vB;\r\n        const mHatB = (this as any).opt_mB / (1 - Math.pow(beta1, t));\r\n        const vHatB = vEffB / (1 - Math.pow(beta2, t));\r\n        let stepB: number;\r\n        if (effectiveType === 'adamax') {\r\n          (this as any).opt_uB = Math.max(\r\n            ((this as any).opt_uB ?? 0) * beta2,\r\n            Math.abs(gB)\r\n          );\r\n          stepB = (mHatB / ((this as any).opt_uB || 1e-12)) * lrScale;\r\n        } else if (effectiveType === 'nadam') {\r\n          const mNesterovB =\r\n            mHatB * beta1 + ((1 - beta1) * gB) / (1 - Math.pow(beta1, t));\r\n          stepB = (mNesterovB / (Math.sqrt(vHatB) + eps)) * lrScale;\r\n        } else if (effectiveType === 'radam') {\r\n          const rhoInf = 2 / (1 - beta2) - 1;\r\n          const rhoT =\r\n            rhoInf - (2 * t * Math.pow(beta2, t)) / (1 - Math.pow(beta2, t));\r\n          if (rhoT > 4) {\r\n            const rt = Math.sqrt(\r\n              ((rhoT - 4) * (rhoT - 2) * rhoInf) /\r\n                ((rhoInf - 4) * (rhoInf - 2) * rhoT)\r\n            );\r\n            stepB = ((rt * mHatB) / (Math.sqrt(vHatB) + eps)) * lrScale;\r\n          } else {\r\n            stepB = mHatB * lrScale;\r\n          }\r\n        } else if (effectiveType === 'lion') {\r\n          const updateB = Math.sign(\r\n            (this as any).opt_mB + (this as any).opt_mB2\r\n          );\r\n          stepB = -updateB * lrScale;\r\n        } else if (effectiveType === 'adabelief') {\r\n          stepB = (mHatB / (Math.sqrt(vHatB) + eps + 1e-12)) * lrScale;\r\n        } else {\r\n          stepB = (mHatB / (Math.sqrt(vHatB) + eps)) * lrScale;\r\n        }\r\n        if (effectiveType === 'adamw' && wd !== 0)\r\n          stepB -= wd * (this.bias || 0) * lrScale;\r\n        let nextBias = this.bias + stepB;\r\n        if (!Number.isFinite(nextBias)) nextBias = 0;\r\n        if (Math.abs(nextBias) > 1e6) nextBias = Math.sign(nextBias) * 1e6;\r\n        this.bias = nextBias;\r\n      } else {\r\n        let currentDeltaBias = gB + momentum * (this.previousDeltaBias || 0);\r\n        if (!Number.isFinite(currentDeltaBias)) currentDeltaBias = 0;\r\n        if (Math.abs(currentDeltaBias) > 1e3)\r\n          currentDeltaBias = Math.sign(currentDeltaBias) * 1e3;\r\n        let nextBias = this.bias + currentDeltaBias * lrScale;\r\n        if (!Number.isFinite(nextBias)) nextBias = 0;\r\n        if (Math.abs(nextBias) > 1e6) nextBias = Math.sign(nextBias) * 1e6;\r\n        this.bias = nextBias;\r\n        this.previousDeltaBias = currentDeltaBias;\r\n      }\r\n      this.totalDeltaBias = 0;\r\n    } else {\r\n      this.previousDeltaBias = 0;\r\n      this.totalDeltaBias = 0;\r\n    }\r\n    if (type === 'lookahead') {\r\n      const k = (this as any)._la_k || 5;\r\n      const alpha = (this as any)._la_alpha || 0.5;\r\n      if ((this as any)._la_step % k === 0) {\r\n        // Blend towards slow weights every k steps: shadow = (1-alpha)*shadow + alpha*fast ; fast = shadow\r\n        (this as any)._la_shadowBias =\r\n          (1 - alpha) * (this as any)._la_shadowBias + alpha * this.bias;\r\n        this.bias = (this as any)._la_shadowBias;\r\n        const blendConn = (conn: Connection) => {\r\n          if (!(conn as any)._la_shadowWeight)\r\n            (conn as any)._la_shadowWeight = conn.weight;\r\n          (conn as any)._la_shadowWeight =\r\n            (1 - alpha) * (conn as any)._la_shadowWeight + alpha * conn.weight;\r\n          conn.weight = (conn as any)._la_shadowWeight;\r\n        };\r\n        for (const c of this.connections.in) blendConn(c);\r\n        for (const c of this.connections.self) blendConn(c);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal helper to safely update a connection weight with clipping and NaN checks.\r\n   */\r\n  private _safeUpdateWeight(connection: Connection, delta: number) {\r\n    let next = connection.weight + delta;\r\n    if (!Number.isFinite(next)) next = 0;\r\n    if (Math.abs(next) > 1e6) next = Math.sign(next) * 1e6;\r\n    connection.weight = next;\r\n  }\r\n}\r\n", "/**\r\n * Activation array pooling utilities.\r\n *\r\n * Size-bucketed pool for reusable activation arrays to reduce allocations in\r\n * hot forward paths. Reused arrays are zero-filled to prevent stale data.\r\n * Array type honors global precision via `config.float32Mode`.\r\n */\r\n\r\nimport { config } from '../config';\r\n\r\n/**\r\n * Allowed activation array shapes for pooling.\r\n * - number[]: default JS array\r\n * - Float32Array: compact typed array when float32 mode is enabled\r\n * - Float64Array: supported for compatibility with typed math paths\r\n */\r\nexport type ActivationArray = number[] | Float32Array | Float64Array;\r\n\r\n/**\r\n * A size-bucketed pool of activation arrays.\r\n *\r\n * Buckets map array length -> stack of arrays. Acquire pops and zero-fills, or\r\n * allocates a new array when empty. Release pushes back up to a configurable\r\n * per-bucket cap to avoid unbounded growth.\r\n *\r\n * Note: not thread-safe; intended for typical single-threaded JS execution.\r\n */\r\nclass ActivationArrayPool {\r\n  /** Buckets keyed by length, storing reusable arrays. */\r\n  private buckets: Map<number, ActivationArray[]> = new Map();\r\n  /** Count of arrays created since last clear(), for diagnostics. */\r\n  private created = 0;\r\n  /** Count of successful reuses since last clear(), for diagnostics. */\r\n  private reused = 0;\r\n  /** Max arrays retained per size bucket; Infinity by default. */\r\n  private maxPerBucket = Number.POSITIVE_INFINITY;\r\n\r\n  /**\r\n   * Acquire an activation array of fixed length.\r\n   * Zero-fills reused arrays to guarantee clean state.\r\n   *\r\n   * @param size Required array length.\r\n   * @returns Zeroed activation array of the requested size.\r\n   */\r\n  acquire(size: number): ActivationArray {\r\n    const bucket = this.buckets.get(size);\r\n    if (bucket && bucket.length > 0) {\r\n      this.reused++;\r\n      const arr = bucket.pop()!;\r\n      // zero on reuse to avoid stale values\r\n      (arr as any).fill(0);\r\n      return arr;\r\n    }\r\n    this.created++;\r\n    return config.float32Mode\r\n      ? new Float32Array(size)\r\n      : new Array<number>(size).fill(0);\r\n  }\r\n\r\n  /**\r\n   * Return an activation array to the pool. If the bucket is full per\r\n   * `maxPerBucket`, the array is dropped and left to GC.\r\n   *\r\n   * @param array Array to release back to the pool.\r\n   */\r\n  release(array: ActivationArray) {\r\n    const size = array.length >>> 0;\r\n    if (!this.buckets.has(size)) this.buckets.set(size, []);\r\n    const bucket = this.buckets.get(size)!;\r\n    if (bucket.length < this.maxPerBucket) bucket.push(array);\r\n  }\r\n\r\n  /**\r\n   * Clear all buckets and reset counters. Frees references to pooled arrays.\r\n   */\r\n  clear() {\r\n    this.buckets.clear();\r\n    this.created = 0;\r\n    this.reused = 0;\r\n  }\r\n\r\n  /**\r\n   * Snapshot of diagnostics: creations, reuses, and number of active buckets.\r\n   */\r\n  stats() {\r\n    return {\r\n      created: this.created,\r\n      reused: this.reused,\r\n      bucketCount: this.buckets.size,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Configure a capacity cap per size bucket to avoid unbounded memory growth.\r\n   *\r\n   * @param cap Non-negative capacity per bucket (Infinity allowed).\r\n   */\r\n  setMaxPerBucket(cap: number) {\r\n    if (typeof cap === 'number' && cap >= 0) this.maxPerBucket = cap;\r\n  }\r\n\r\n  /**\r\n   * Pre-allocate and retain arrays for a given size bucket up to `count` items.\r\n   *\r\n   * @param size Array length (bucket key).\r\n   * @param count Number of arrays to prepare (rounded down, min 0).\r\n   */\r\n  prewarm(size: number, count: number) {\r\n    const n = Math.max(0, Math.floor(count));\r\n    if (!this.buckets.has(size)) this.buckets.set(size, []);\r\n    const bucket = this.buckets.get(size)!;\r\n    for (let i = 0; i < n && bucket.length < this.maxPerBucket; i++) {\r\n      const arr = config.float32Mode\r\n        ? new Float32Array(size)\r\n        : new Array<number>(size).fill(0);\r\n      bucket.push(arr);\r\n      this.created++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Current retained count for a size bucket.\r\n   *\r\n   * @param size Array length (bucket key).\r\n   * @returns Number of arrays available to reuse for that length.\r\n   */\r\n  bucketSize(size: number): number {\r\n    return this.buckets.get(size)?.length ?? 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Shared singleton instance used across the library for maximal reuse.\r\n */\r\nexport const activationArrayPool = new ActivationArrayPool();\r\n", "/**\r\n * ONNX export/import utilities for a constrained subset of networks (minimal MLPs).\r\n *\r\n * Scope & Assumptions:\r\n *  - Supports strictly layered, fully-connected feed\u2011forward topologies only.\r\n *  - Each non-input layer must have a homogeneous activation function (single activation per layer).\r\n *  - No recurrence, self/backward connections, gating, or heterogeneous per-node activations.\r\n *  - Unsupported activation functions degrade to Identity with a console warning.\r\n *\r\n * Design Goals:\r\n *  - Keep zero external ONNX dependencies (simple JSON shape) to avoid heavy protobuf runtime.\r\n *  - Perform structural validation early to produce informative errors.\r\n *  - Provide clearly documented stepwise transformation for auditability & reproducibility.\r\n *\r\n * Future Extension Ideas (not implemented):\r\n *  - BatchNorm / Dropout folding recognition.\r\n *  - Recurrent unrolling (time-limited) to pseudo-feedforward graph.\r\n *  - Operator fusion (Gemm + Activation ordering refinement).\r\n *  - Custom activation registration to ONNX via function proto definitions.\r\n *\r\n * NOTE: Import is only guaranteed to work for models produced by {@link exportToONNX};\r\n * arbitrary ONNX graphs are NOT universally supported.\r\n */\r\n\r\nimport * as methods from '../../methods/methods';\r\nimport type Network from '../network';\r\n\r\n// --- Lightweight ONNX type aliases (minimal subset used for export/import) ---\r\nexport type OnnxModel = { graph: OnnxGraph };\r\ntype OnnxGraph = {\r\n  inputs: any[];\r\n  outputs: any[];\r\n  initializer: OnnxTensor[];\r\n  node: OnnxNode[];\r\n};\r\ntype OnnxTensor = {\r\n  name: string;\r\n  data_type: number;\r\n  dims: number[];\r\n  float_data: number[];\r\n};\r\ntype OnnxNode = {\r\n  op_type: string;\r\n  input: string[];\r\n  output: string[];\r\n  name: string;\r\n  attributes?: any[];\r\n};\r\n\r\n// ---------------------------------------------------------------------------\r\n// Internal helpers (not exported)\r\n// ---------------------------------------------------------------------------\r\n\r\n/** Rebuild the network's flat connections array from each node's outgoing list (avoids circular import). */\r\nfunction rebuildConnectionsLocal(networkLike: any): void {\r\n  /** Set used to deduplicate connection objects. */\r\n  const uniqueConnections = new Set<any>();\r\n  networkLike.nodes.forEach((node: any) =>\r\n    node.connections?.out.forEach((conn: any) => uniqueConnections.add(conn))\r\n  );\r\n  networkLike.connections = Array.from(uniqueConnections);\r\n}\r\n\r\n/** Map an internal activation function (squash) to an ONNX op_type, defaulting to Identity. */\r\nfunction mapActivationToOnnx(squash: any): string {\r\n  const upperName = (squash?.name || '').toUpperCase();\r\n  if (upperName.includes('TANH')) return 'Tanh';\r\n  if (upperName.includes('LOGISTIC') || upperName.includes('SIGMOID'))\r\n    return 'Sigmoid';\r\n  if (upperName.includes('RELU')) return 'Relu';\r\n  if (squash)\r\n    console.warn(\r\n      `Unsupported activation function ${squash.name} for ONNX export, defaulting to Identity.`\r\n    );\r\n  return 'Identity';\r\n}\r\n\r\n/** Infer strictly layered ordering from a network, ensuring feed-forward fully-connected structure. */\r\nfunction inferLayerOrdering(network: Network): any[][] {\r\n  /** All input nodes (first layer). */\r\n  const inputNodes = network.nodes.filter((n: any) => n.type === 'input');\r\n  /** All output nodes (final layer). */\r\n  const outputNodes = network.nodes.filter((n: any) => n.type === 'output');\r\n  /** All hidden nodes requiring layer inference. */\r\n  const hiddenNodes = network.nodes.filter((n: any) => n.type === 'hidden');\r\n  if (hiddenNodes.length === 0) return [inputNodes, outputNodes];\r\n  /** Remaining hidden nodes to allocate. */\r\n  let remainingHidden = [...hiddenNodes];\r\n  /** Previously accepted layer (starts at inputs). */\r\n  let previousLayer = inputNodes;\r\n  /** Accumulated layers (excluding final output which is appended later). */\r\n  const layerAccumulator: any[][] = [];\r\n  while (remainingHidden.length) {\r\n    /** Hidden nodes whose inbound connections originate only from previousLayer. */\r\n    const currentLayer = remainingHidden.filter((hidden) =>\r\n      hidden.connections.in.every((conn: any) =>\r\n        previousLayer.includes(conn.from)\r\n      )\r\n    );\r\n    if (!currentLayer.length)\r\n      throw new Error(\r\n        'Invalid network structure for ONNX export: cannot resolve layered ordering.'\r\n      );\r\n    layerAccumulator.push(previousLayer);\r\n    previousLayer = currentLayer;\r\n    remainingHidden = remainingHidden.filter((h) => !currentLayer.includes(h));\r\n  }\r\n  // Append the last hidden layer and output layer.\r\n  layerAccumulator.push(previousLayer);\r\n  layerAccumulator.push(outputNodes);\r\n  return layerAccumulator;\r\n}\r\n\r\n/** Validate that each non-input layer has homogeneous activation and is fully connected from previous layer. */\r\nfunction validateLayerHomogeneityAndConnectivity(\r\n  layers: any[][],\r\n  network: Network\r\n): void {\r\n  for (let layerIndex = 1; layerIndex < layers.length; layerIndex++) {\r\n    /** Nodes in the source (previous) layer feeding current layer. */\r\n    const previousLayerNodes = layers[layerIndex - 1];\r\n    /** Nodes in the current destination layer being validated. */\r\n    const currentLayerNodes = layers[layerIndex];\r\n    /** Set of activation names encountered. */\r\n    const activationNameSet = new Set(\r\n      currentLayerNodes.map((n: any) => n.squash && n.squash.name)\r\n    );\r\n    if (activationNameSet.size > 1)\r\n      throw new Error(\r\n        `ONNX export error: Mixed activation functions detected in layer ${layerIndex}.`\r\n      );\r\n    for (const targetNode of currentLayerNodes) {\r\n      for (const sourceNode of previousLayerNodes) {\r\n        const isConnected = targetNode.connections.in.some(\r\n          (conn: any) => conn.from === sourceNode\r\n        );\r\n        if (!isConnected) {\r\n          throw new Error(\r\n            `ONNX export error: Missing connection from node ${sourceNode.index} to node ${targetNode.index} in layer ${layerIndex}.`\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/** Construct the ONNX model graph (initializers + nodes) given validated layers. */\r\nfunction buildOnnxModel(network: Network, layers: any[][]): OnnxModel {\r\n  /** Input layer nodes (used for input tensor dimension). */\r\n  const inputLayerNodes = layers[0];\r\n  /** Output layer nodes (used for output tensor dimension). */\r\n  const outputLayerNodes = layers[layers.length - 1];\r\n  /** Mutable ONNX model under construction. */\r\n  const model: OnnxModel = {\r\n    graph: {\r\n      inputs: [\r\n        {\r\n          name: 'input',\r\n          type: {\r\n            tensor_type: {\r\n              elem_type: 1,\r\n              shape: { dim: [{ dim_value: inputLayerNodes.length }] },\r\n            },\r\n          },\r\n        },\r\n      ],\r\n      outputs: [\r\n        {\r\n          name: 'output',\r\n          type: {\r\n            tensor_type: {\r\n              elem_type: 1,\r\n              shape: { dim: [{ dim_value: outputLayerNodes.length }] },\r\n            },\r\n          },\r\n        },\r\n      ],\r\n      initializer: [],\r\n      node: [],\r\n    },\r\n  };\r\n  /** Name of the tensor that feeds into the current Gemm. */\r\n  let previousOutputName = 'input';\r\n  for (let layerIndex = 1; layerIndex < layers.length; layerIndex++) {\r\n    const previousLayerNodes = layers[layerIndex - 1];\r\n    const currentLayerNodes = layers[layerIndex];\r\n    /** Flattened row-major weight matrix (rows = current layer neurons, cols = previous layer neurons). */\r\n    const weightMatrixValues: number[] = [];\r\n    /** Bias vector for current layer. */\r\n    const biasVector: number[] = new Array(currentLayerNodes.length).fill(0);\r\n    for (let neuronRow = 0; neuronRow < currentLayerNodes.length; neuronRow++) {\r\n      const targetNode: any = currentLayerNodes[neuronRow];\r\n      biasVector[neuronRow] = targetNode.bias;\r\n      for (\r\n        let neuronCol = 0;\r\n        neuronCol < previousLayerNodes.length;\r\n        neuronCol++\r\n      ) {\r\n        const sourceNode = previousLayerNodes[neuronCol];\r\n        const inboundConn = targetNode.connections.in.find(\r\n          (c: any) => c.from === sourceNode\r\n        );\r\n        weightMatrixValues.push(inboundConn ? inboundConn.weight : 0);\r\n      }\r\n    }\r\n    /** Symbolic weight tensor name. */\r\n    const weightTensorName = `W${layerIndex - 1}`;\r\n    /** Symbolic bias tensor name. */\r\n    const biasTensorName = `B${layerIndex - 1}`;\r\n    /** Intermediate Gemm output name. */\r\n    const gemmOutputName = `Gemm_${layerIndex}`;\r\n    /** Post-activation output name (feeds next layer). */\r\n    const activationOutputName = `Layer_${layerIndex}`;\r\n    model.graph.initializer.push({\r\n      name: weightTensorName,\r\n      data_type: 1,\r\n      dims: [currentLayerNodes.length, previousLayerNodes.length],\r\n      float_data: weightMatrixValues,\r\n    });\r\n    model.graph.initializer.push({\r\n      name: biasTensorName,\r\n      data_type: 1,\r\n      dims: [currentLayerNodes.length],\r\n      float_data: biasVector,\r\n    });\r\n    // Activation node first (to preserve original order used historically in this project)\r\n    model.graph.node.push({\r\n      op_type: mapActivationToOnnx(currentLayerNodes[0].squash),\r\n      input: [gemmOutputName],\r\n      output: [activationOutputName],\r\n      name: `act_l${layerIndex}`,\r\n    });\r\n    (model.graph.node as any).push({\r\n      op_type: 'Gemm',\r\n      input: [previousOutputName, weightTensorName, biasTensorName],\r\n      output: [gemmOutputName],\r\n      name: `gemm_l${layerIndex}`,\r\n      attributes: [\r\n        { name: 'alpha', type: 'FLOAT', f: 1 },\r\n        { name: 'beta', type: 'FLOAT', f: 1 },\r\n        { name: 'transB', type: 'INT', i: 1 },\r\n      ],\r\n    });\r\n    previousOutputName = activationOutputName;\r\n  }\r\n  return model;\r\n}\r\n\r\n/** Extract hidden layer sizes from ONNX initializers (weight tensors). */\r\nfunction deriveHiddenLayerSizes(initializers: OnnxTensor[]): number[] {\r\n  /** All 2D weight tensors (W*) representing layer transitions. */\r\n  const weightTensors = initializers.filter(\r\n    (t) => t.name.startsWith('W') && t.dims.length === 2\r\n  );\r\n  // All except the last weight tensor correspond to hidden layers (last maps into output layer)\r\n  return weightTensors.slice(0, -1).map((t) => t.dims[0]);\r\n}\r\n\r\n/** Apply weights & biases from ONNX initializers onto the newly created network. */\r\nfunction assignWeightsAndBiases(\r\n  network: Network,\r\n  onnx: OnnxModel,\r\n  hiddenLayerSizes: number[]\r\n): void {\r\n  /** Index of current layer transition (0..hiddenCount then output). */\r\n  let layerOffset = 0; // which layer (0..hiddenCount then output)\r\n  for (\r\n    let initializerIndex = 0;\r\n    initializerIndex < onnx.graph.initializer.length;\r\n    initializerIndex += 2\r\n  ) {\r\n    /** Weight tensor for this layer transition. */\r\n    const weightTensor = onnx.graph.initializer[initializerIndex];\r\n    /** Bias tensor for this layer transition. */\r\n    const biasTensor = onnx.graph.initializer[initializerIndex + 1];\r\n    /** True if assigning into a hidden layer; false for final output layer. */\r\n    const isHiddenLayer = layerOffset < hiddenLayerSizes.length;\r\n    /** Destination layer nodes whose parameters are being assigned. */\r\n    const currentLayerNodes = isHiddenLayer\r\n      ? network.nodes\r\n          .filter((n: any) => n.type === 'hidden')\r\n          .slice(\r\n            hiddenLayerSizes.slice(0, layerOffset).reduce((a, b) => a + b, 0),\r\n            hiddenLayerSizes\r\n              .slice(0, layerOffset + 1)\r\n              .reduce((a, b) => a + b, 0)\r\n          )\r\n      : network.nodes.filter((n: any) => n.type === 'output');\r\n    /** Source layer nodes providing incoming weights. */\r\n    const previousLayerNodes =\r\n      layerOffset === 0\r\n        ? network.nodes.filter((n: any) => n.type === 'input')\r\n        : network.nodes\r\n            .filter((n: any) => n.type === 'hidden')\r\n            .slice(\r\n              hiddenLayerSizes\r\n                .slice(0, layerOffset - 1)\r\n                .reduce((a, b) => a + b, 0),\r\n              hiddenLayerSizes.slice(0, layerOffset).reduce((a, b) => a + b, 0)\r\n            );\r\n    for (let row = 0; row < currentLayerNodes.length; row++) {\r\n      for (let col = 0; col < previousLayerNodes.length; col++) {\r\n        /** Existing forward connection (if present) from source to target. */\r\n        const existingConn = previousLayerNodes[col].connections.out.find(\r\n          (c: any) => c.to === currentLayerNodes[row]\r\n        );\r\n        if (existingConn)\r\n          existingConn.weight =\r\n            weightTensor.float_data[row * previousLayerNodes.length + col];\r\n      }\r\n      currentLayerNodes[row].bias = biasTensor.float_data[row];\r\n    }\r\n    layerOffset++;\r\n  }\r\n}\r\n\r\n/** Map activation op_types from ONNX nodes back to internal activation functions. */\r\nfunction assignActivationFunctions(\r\n  network: Network,\r\n  onnx: OnnxModel,\r\n  hiddenLayerSizes: number[]\r\n): void {\r\n  /** All ONNX activation nodes in traversal order. */\r\n  const activationNodes = onnx.graph.node.filter((n) =>\r\n    ['Tanh', 'Sigmoid', 'Logistic', 'Relu', 'Identity'].includes(n.op_type)\r\n  );\r\n  /** Index into activationNodes corresponding to current hidden layer. */\r\n  let activationNodeIndex = 0;\r\n  /** Flat list of hidden nodes (original network order). */\r\n  const hiddenLayerNodes = network.nodes.filter(\r\n    (n: any) => n.type === 'hidden'\r\n  );\r\n  /** Offset into hiddenLayerNodes tracking start of current layer segment. */\r\n  let hiddenLayerOffset = 0;\r\n  for (let layerIndex = 0; layerIndex < hiddenLayerSizes.length; layerIndex++) {\r\n    /** Number of neurons in this hidden layer. */\r\n    const size = hiddenLayerSizes[layerIndex];\r\n    if (!size) continue;\r\n    /** ONNX op_type representing this layer's activation. */\r\n    const opType = activationNodes[activationNodeIndex]?.op_type;\r\n    /** Resolved internal squash function for this layer. */\r\n    let squashFn;\r\n    switch (opType) {\r\n      case 'Tanh':\r\n        squashFn = methods.Activation.tanh;\r\n        break;\r\n      case 'Sigmoid':\r\n      case 'Logistic':\r\n        squashFn = methods.Activation.sigmoid;\r\n        break;\r\n      case 'Relu':\r\n        squashFn = methods.Activation.relu;\r\n        break;\r\n      default:\r\n        squashFn = methods.Activation.identity;\r\n        break;\r\n    }\r\n    for (let i = 0; i < size; i++) {\r\n      if (hiddenLayerNodes[hiddenLayerOffset + i])\r\n        hiddenLayerNodes[hiddenLayerOffset + i].squash = squashFn;\r\n    }\r\n    hiddenLayerOffset += size;\r\n    activationNodeIndex++;\r\n  }\r\n  /** Output nodes requiring activation assignment. */\r\n  const outputLayerNodes = network.nodes.filter(\r\n    (n: any) => n.type === 'output'\r\n  );\r\n  if (outputLayerNodes.length) {\r\n    /** ONNX op_type of last activation node (assumed output layer). */\r\n    const opType = activationNodes[activationNodes.length - 1]?.op_type;\r\n    /** Resolved internal squash function for output layer. */\r\n    let outputSquash;\r\n    switch (opType) {\r\n      case 'Tanh':\r\n        outputSquash = methods.Activation.tanh;\r\n        break;\r\n      case 'Sigmoid':\r\n      case 'Logistic':\r\n        outputSquash = methods.Activation.sigmoid;\r\n        break;\r\n      case 'Relu':\r\n        outputSquash = methods.Activation.relu;\r\n        break;\r\n      default:\r\n        outputSquash = methods.Activation.identity;\r\n        break;\r\n    }\r\n    outputLayerNodes.forEach((n: any) => (n.squash = outputSquash));\r\n  }\r\n}\r\n\r\n// ---------------------------------------------------------------------------\r\n// Public API\r\n// ---------------------------------------------------------------------------\r\n\r\n/**\r\n * Export a minimal multilayer perceptron Network to a lightweight ONNX JSON object.\r\n *\r\n * Steps:\r\n *  1. Rebuild connection cache ensuring up-to-date adjacency.\r\n *  2. Index nodes for error messaging.\r\n *  3. Infer strict layer ordering (throws if structure unsupported).\r\n *  4. Validate homogeneity & full connectivity layer-to-layer.\r\n *  5. Build initializer tensors (weights + biases) and node list (Gemm + activation pairs).\r\n *\r\n * Constraints: See module doc. Throws descriptive errors when assumptions violated.\r\n */\r\nexport function exportToONNX(network: Network): OnnxModel {\r\n  rebuildConnectionsLocal(network as any);\r\n  network.nodes.forEach((node: any, idx: number) => (node.index = idx));\r\n  if (!network.connections || network.connections.length === 0)\r\n    throw new Error('ONNX export currently only supports simple MLPs');\r\n  /** Layered node arrays (input, hidden..., output) inferred for export. */\r\n  const layers = inferLayerOrdering(network);\r\n  validateLayerHomogeneityAndConnectivity(layers, network);\r\n  return buildOnnxModel(network, layers);\r\n}\r\n\r\n/**\r\n * Import a model previously produced by {@link exportToONNX} into a fresh Network instance.\r\n *\r\n * Steps:\r\n *  1. Read input/output dimensions.\r\n *  2. Derive hidden layer sizes from weight tensor shapes.\r\n *  3. Create corresponding MLP with identical layer counts.\r\n *  4. Assign weights & biases.\r\n *  5. Map activation op_types back to internal activation functions.\r\n *  6. Rebuild flat connection list.\r\n *\r\n * Limitations: Only guaranteed for self-produced ONNX; inconsistent naming or ordering will break.\r\n */\r\nexport function importFromONNX(onnx: OnnxModel): Network {\r\n  const { default: NetworkVal } = require('../network'); // dynamic import to avoid circular reference at module load\r\n  /** Number of input features (dimension of input tensor). */\r\n  const inputCount =\r\n    onnx.graph.inputs[0].type.tensor_type.shape.dim[0].dim_value;\r\n  /** Number of output neurons (dimension of output tensor). */\r\n  const outputCount =\r\n    onnx.graph.outputs[0].type.tensor_type.shape.dim[0].dim_value;\r\n  /** Hidden layer sizes derived from weight tensor shapes. */\r\n  const hiddenLayerSizes = deriveHiddenLayerSizes(onnx.graph.initializer);\r\n  /** Newly constructed network mirroring the ONNX architecture. */\r\n  const network: Network = NetworkVal.createMLP(\r\n    inputCount,\r\n    hiddenLayerSizes,\r\n    outputCount\r\n  );\r\n  if (hiddenLayerSizes.length === 0) {\r\n    // Edge case: single-layer perceptron (inputs -> outputs); prune hidden placeholders if any.\r\n    network.nodes = [\r\n      ...network.nodes.filter((n: any) => n.type === 'input'),\r\n      ...network.nodes.filter((n: any) => n.type === 'output'),\r\n    ];\r\n    rebuildConnectionsLocal(network as any);\r\n  }\r\n  assignWeightsAndBiases(network, onnx, hiddenLayerSizes);\r\n  assignActivationFunctions(network, onnx, hiddenLayerSizes);\r\n  rebuildConnectionsLocal(network as any);\r\n  return network;\r\n}\r\n\r\nexport default { exportToONNX, importFromONNX };\r\n", "// Backward compatibility shim: logic moved to network/network.onnx.ts\r\nexport * from './network/network.onnx';\r\nexport { default } from './network/network.onnx';\r\n", "import type Network from '../network';\r\n\r\n/**\r\n * Standalone forward pass code generator.\r\n *\r\n * Purpose:\r\n *  Transforms a dynamic Network instance (object graph with Nodes / Connections / gating metadata)\r\n *  into a self-contained JavaScript function string that, when evaluated, returns an `activate(input)`\r\n *  function capable of performing forward propagation without the original library runtime.\r\n *\r\n * Why generate code?\r\n *  - Deployment: Embed a compact, dependency\u2011free inference function in environments where bundling\r\n *    the full evolutionary framework is unnecessary (e.g. model cards, edge scripts, CI sanity checks).\r\n *  - Performance: Remove dynamic indirection (property lookups, virtual dispatch) by specializing\r\n *    the computation graph into straight\u2011line code and simple loops; JS engines can optimize this.\r\n *  - Pedagogy: Emitted source is readable\u2014users can inspect how weighted sums + activations compose.\r\n *\r\n * Features Supported:\r\n *  - Standard feed\u2011forward connections with optional gating (multiplicative modulation).\r\n *  - Single self-connection per node (handled as recurrent term S[i] * weight before activation).\r\n *  - Arbitrary activation functions: built\u2011in ones are emitted via canonical snippets; custom user\r\n *    functions are stringified and sanitized via stripCoverage(). Arrow or anonymous functions are\r\n *    normalized into named `function <name>(...)` forms for clarity and stable ordering.\r\n *\r\n * Not Supported / Simplifications:\r\n *  - No dynamic dropout, noise injection, or stochastic depth\u2014those would require runtime randomness.\r\n *  - Assumes all node indices are stable and sequential (enforced prior to generation).\r\n *  - Gradient / backprop logic intentionally omitted (forward inference only).\r\n */\r\n\r\n/**\r\n * Remove instrumentation / coverage artifacts and trivial formatting detritus from function strings.\r\n * Keeps emitted activation functions as clean as possible for readability and engine optimization.\r\n */\r\nconst stripCoverage = (code: string): string => {\r\n  code = code.replace(/\\/\\*\\s*istanbul\\s+ignore\\s+[\\s\\S]*?\\*\\//g, ''); // /* istanbul ignore ... */ blocks\r\n  code = code.replace(/cov_[\\w$]+\\(\\)\\.(s|f|b)\\[\\d+\\](\\[\\d+\\])?\\+\\+/g, ''); // counters like cov_xyz().s[3]++\r\n  code = code.replace(/cov_[\\w$]+\\(\\)/g, ''); // bare cov_ calls\r\n  code = code.replace(/^\\s*\\/\\/ # sourceMappingURL=.*\\s*$/gm, ''); // source maps\r\n  code = code.replace(/\\(\\s*,\\s*/g, '( '); // normalize stray comma spacing\r\n  code = code.replace(/\\s*,\\s*\\)/g, ' )');\r\n  code = code.trim();\r\n  code = code.replace(/^\\s*;\\s*$/gm, ''); // solitary semicolons\r\n  code = code.replace(/;{2,}/g, ';'); // collapse repeated semicolons\r\n  code = code.replace(/^\\s*[,;]?\\s*$/gm, ''); // leftover empty tokens\r\n  return code;\r\n};\r\n\r\n/**\r\n * Generate a standalone JavaScript source string that returns an `activate(input:number[])` function.\r\n *\r\n * Implementation Steps:\r\n *  1. Validate presence of output nodes (must produce something observable).\r\n *  2. Assign stable sequential indices to nodes (used as array offsets in generated code).\r\n *  3. Collect initial activation/state values into typed array initializers for warm starting.\r\n *  4. For each non-input node, build a line computing S[i] (pre-activation sum with bias) and A[i]\r\n *     (post-activation output). Gating multiplies activation by gate activations; self-connection adds\r\n *     recurrent term S[i] * weight before activation.\r\n *  5. De-duplicate activation functions: each unique squash name is emitted once; references become\r\n *     indices into array F of function references for compactness.\r\n *  6. Emit an IIFE producing the activate function with internal arrays A (activations) and S (states).\r\n *\r\n * @param net Network instance to snapshot.\r\n * @returns Source string (ES5-compatible) \u2013 safe to eval in sandbox to obtain activate function.\r\n * @throws If network lacks output nodes.\r\n */\r\nexport function generateStandalone(net: Network): string {\r\n  // 1. Structural validation: ensure at least one output node exists.\r\n  if (!(net as any).nodes.some((nodeRef: any) => nodeRef.type === 'output')) {\r\n    throw new Error(\r\n      'Cannot create standalone function: network has no output nodes.'\r\n    );\r\n  }\r\n  /** Map of activation function name -> emitted source string (deduplication). */\r\n  const emittedActivationSource: Record<string, string> = {};\r\n  /** Ordered list of activation function source strings (in emission order). */\r\n  const activationFunctionSources: string[] = [];\r\n  /** Activation function name -> index in F array (for compact referencing). */\r\n  const activationFunctionIndexMap: Record<string, number> = {};\r\n  /** Counter allocating the next function index. */\r\n  let nextActivationFunctionIndex = 0;\r\n  /** Initial activation values (A array seed). */\r\n  const initialActivations: number[] = [];\r\n  /** Initial state (pre-activation sums) values (S array seed). */\r\n  const initialStates: number[] = [];\r\n  /** Body lines comprising the activate(input) function. */\r\n  const bodyLines: string[] = [];\r\n  /** Built-in activation implementations (canonical, readable forms). */\r\n  const builtinActivationSnippets: Record<string, string> = {\r\n    logistic: 'function logistic(x){ return 1 / (1 + Math.exp(-x)); }',\r\n    tanh: 'function tanh(x){ return Math.tanh(x); }',\r\n    relu: 'function relu(x){ return x > 0 ? x : 0; }',\r\n    identity: 'function identity(x){ return x; }',\r\n    step: 'function step(x){ return x > 0 ? 1 : 0; }',\r\n    softsign: 'function softsign(x){ return x / (1 + Math.abs(x)); }',\r\n    sinusoid: 'function sinusoid(x){ return Math.sin(x); }',\r\n    gaussian: 'function gaussian(x){ return Math.exp(-Math.pow(x, 2)); }',\r\n    bentIdentity:\r\n      'function bentIdentity(x){ return (Math.sqrt(Math.pow(x, 2) + 1) - 1) / 2 + x; }',\r\n    bipolar: 'function bipolar(x){ return x > 0 ? 1 : -1; }',\r\n    bipolarSigmoid:\r\n      'function bipolarSigmoid(x){ return 2 / (1 + Math.exp(-x)) - 1; }',\r\n    hardTanh: 'function hardTanh(x){ return Math.max(-1, Math.min(1, x)); }',\r\n    absolute: 'function absolute(x){ return Math.abs(x); }',\r\n    inverse: 'function inverse(x){ return 1 - x; }',\r\n    selu:\r\n      'function selu(x){ var a=1.6732632423543772,s=1.0507009873554805; var fx=x>0?x:a*Math.exp(x)-a; return fx*s; }',\r\n    softplus:\r\n      'function softplus(x){ if(x>30)return x; if(x<-30)return Math.exp(x); return Math.max(0,x)+Math.log(1+Math.exp(-Math.abs(x))); }',\r\n    swish: 'function swish(x){ var s=1/(1+Math.exp(-x)); return x*s; }',\r\n    gelu:\r\n      'function gelu(x){ var cdf=0.5*(1.0+Math.tanh(Math.sqrt(2.0/Math.PI)*(x+0.044715*Math.pow(x,3)))); return x*cdf; }',\r\n    mish:\r\n      'function mish(x){ var sp_x; if(x>30){sp_x=x;}else if(x<-30){sp_x=Math.exp(x);}else{sp_x=Math.log(1+Math.exp(x));} var tanh_sp_x=Math.tanh(sp_x); return x*tanh_sp_x; }',\r\n  };\r\n\r\n  // 2. Assign stable indices & collect runtime state seeds.\r\n  (net as any).nodes.forEach((node: any, nodeIndex: number) => {\r\n    node.index = nodeIndex;\r\n    initialActivations.push(node.activation);\r\n    initialStates.push(node.state);\r\n  });\r\n\r\n  // 3. Emit input seeding loop (direct copy of provided input into A[0..inputSize-1]).\r\n  bodyLines.push('for(var i = 0; i < input.length; i++) A[i] = input[i];');\r\n  // 4. Build computational body for each non-input node.\r\n  for (\r\n    let nodeIndex = (net as any).input;\r\n    nodeIndex < (net as any).nodes.length;\r\n    nodeIndex++\r\n  ) {\r\n    const node: any = (net as any).nodes[nodeIndex];\r\n    const squashFn: any = node.squash;\r\n    const squashName = squashFn.name || `anonymous_squash_${nodeIndex}`;\r\n    // Activation function emission (deduplicate by name).\r\n    if (!(squashName in emittedActivationSource)) {\r\n      let functionSource: string;\r\n      if (builtinActivationSnippets[squashName]) {\r\n        functionSource = builtinActivationSnippets[squashName];\r\n        // Guarantee explicit named function signature (normalize just in case snippet differs).\r\n        if (!functionSource.startsWith(`function ${squashName}`)) {\r\n          functionSource = `function ${squashName}${functionSource.substring(\r\n            functionSource.indexOf('(')\r\n          )}`;\r\n        }\r\n        functionSource = stripCoverage(functionSource);\r\n      } else {\r\n        // Attempt to stringify custom activation; fallback to identity if unparsable.\r\n        functionSource = squashFn.toString();\r\n        functionSource = stripCoverage(functionSource);\r\n        if (functionSource.startsWith('function')) {\r\n          functionSource = `function ${squashName}${functionSource.substring(\r\n            functionSource.indexOf('(')\r\n          )}`;\r\n        } else if (functionSource.includes('=>')) {\r\n          // Arrow function: treat substring from first '(' as params.\r\n          functionSource = `function ${squashName}${functionSource.substring(\r\n            functionSource.indexOf('(')\r\n          )}`;\r\n        } else {\r\n          functionSource = `function ${squashName}(x){ return x; }`;\r\n        }\r\n      }\r\n      emittedActivationSource[squashName] = functionSource;\r\n      activationFunctionSources.push(functionSource);\r\n      activationFunctionIndexMap[squashName] = nextActivationFunctionIndex++;\r\n    }\r\n    const activationFunctionIndex = activationFunctionIndexMap[squashName];\r\n    /** Weighted incoming terms (strings) assembled for nodeIndex. */\r\n    const incomingTerms: string[] = [];\r\n    // Standard feed-forward inbound connections.\r\n    for (const connection of node.connections.in) {\r\n      if (typeof connection.from.index === 'undefined') continue; // Skip malformed edge.\r\n      let term = `A[${connection.from.index}] * ${connection.weight}`;\r\n      // Gating multiplies the signal by the gate node activation (multiplicative modulation).\r\n      if (connection.gater && typeof connection.gater.index !== 'undefined') {\r\n        term += ` * A[${connection.gater.index}]`;\r\n      }\r\n      incomingTerms.push(term);\r\n    }\r\n    // Optional self-connection (recurrent contribution from prior state).\r\n    if (node.connections.self.length > 0) {\r\n      const selfConn = node.connections.self[0];\r\n      let term = `S[${nodeIndex}] * ${selfConn.weight}`;\r\n      if (selfConn.gater && typeof selfConn.gater.index !== 'undefined') {\r\n        term += ` * A[${selfConn.gater.index}]`;\r\n      }\r\n      incomingTerms.push(term);\r\n    }\r\n    /** Summation expression (0 if no inbound edges). */\r\n    const sumExpression =\r\n      incomingTerms.length > 0 ? incomingTerms.join(' + ') : '0';\r\n    bodyLines.push(`S[${nodeIndex}] = ${sumExpression} + ${node.bias};`);\r\n    /** Optional multiplicative mask (e.g., dropout mask captured previously). */\r\n    const maskValue =\r\n      typeof node.mask === 'number' && node.mask !== 1 ? node.mask : 1;\r\n    bodyLines.push(\r\n      `A[${nodeIndex}] = F[${activationFunctionIndex}](S[${nodeIndex}])${\r\n        maskValue !== 1 ? ` * ${maskValue}` : ''\r\n      };`\r\n    );\r\n  }\r\n  // 5. Gather output indices (tail section of node array).\r\n  const outputIndices: number[] = [];\r\n  for (\r\n    let nodeIndex = (net as any).nodes.length - (net as any).output;\r\n    nodeIndex < (net as any).nodes.length;\r\n    nodeIndex++\r\n  ) {\r\n    if (typeof ((net as any).nodes[nodeIndex] as any)?.index !== 'undefined') {\r\n      outputIndices.push(((net as any).nodes[nodeIndex] as any).index);\r\n    }\r\n  }\r\n  bodyLines.push(\r\n    `return [${outputIndices.map((idx) => `A[${idx}]`).join(',')}];`\r\n  );\r\n  // 6. Assemble final source with deterministic activation function ordering by index.\r\n  const activationArrayLiteral = Object.entries(activationFunctionIndexMap)\r\n    .sort(([, a], [, b]) => a - b)\r\n    .map(([name]) => name)\r\n    .join(',');\r\n  const activationArrayType =\r\n    (net as any)._activationPrecision === 'f32'\r\n      ? 'Float32Array'\r\n      : 'Float64Array';\r\n  let generatedSource = '';\r\n  generatedSource += `(function(){\\n`;\r\n  generatedSource += `${activationFunctionSources.join('\\n')}\\n`;\r\n  generatedSource += `var F = [${activationArrayLiteral}];\\n`;\r\n  generatedSource += `var A = new ${activationArrayType}([${initialActivations.join(\r\n    ','\r\n  )}]);\\n`;\r\n  generatedSource += `var S = new ${activationArrayType}([${initialStates.join(\r\n    ','\r\n  )}]);\\n`;\r\n  generatedSource += `function activate(input){\\n`;\r\n  generatedSource += `if (!input || input.length !== ${\r\n    (net as any).input\r\n  }) { throw new Error('Invalid input size. Expected ${\r\n    (net as any).input\r\n  }, got ' + (input ? input.length : 'undefined')); }\\n`;\r\n  generatedSource += bodyLines.join('\\n');\r\n  generatedSource += `}\\n`;\r\n  generatedSource += `return activate;\\n})();`;\r\n  return generatedSource;\r\n}\r\n", "import type Network from '../network';\r\nimport type Node from '../node';\r\n\r\n/**\r\n * Topology utilities.\r\n *\r\n * Provides:\r\n *  - computeTopoOrder: Kahn-style topological sorting with graceful fallback when cycles detected.\r\n *  - hasPath: depth-first reachability query (used to prevent cycle introduction when acyclicity enforced).\r\n *\r\n * Design Notes:\r\n *  - We deliberately tolerate cycles by falling back to raw node ordering instead of throwing; this\r\n *    allows callers performing interim structural mutations to proceed (e.g. during evolve phases)\r\n *    while signaling that the fast acyclic optimizations should not be used.\r\n *  - Input nodes are seeded into the queue immediately regardless of in-degree to keep them early in\r\n *    the ordering even if an unusual inbound edge was added (defensive redundancy).\r\n *  - Self loops are ignored for in-degree accounting and queue progression (they neither unlock new\r\n *    nodes nor should they block ordering completion).\r\n */\r\n\r\n/**\r\n * Compute a topological ordering (Kahn's algorithm) for the current directed acyclic graph.\r\n * If cycles are detected (order shorter than node count) we fall back to raw node order to avoid breaking callers.\r\n * In non-acyclic mode we simply clear cached order to signal use of sequential node array.\r\n */\r\nexport function computeTopoOrder(this: Network): void {\r\n  const internalNet = this as any;\r\n  // Fast exit: if acyclicity not enforced we discard any cached order (signals using raw nodes list).\r\n  if (!internalNet._enforceAcyclic) {\r\n    internalNet._topoOrder = null;\r\n    internalNet._topoDirty = false;\r\n    return;\r\n  }\r\n  /** In-degree tally per node (excluding self loops). */\r\n  const inDegree: Map<Node, number> = new Map();\r\n  this.nodes.forEach((node) => inDegree.set(node, 0));\r\n  for (const connection of this.connections) {\r\n    if (connection.from !== connection.to) {\r\n      inDegree.set(connection.to, (inDegree.get(connection.to) || 0) + 1);\r\n    }\r\n  }\r\n  /** Processing queue for Kahn's algorithm. */\r\n  const processingQueue: Node[] = [];\r\n  this.nodes.forEach((node) => {\r\n    if ((node as any).type === 'input' || (inDegree.get(node) || 0) === 0) {\r\n      processingQueue.push(node);\r\n    }\r\n  });\r\n  /** Accumulated topological order under construction. */\r\n  const topoOrder: Node[] = [];\r\n  while (processingQueue.length) {\r\n    /** Next node with satisfied dependencies. */\r\n    const node = processingQueue.shift()!;\r\n    topoOrder.push(node);\r\n    // Decrement in-degree of outgoing targets (ignoring self loops which were excluded earlier).\r\n    for (const outgoing of (node as any).connections.out) {\r\n      if (outgoing.to === node) continue; // Skip self loop.\r\n      const remaining = (inDegree.get(outgoing.to) || 0) - 1;\r\n      inDegree.set(outgoing.to, remaining);\r\n      if (remaining === 0) processingQueue.push(outgoing.to);\r\n    }\r\n  }\r\n  // Fallback: If cycle detected (not all nodes output), revert to raw node ordering to avoid partial order usage.\r\n  internalNet._topoOrder =\r\n    topoOrder.length === this.nodes.length ? topoOrder : this.nodes.slice();\r\n  internalNet._topoDirty = false;\r\n}\r\n\r\n/** Depth-first reachability test (avoids infinite loops via visited set). */\r\nexport function hasPath(this: Network, from: Node, to: Node): boolean {\r\n  if (from === to) return true; // Trivial reachability.\r\n  /** Visited node set to prevent infinite traversal on cycles. */\r\n  const visited = new Set<Node>();\r\n  /** Stack for explicit depth-first search (iterative to avoid recursion limits). */\r\n  const dfsStack: Node[] = [from];\r\n  while (dfsStack.length) {\r\n    const current = dfsStack.pop()!;\r\n    if (current === to) return true;\r\n    if (visited.has(current)) continue; // Already expanded.\r\n    visited.add(current);\r\n    for (const edge of (current as any).connections.out) {\r\n      if (edge.to !== current) dfsStack.push(edge.to); // Skip self loops.\r\n    }\r\n  }\r\n  return false;\r\n}\r\n", "import type Network from '../network';\r\nimport { activationArrayPool } from '../activationArrayPool';\r\n\r\n/**\r\n * Fast slab (structure-of-arrays) acceleration layer.\r\n *\r\n * Rationale:\r\n *  Typical neural network graphs represented as object graphs incur significant overhead during\r\n *  forward passes due to pointer chasing (cache misses) and dynamic property lookups. For large\r\n *  evolving populations where topologies change infrequently compared to evaluation frequency,\r\n *  we can amortize a one-off packing cost into contiguous typed arrays, dramatically improving\r\n *  memory locality and enabling tight inner loops.\r\n *\r\n * Core Data Structures:\r\n *  - weightArray     (Float32Array|Float64Array): connection weights\r\n *  - fromIndexArray  (Uint32Array): source node indices per connection\r\n *  - toIndexArray    (Uint32Array): destination node indices per connection\r\n *  - outgoingStartIndices (Uint32Array length = nodeCount + 1): CSR row pointer style offsets\r\n *  - outgoingOrder   (Uint32Array): permutation of connection indices grouped by source node\r\n *\r\n * Workflow:\r\n *  1. rebuildConnectionSlab packs connections into SoA arrays when dirty.\r\n *  2. _buildAdjacency converts fromIndexArray into CSR-like adjacency for each source node.\r\n *  3. fastSlabActivate uses the packed arrays + precomputed topological order to perform a forward pass\r\n *     with minimal branching and object access.\r\n *\r\n * Constraints for Fast Path (_canUseFastSlab):\r\n *  - Acyclic enforced (no recurrence) so single topological sweep suffices.\r\n *  - No gating, self-connections, dropout, stochastic depth, or per-hidden noise.\r\n *  - Topological order and node indices must be clean.\r\n *\r\n * Dirty Flags Touched:\r\n *  - _slabDirty: slab arrays need rebuild\r\n *  - _adjDirty: adjacency mapping (CSR) invalid\r\n *  - _nodeIndexDirty: node.index values invalid\r\n *  - _topoDirty: topological ordering invalid\r\n */\r\n\r\n/**\r\n * (Re)build packed connection slabs (SoA layout) for fast, cache-friendly forward passes.\r\n *\r\n * Slab arrays:\r\n *  - weights: Float32/64 contiguous weights\r\n *  - from: Uint32 source node indices\r\n *  - to:   Uint32 target node indices\r\n *\r\n * These enable tight loops free of object indirection; we update only when structure/weights marked dirty.\r\n */\r\nexport function rebuildConnectionSlab(this: Network, force = false): void {\r\n  const internalNet = this as any;\r\n  if (!force && !internalNet._slabDirty) return; // Already current; avoid reallocation churn.\r\n  if (internalNet._nodeIndexDirty) _reindexNodes.call(this); // Ensure node.index stable before packing.\r\n  /** Total number of forward connections to pack. */\r\n  const connectionCount = this.connections.length;\r\n  /** Contiguous weight buffer matching connection order. */\r\n  const weightArray = internalNet._useFloat32Weights\r\n    ? new Float32Array(connectionCount)\r\n    : new Float64Array(connectionCount);\r\n  /** Source node indices per connection (parallel to weightArray). */\r\n  const fromIndexArray = new Uint32Array(connectionCount);\r\n  /** Target node indices per connection (parallel to weightArray). */\r\n  const toIndexArray = new Uint32Array(connectionCount);\r\n  for (\r\n    let connectionIndex = 0;\r\n    connectionIndex < connectionCount;\r\n    connectionIndex++\r\n  ) {\r\n    /** Original connection object (read-only during packing). */\r\n    const connection = this.connections[connectionIndex];\r\n    weightArray[connectionIndex] = connection.weight; // Snapshot weight (mutations will mark dirty next time).\r\n    fromIndexArray[connectionIndex] = (connection.from as any).index >>> 0;\r\n    toIndexArray[connectionIndex] = (connection.to as any).index >>> 0;\r\n  }\r\n  internalNet._connWeights = weightArray;\r\n  internalNet._connFrom = fromIndexArray;\r\n  internalNet._connTo = toIndexArray;\r\n  internalNet._slabDirty = false;\r\n  internalNet._adjDirty = true; // CSR adjacency invalidated by rebuild.\r\n}\r\n\r\n/** Return current slab (building lazily). */\r\nexport function getConnectionSlab(this: Network) {\r\n  rebuildConnectionSlab.call(this); // Lazy rebuild if needed.\r\n  const internalNet = this as any;\r\n  return {\r\n    weights: internalNet._connWeights!,\r\n    from: internalNet._connFrom!,\r\n    to: internalNet._connTo!,\r\n  };\r\n}\r\n\r\n// Assign sequential indices (stable across slabs) to nodes.\r\nfunction _reindexNodes(this: Network) {\r\n  const internalNet = this as any;\r\n  for (let nodeIndex = 0; nodeIndex < this.nodes.length; nodeIndex++)\r\n    (this.nodes[nodeIndex] as any).index = nodeIndex;\r\n  internalNet._nodeIndexDirty = false;\r\n}\r\n\r\n// Build CSR-like adjacency (outgoing edge index ranges) for fast propagation in slab mode.\r\nfunction _buildAdjacency(this: Network) {\r\n  const internalNet = this as any;\r\n  if (!internalNet._connFrom || !internalNet._connTo) return; // Nothing to build yet.\r\n  /** Number of nodes in current network. */\r\n  const nodeCount = this.nodes.length;\r\n  /** Number of packed connections. */\r\n  const connectionCount = internalNet._connFrom.length;\r\n  /** Fan-out counts per source node (populated first pass). */\r\n  const fanOutCounts = new Uint32Array(nodeCount);\r\n  for (\r\n    let connectionIndex = 0;\r\n    connectionIndex < connectionCount;\r\n    connectionIndex++\r\n  ) {\r\n    fanOutCounts[internalNet._connFrom[connectionIndex]]++; // Tally outgoing edges per source.\r\n  }\r\n  /** CSR row pointer style start indices (length = nodeCount + 1). */\r\n  const outgoingStartIndices = new Uint32Array(nodeCount + 1);\r\n  /** Running offset while computing prefix sum of fanOutCounts. */\r\n  let runningOffset = 0;\r\n  for (let nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++) {\r\n    outgoingStartIndices[nodeIndex] = runningOffset;\r\n    runningOffset += fanOutCounts[nodeIndex];\r\n  }\r\n  outgoingStartIndices[nodeCount] = runningOffset; // Sentinel (total connections).\r\n  /** Permutation of connection indices grouped by source for contiguous traversal. */\r\n  const outgoingOrder = new Uint32Array(connectionCount);\r\n  /** Working cursor array (clone) used to place each connection into its slot. */\r\n  const insertionCursor = outgoingStartIndices.slice();\r\n  for (\r\n    let connectionIndex = 0;\r\n    connectionIndex < connectionCount;\r\n    connectionIndex++\r\n  ) {\r\n    const fromNodeIndex = internalNet._connFrom[connectionIndex];\r\n    outgoingOrder[insertionCursor[fromNodeIndex]++] = connectionIndex;\r\n  }\r\n  internalNet._outStart = outgoingStartIndices;\r\n  internalNet._outOrder = outgoingOrder;\r\n  internalNet._adjDirty = false;\r\n}\r\n\r\n// Eligibility conditions for fast slab path (must avoid scenarios needing per-edge dynamic behavior)\r\nfunction _canUseFastSlab(this: Network, training: boolean): boolean {\r\n  const internalNet = this as any;\r\n  return (\r\n    !training && // Training may require gradients / noise injection.\r\n    internalNet._enforceAcyclic && // Must have acyclic guarantee for single forward sweep.\r\n    !internalNet._topoDirty && // Topological order must be current.\r\n    this.gates.length === 0 && // Gating implies dynamic per-edge behavior.\r\n    this.selfconns.length === 0 && // Self connections require recurrent handling.\r\n    this.dropout === 0 && // Dropout introduces stochastic masking.\r\n    internalNet._weightNoiseStd === 0 && // Global weight noise disables deterministic slab pass.\r\n    internalNet._weightNoisePerHidden.length === 0 && // Per hidden noise variants.\r\n    internalNet._stochasticDepth.length === 0 // Layer drop also stochastic.\r\n  );\r\n}\r\n\r\n/**\r\n * High-performance forward pass using packed slabs + CSR adjacency.\r\n * Falls back to generic activate if prerequisites unavailable.\r\n */\r\nexport function fastSlabActivate(this: Network, input: number[]): number[] {\r\n  const internalNet = this as any;\r\n  rebuildConnectionSlab.call(this); // Ensure slabs up-to-date (no-op if clean).\r\n  if (internalNet._adjDirty) _buildAdjacency.call(this); // Build CSR adjacency if needed.\r\n  if (\r\n    !internalNet._connWeights ||\r\n    !internalNet._connFrom ||\r\n    !internalNet._connTo ||\r\n    !internalNet._outStart ||\r\n    !internalNet._outOrder\r\n  ) {\r\n    return (this as any).activate(input, false); // Fallback: prerequisites missing.\r\n  }\r\n  if (internalNet._topoDirty) (this as any)._computeTopoOrder();\r\n  if (internalNet._nodeIndexDirty) _reindexNodes.call(this);\r\n  /** Topologically sorted nodes (or original order if already acyclic & clean). */\r\n  const topoOrder = internalNet._topoOrder || this.nodes;\r\n  /** Total node count. */\r\n  const nodeCount = this.nodes.length;\r\n  /** Whether to store activations in 32-bit for memory/bandwidth or 64-bit for precision. */\r\n  const useFloat32Activation = internalNet._activationPrecision === 'f32';\r\n  // Allocate / reuse activation & state typed arrays (avoid reallocating each forward pass).\r\n  if (\r\n    !internalNet._fastA ||\r\n    internalNet._fastA.length !== nodeCount ||\r\n    (useFloat32Activation && !(internalNet._fastA instanceof Float32Array)) ||\r\n    (!useFloat32Activation && !(internalNet._fastA instanceof Float64Array))\r\n  ) {\r\n    internalNet._fastA = useFloat32Activation\r\n      ? new Float32Array(nodeCount)\r\n      : new Float64Array(nodeCount);\r\n  }\r\n  if (\r\n    !internalNet._fastS ||\r\n    internalNet._fastS.length !== nodeCount ||\r\n    (useFloat32Activation && !(internalNet._fastS instanceof Float32Array)) ||\r\n    (!useFloat32Activation && !(internalNet._fastS instanceof Float64Array))\r\n  ) {\r\n    internalNet._fastS = useFloat32Activation\r\n      ? new Float32Array(nodeCount)\r\n      : new Float64Array(nodeCount);\r\n  }\r\n  /** Activation buffer (post-squash outputs). */\r\n  const activationBuffer = internalNet._fastA as Float32Array | Float64Array;\r\n  /** Pre-activation sum buffer (accumulates weighted inputs). */\r\n  const stateBuffer = internalNet._fastS as Float32Array | Float64Array;\r\n  stateBuffer.fill(0);\r\n  // Seed input activations directly (no accumulation for inputs).\r\n  for (let inputIndex = 0; inputIndex < this.input; inputIndex++) {\r\n    activationBuffer[inputIndex] = input[inputIndex];\r\n    (this.nodes[inputIndex] as any).activation = input[inputIndex];\r\n    (this.nodes[inputIndex] as any).state = 0;\r\n  }\r\n  /** Packed connection weights. */\r\n  const weightArray = internalNet._connWeights;\r\n  /** Packed destination node indices per connection. */\r\n  const toIndexArray = internalNet._connTo;\r\n  /** Connection index order grouped by source (CSR style). */\r\n  const outgoingOrder = internalNet._outOrder;\r\n  /** Row pointer style start offsets for each source node. */\r\n  const outgoingStartIndices = internalNet._outStart;\r\n  // Iterate nodes in topological order, computing activations then streaming contributions forward.\r\n  for (let topoIdx = 0; topoIdx < topoOrder.length; topoIdx++) {\r\n    const node: any = topoOrder[topoIdx];\r\n    const nodeIndex = node.index >>> 0;\r\n    if (nodeIndex >= this.input) {\r\n      /** Weighted input sum plus bias. */\r\n      const weightedSum = stateBuffer[nodeIndex] + node.bias;\r\n      /** Activated output via node's squash function. */\r\n      const activated = node.squash(weightedSum);\r\n      node.state = stateBuffer[nodeIndex];\r\n      node.activation = activated;\r\n      activationBuffer[nodeIndex] = activated;\r\n    }\r\n    // Propagate activation along outgoing edges.\r\n    const edgeStart = outgoingStartIndices[nodeIndex];\r\n    const edgeEnd = outgoingStartIndices[nodeIndex + 1];\r\n    const sourceActivation = activationBuffer[nodeIndex];\r\n    for (let cursorIdx = edgeStart; cursorIdx < edgeEnd; cursorIdx++) {\r\n      const connectionIndex = outgoingOrder[cursorIdx];\r\n      stateBuffer[toIndexArray[connectionIndex]] +=\r\n        sourceActivation * weightArray[connectionIndex];\r\n    }\r\n  }\r\n  // Collect outputs: final output nodes occupy the tail of the node list.\r\n  const outputBaseIndex = nodeCount - this.output;\r\n  const pooledOutputArray = activationArrayPool.acquire(this.output);\r\n  for (let outputOffset = 0; outputOffset < this.output; outputOffset++) {\r\n    (pooledOutputArray as any)[outputOffset] =\r\n      activationBuffer[outputBaseIndex + outputOffset];\r\n  }\r\n  const result = Array.from(pooledOutputArray as any) as number[]; // Detach buffer into regular array.\r\n  activationArrayPool.release(pooledOutputArray);\r\n  return result;\r\n}\r\n\r\n/** Public helper: indicates whether fast slab path is currently viable. */\r\nexport function canUseFastSlab(this: Network, training: boolean) {\r\n  return _canUseFastSlab.call(this, training);\r\n}\r\n", "import type Network from '../network';\r\nimport Node from '../node';\r\nimport Connection from '../connection';\r\n\r\n/**\r\n * Structured and dynamic pruning utilities for networks.\r\n *\r\n * Features:\r\n *  - Scheduled pruning during gradient-based training ({@link maybePrune}) with linear sparsity ramp.\r\n *  - Evolutionary generation pruning toward a target sparsity ({@link pruneToSparsity}).\r\n *  - Two ranking heuristics:\r\n *      magnitude: |w|\r\n *      snip: |w * g| approximation (g approximated via accumulated delta stats; falls back to |w|)\r\n *  - Optional stochastic regrowth during scheduled pruning (dynamic sparse training), preserving acyclic constraints.\r\n *\r\n * Internal State Fields (attached to Network via `any` casting):\r\n *  - _pruningConfig: user-specified schedule & options (start, end, frequency, targetSparsity, method, regrowFraction, lastPruneIter)\r\n *  - _initialConnectionCount: baseline connection count captured outside (first training iteration)\r\n *  - _evoInitialConnCount: baseline for evolutionary pruning (first invocation of pruneToSparsity)\r\n *  - _rand: deterministic RNG function\r\n *  - _enforceAcyclic: boolean flag enforcing forward-only connectivity ordering\r\n *  - _topoDirty: topology order invalidation flag consumed by activation fast path / topological sorting\r\n */\r\n\r\n// ---------------------------------------------------------------------------\r\n// Internal helpers (not exported)\r\n// ---------------------------------------------------------------------------\r\n\r\n/** Rank connections ascending by removal priority according to a method. */\r\nfunction rankConnections(\r\n  conns: Connection[],\r\n  method: 'magnitude' | 'snip'\r\n): Connection[] {\r\n  /** Shallow copy of connections to be sorted by removal priority (ascending). */\r\n  const ranked = [...conns];\r\n  if (method === 'snip') {\r\n    ranked.sort((a: any, b: any) => {\r\n      /** Gradient magnitude proxy for connection A (uses accumulated or last delta). */\r\n      const gradMagA =\r\n        Math.abs(a.totalDeltaWeight) || Math.abs(a.previousDeltaWeight) || 0;\r\n      /** Gradient magnitude proxy for connection B (uses accumulated or last delta). */\r\n      const gradMagB =\r\n        Math.abs(b.totalDeltaWeight) || Math.abs(b.previousDeltaWeight) || 0;\r\n      /** Saliency estimate for connection A (|w| * |g| fallback to |w|). */\r\n      const saliencyA = gradMagA\r\n        ? Math.abs(a.weight) * gradMagA\r\n        : Math.abs(a.weight);\r\n      /** Saliency estimate for connection B (|w| * |g| fallback to |w|). */\r\n      const saliencyB = gradMagB\r\n        ? Math.abs(b.weight) * gradMagB\r\n        : Math.abs(b.weight);\r\n      return saliencyA - saliencyB; // ascending => remove lowest first\r\n    });\r\n  } else {\r\n    ranked.sort((a, b) => Math.abs(a.weight) - Math.abs(b.weight));\r\n  }\r\n  return ranked;\r\n}\r\n\r\n/** Attempt stochastic regrowth of pruned connections up to a desired remaining count. */\r\nfunction regrowConnections(\r\n  network: Network,\r\n  desiredRemaining: number,\r\n  maxAttempts: number\r\n) {\r\n  /** Internal network reference for private fields (_rand, _enforceAcyclic). */\r\n  const netAny = network as any;\r\n  /** Number of attempted regrowth trials so far. */\r\n  let attempts = 0;\r\n  while (\r\n    network.connections.length < desiredRemaining &&\r\n    attempts < maxAttempts\r\n  ) {\r\n    attempts++;\r\n    /** Random source node candidate for a new connection. */\r\n    const fromNode =\r\n      network.nodes[Math.floor(netAny._rand() * network.nodes.length)];\r\n    /** Random target node candidate for a new connection. */\r\n    const toNode =\r\n      network.nodes[Math.floor(netAny._rand() * network.nodes.length)];\r\n    if (!fromNode || !toNode || fromNode === toNode) continue; // invalid pair\r\n    if (network.connections.some((c) => c.from === fromNode && c.to === toNode))\r\n      continue; // duplicate\r\n    if (\r\n      netAny._enforceAcyclic &&\r\n      network.nodes.indexOf(fromNode) > network.nodes.indexOf(toNode)\r\n    )\r\n      continue; // violates order\r\n    network.connect(fromNode, toNode);\r\n  }\r\n}\r\n\r\n/**\r\n * Opportunistically perform scheduled pruning during gradient-based training.\r\n *\r\n * Scheduling model:\r\n *  - start / end define an iteration window (inclusive) during which pruning may occur\r\n *  - frequency defines cadence (every N iterations inside the window)\r\n *  - targetSparsity is linearly annealed from 0 to its final value across the window\r\n *  - method chooses ranking heuristic (magnitude | snip)\r\n *  - optional regrowFraction allows dynamic sparse training: after removing edges we probabilistically regrow\r\n *    a fraction of them at random unused positions (respecting acyclic constraint if enforced)\r\n *\r\n * SNIP heuristic:\r\n *  - Uses |w * grad| style saliency approximation (here reusing stored delta stats as gradient proxy)\r\n *  - Falls back to pure magnitude if gradient stats absent.\r\n */\r\n/**\r\n * Perform scheduled pruning at a given training iteration if conditions are met.\r\n *\r\n * Scheduling fields (cfg): start, end, frequency, targetSparsity, method ('magnitude' | 'snip'), regrowFraction.\r\n * The target sparsity ramps linearly from 0 at start to cfg.targetSparsity at end.\r\n *\r\n * @param iteration Current (0-based or 1-based) training iteration counter used for scheduling.\r\n */\r\nexport function maybePrune(this: Network, iteration: number): void {\r\n  /** Active pruning configuration attached to the network (or undefined if disabled). */\r\n  const cfg: any = (this as any)._pruningConfig; // internal schedule/config\r\n  if (!cfg) return; // disabled\r\n  if (iteration < cfg.start || iteration > cfg.end) return; // outside schedule window\r\n  if (cfg.lastPruneIter != null && iteration === cfg.lastPruneIter) return; // already pruned this iteration\r\n  if ((iteration - cfg.start) % (cfg.frequency || 1) !== 0) return; // off-cycle\r\n  /** Baseline connection count captured at training start for scheduled pruning reference. */\r\n  const initialConnectionBaseline = (this as any)._initialConnectionCount;\r\n  if (!initialConnectionBaseline) return; // baseline not captured yet\r\n\r\n  /** Progress fraction (0..1) through pruning window. */\r\n  const progressFraction =\r\n    (iteration - cfg.start) / Math.max(1, cfg.end - cfg.start);\r\n  /** Instantaneous target sparsity (linearly annealed). */\r\n  const targetSparsityNow =\r\n    cfg.targetSparsity * Math.min(1, Math.max(0, progressFraction));\r\n  /** Desired remaining connection count based on baseline & current sparsity. */\r\n  const desiredRemainingConnections = Math.max(\r\n    1,\r\n    Math.floor(initialConnectionBaseline * (1 - targetSparsityNow))\r\n  );\r\n  /** Excess connections present right now that should be removed to hit schedule target. */\r\n  const excessConnectionCount =\r\n    this.connections.length - desiredRemainingConnections;\r\n  if (excessConnectionCount <= 0) {\r\n    cfg.lastPruneIter = iteration;\r\n    return;\r\n  }\r\n\r\n  /** Ranked connections ascending by removal priority. */\r\n  const rankedConnections = rankConnections(\r\n    this.connections,\r\n    cfg.method || 'magnitude'\r\n  );\r\n  /** Subset of connections to prune this iteration. */\r\n  const connectionsToPrune = rankedConnections.slice(0, excessConnectionCount);\r\n  connectionsToPrune.forEach((conn) => this.disconnect(conn.from, conn.to));\r\n\r\n  // Dynamic sparse regrowth (optional) to maintain target density while allowing exploration.\r\n  if (cfg.regrowFraction && cfg.regrowFraction > 0) {\r\n    /** Intended number of new connections to attempt to regrow (before attempt limit multiplier). */\r\n    const intendedRegrowCount = Math.floor(\r\n      connectionsToPrune.length * cfg.regrowFraction\r\n    );\r\n    regrowConnections(\r\n      this,\r\n      desiredRemainingConnections,\r\n      intendedRegrowCount * 10\r\n    );\r\n  }\r\n\r\n  cfg.lastPruneIter = iteration; // record bookkeeping\r\n  (this as any)._topoDirty = true; // structural change => invalidate cached order\r\n}\r\n\r\n/**\r\n * Evolutionary (generation-based) pruning toward a target sparsity baseline.\r\n * Unlike maybePrune this operates immediately relative to the first invocation's connection count\r\n * (stored separately as _evoInitialConnCount) and does not implement scheduling or regrowth.\r\n */\r\nexport function pruneToSparsity(\r\n  this: Network,\r\n  targetSparsity: number,\r\n  method: 'magnitude' | 'snip' = 'magnitude'\r\n): void {\r\n  if (targetSparsity <= 0) return; // trivial\r\n  if (targetSparsity >= 1) targetSparsity = 0.999; // safety clamp\r\n  /** Internal network reference for private evolutionary baseline. */\r\n  const netAny = this as any;\r\n  if (!netAny._evoInitialConnCount)\r\n    netAny._evoInitialConnCount = this.connections.length; // capture baseline only once\r\n  /** Connection count baseline at first evolutionary pruning invocation. */\r\n  const evolutionaryBaseline = netAny._evoInitialConnCount;\r\n  /** Desired number of connections to retain. */\r\n  const desiredRemainingConnections = Math.max(\r\n    1,\r\n    Math.floor(evolutionaryBaseline * (1 - targetSparsity))\r\n  );\r\n  /** Excess relative to desired number. */\r\n  const excessConnectionCount =\r\n    this.connections.length - desiredRemainingConnections;\r\n  if (excessConnectionCount <= 0) return; // already at or below target\r\n  /** Ranked connections ascending by removal priority. */\r\n  const rankedConnections = rankConnections(this.connections, method);\r\n  /** Slice of ranked connections to remove to reach target sparsity. */\r\n  const connectionsToRemove = rankedConnections.slice(0, excessConnectionCount);\r\n  connectionsToRemove.forEach((c) => this.disconnect(c.from, c.to));\r\n  netAny._topoDirty = true;\r\n}\r\n\r\n/** Current sparsity fraction relative to the training-time pruning baseline. */\r\nexport function getCurrentSparsity(this: Network): number {\r\n  /** Baseline connection count used for scheduled pruning sparsity measurement. */\r\n  const initialBaseline = (this as any)._initialConnectionCount;\r\n  if (!initialBaseline) return 0;\r\n  return 1 - this.connections.length / initialBaseline;\r\n}\r\n\r\n// Explicit export object to keep module side-effects clear (tree-shaking friendliness)\r\nexport {};\r\n", "import type Network from '../network';\r\nimport Node from '../node';\r\nimport Connection from '../connection';\r\nimport mutation from '../../methods/mutation';\r\nimport { config } from '../../config';\r\n\r\n/**\r\n * Gating & node removal utilities for {@link Network}.\r\n *\r\n * Gating concept:\r\n *  - A \"gater\" node modulates the effective weight of a target connection. Conceptually the raw\r\n *    connection weight w is multiplied (or otherwise transformed) by a function of the gater node's\r\n *    activation a_g (actual math lives in {@link Node.gate}). This enables dynamic, context-sensitive\r\n *    routing (similar in spirit to attention mechanisms or LSTM-style gates) within an evolved topology.\r\n *\r\n * Removal strategy (removeNode):\r\n *  - When excising a hidden node we attempt to preserve overall connectivity by creating bridging\r\n *    connections from each of its predecessors to each of its successors if such edges do not already\r\n *    exist. Optional logic reassigns previous gater nodes to these new edges (best-effort) to preserve\r\n *    modulation diversity.\r\n *\r\n * Mutation interplay:\r\n *  - The flag `mutation.SUB_NODE.keep_gates` determines whether gating nodes associated with edges\r\n *    passing through the removed node should be retained and reassigned.\r\n *\r\n * Determinism note:\r\n *  - Bridging gate reassignment currently uses Math.random directly; for fully deterministic runs\r\n *    you may consider replacing with the network's seeded RNG (if provided) in future refactors.\r\n *\r\n * Exported functions:\r\n *  - {@link gate}: Attach a gater to a connection.\r\n *  - {@link ungate}: Remove gating from a connection.\r\n *  - {@link removeNode}: Remove a hidden node while attempting to preserve connectivity & gating.\r\n *\r\n * @module network.gating\r\n */\r\n\r\n/**\r\n * Attach a gater node to a connection so that the connection's effective weight\r\n * becomes dynamically modulated by the gater's activation (see {@link Node.gate} for exact math).\r\n *\r\n * Validation / invariants:\r\n *  - Throws if the gater node is not part of this network (prevents cross-network corruption).\r\n *  - If the connection is already gated, function is a no-op (emits warning when enabled).\r\n *\r\n * Complexity: O(1)\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @param node - Candidate gater node (must belong to network).\r\n * @param connection - Connection to gate.\r\n */\r\nexport function gate(this: Network, node: Node, connection: Connection) {\r\n  if (!this.nodes.includes(node))\r\n    throw new Error(\r\n      'Gating node must be part of the network to gate a connection!'\r\n    );\r\n  if (connection.gater) {\r\n    if (config.warnings) console.warn('Connection is already gated. Skipping.');\r\n    return;\r\n  }\r\n  node.gate(connection); // Delegate per-node bookkeeping (adds to node.connections.gated & sets connection.gater)\r\n  this.gates.push(connection); // Track globally for fast iteration / serialization.\r\n}\r\n\r\n/**\r\n * Remove gating from a connection, restoring its static weight contribution.\r\n *\r\n * Idempotent: If the connection is not currently gated, the call performs no structural changes\r\n * (and optionally logs a warning). After ungating, the connection's weight will be used directly\r\n * without modulation by a gater activation.\r\n *\r\n * Complexity: O(n) where n = number of gated connections (indexOf lookup) \u2013 typically small.\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @param connection - Connection to ungate.\r\n */\r\nexport function ungate(this: Network, connection: Connection) {\r\n  /** Index of the connection within the global gates list ( -1 if not found ). */\r\n  const index = this.gates.indexOf(connection);\r\n  if (index === -1) {\r\n    if (config.warnings)\r\n      console.warn('Attempted to ungate a connection not in the gates list.');\r\n    return;\r\n  }\r\n  this.gates.splice(index, 1); // Remove from global gated list.\r\n  connection.gater?.ungate(connection); // Remove reverse reference from the gater node.\r\n}\r\n\r\n/**\r\n * Remove a hidden node from the network while attempting to preserve functional connectivity.\r\n *\r\n * Algorithm outline:\r\n *  1. Reject removal if node is input/output (structural invariants) or absent (error).\r\n *  2. Optionally collect gating nodes (if keep_gates flag) from inbound & outbound connections.\r\n *  3. Remove self-loop (if present) to simplify subsequent edge handling.\r\n *  4. Disconnect all inbound edges (record their source nodes) and all outbound edges (record targets).\r\n *  5. For every (input predecessor, output successor) pair create a new connection unless:\r\n *       a. input === output (avoid trivial self loops) OR\r\n *       b. an existing projection already connects them.\r\n *  6. Reassign preserved gater nodes randomly onto newly created bridging connections.\r\n *  7. Ungate any connections that were gated BY this node (where node acted as gater).\r\n *  8. Remove node from network node list and flag node index cache as dirty.\r\n *\r\n * Complexity summary:\r\n *  - Let I = number of inbound edges, O = number of outbound edges.\r\n *  - Disconnect phase: O(I + O)\r\n *  - Bridging phase: O(I * O) connection existence checks (isProjectingTo) + potential additions.\r\n *  - Gater reassignment: O(min(G, newConnections)) where G is number of preserved gaters.\r\n *\r\n * Preservation rationale:\r\n *  - Reassigning gaters maintains some of the dynamic modulation capacity that would otherwise\r\n *    be lost, aiding continuity during topology simplification.\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @param node - Hidden node to remove.\r\n * @throws If node is input/output or not present in network.\r\n */\r\nexport function removeNode(this: Network, node: Node) {\r\n  if (node.type === 'input' || node.type === 'output')\r\n    throw new Error('Cannot remove input or output node from the network.');\r\n  const idx = this.nodes.indexOf(node);\r\n  if (idx === -1) throw new Error('Node not found in the network for removal.');\r\n\r\n  // Collected gating nodes to potentially reattach to new bridging connections.\r\n  /** Collection of gater nodes preserved for reassignment onto new bridging connections. */\r\n  const gaters: Node[] = [];\r\n\r\n  // Remove self-loop first (simplifies later logic and ensures gating removal handled early).\r\n  this.disconnect(node, node);\r\n\r\n  // Gather inbound source nodes and optionally preserve their gaters.\r\n  /** List of source nodes feeding into the node being removed (predecessors). */\r\n  const inputs: Node[] = [];\r\n  for (let i = node.connections.in.length - 1; i >= 0; i--) {\r\n    const c = node.connections.in[i];\r\n    if (mutation.SUB_NODE.keep_gates && c.gater && c.gater !== node)\r\n      gaters.push(c.gater);\r\n    inputs.push(c.from);\r\n    this.disconnect(c.from, node);\r\n  }\r\n\r\n  // Gather outbound destination nodes similarly.\r\n  /** List of destination nodes the node being removed projects to (successors). */\r\n  const outputs: Node[] = [];\r\n  for (let i = node.connections.out.length - 1; i >= 0; i--) {\r\n    const c = node.connections.out[i];\r\n    if (mutation.SUB_NODE.keep_gates && c.gater && c.gater !== node)\r\n      gaters.push(c.gater);\r\n    outputs.push(c.to);\r\n    this.disconnect(node, c.to);\r\n  }\r\n\r\n  // Create bridging connections between every predecessor and successor (if not already connected).\r\n  /** New bridging connections created to preserve path connectivity after removal. */\r\n  const newConns: Connection[] = [];\r\n  for (const input of inputs) {\r\n    for (const output of outputs) {\r\n      // Skip trivial self-loop & skip if an existing connection already links them.\r\n      if (input !== output && !input.isProjectingTo(output)) {\r\n        const conn = this.connect(input, output);\r\n        if (conn.length) newConns.push(conn[0]); // Only record created connection\r\n      }\r\n    }\r\n  }\r\n\r\n  // Reassign preserved gaters randomly to newly formed bridging connections.\r\n  for (const g of gaters) {\r\n    if (!newConns.length) break; // No more candidate connections\r\n    /** Random index into the remaining pool of new bridging connections for gater reassignment. */\r\n    const ci = Math.floor(Math.random() * newConns.length);\r\n    this.gate(g, newConns[ci]);\r\n    newConns.splice(ci, 1); // Avoid double\u2011gating same connection\r\n  }\r\n\r\n  // Ungate connections that were gated by the removed node itself.\r\n  for (let i = node.connections.gated.length - 1; i >= 0; i--) {\r\n    this.ungate(node.connections.gated[i]);\r\n  }\r\n\r\n  // Final removal & cache invalidation (indices may be used by fast lookup structures elsewhere).\r\n  this.nodes.splice(idx, 1);\r\n  (this as any)._nodeIndexDirty = true;\r\n}\r\n\r\n// Only functions exported; keep module shape predictable for tree-shaking / documentation tooling.\r\nexport {};\r\n", "import type Network from '../network';\r\n\r\n/**\r\n * Deterministic pseudo\u2011random number generation (PRNG) utilities for {@link Network}.\r\n *\r\n * Why this module exists:\r\n *  - Facilitates reproducible evolutionary runs / gradient training by allowing explicit seeding.\r\n *  - Centralizes RNG state management & snapshot/restore operations (useful for rollbacks or\r\n *    deterministic tests around mutation sequences).\r\n *  - Keeps the core Network class focused by extracting ancillary RNG concerns.\r\n *\r\n * Implementation notes:\r\n *  - Uses a small, fast 32\u2011bit xorshift / mix style generator (same semantics as the legacy inline version)\r\n *    combining an additive Weyl sequence step plus a few avalanche-style integer mixes.\r\n *  - Not cryptographically secure. Do not use for security / fairness sensitive applications.\r\n *  - Produces floating point numbers in [0,1) with 2^32 (~4.29e9) discrete possible mantissa states.\r\n *\r\n * Public surface:\r\n *  - {@link setSeed}: Initialize deterministic generator with a numeric seed.\r\n *  - {@link snapshotRNG}: Capture current training step + raw internal RNG state.\r\n *  - {@link restoreRNG}: Provide an externally saved RNG function (advanced) & clear stored state.\r\n *  - {@link getRNGState} / {@link setRNGState}: Low-level accessors for the internal 32\u2011bit state word.\r\n *  - {@link getRandomFn}: Retrieve the active random() function reference (primarily for tests / tooling).\r\n *\r\n * Design rationale:\r\n *  - Storing both a state integer (_rngState) and a function (_rand) allows hot-swapping alternative\r\n *    RNG implementations (e.g., for benchmarking or pluggable randomness strategies) without rewriting\r\n *    callsites inside Network algorithms.\r\n *\r\n * @module network.deterministic\r\n */\r\n\r\n/** Shape of an RNG snapshot object. */\r\nexport interface RNGSnapshot {\r\n  step: number | undefined;\r\n  state: number | undefined;\r\n}\r\n\r\n/**\r\n * Seed the internal PRNG and install a deterministic random() implementation on the Network instance.\r\n *\r\n * Process:\r\n *  1. Coerce the provided seed to an unsigned 32\u2011bit integer (>>> 0) for predictable wraparound behavior.\r\n *  2. Define an inline closure that advances an internal 32\u2011bit state using:\r\n *       a. A Weyl increment (adding constant 0x6D2B79F5 each call) ensuring full-period traversal of\r\n *          the 32\u2011bit space when combined with mixing.\r\n *       b. Two rounds of xorshift / integer mixing (xor, shifts, multiplications) to decorrelate bits.\r\n *       c. Normalization to [0,1) by dividing the final 32\u2011bit unsigned integer by 2^32.\r\n *\r\n * Bit-mixing explanation (rough intuition):\r\n *  - XOR with shifted versions spreads high-order entropy to lower bits.\r\n *  - Multiplication (Math.imul) with carefully chosen odd constants introduces non-linear mixing.\r\n *  - The final right shift & xor avalanche aims to reduce sequential correlation.\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @param seed - Any finite number; only its lower 32 bits are used.\r\n * @example\r\n * net.setSeed(1234);\r\n * const a = net.getRandomFn()(); // deterministic given the seed\r\n * net.setSeed(1234);\r\n * const b = net.getRandomFn()(); // a === b\r\n */\r\nexport function setSeed(this: Network, seed: number): void {\r\n  // Store 32-bit unsigned state (bitwise ops in JS operate on signed 32-bit but we keep consistency via >>> 0).\r\n  (this as any)._rngState = seed >>> 0;\r\n  // Install PRNG closure referencing _rngState by name for mutation on each invocation.\r\n  (this as any)._rand = () => {\r\n    // Add Weyl constant (chosen odd constant) & coerce to uint32 wraparound.\r\n    (this as any)._rngState = ((this as any)._rngState + 0x6d2b79f5) >>> 0;\r\n    // First mix: xor with shifted self and multiply (Math.imul preserves 32-bit overflow semantics).\r\n    let r = Math.imul(\r\n      (this as any)._rngState ^ ((this as any)._rngState >>> 15),\r\n      1 | (this as any)._rngState\r\n    );\r\n    // Second mix: avalanche style bit diffusion.\r\n    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);\r\n    // Final xor/shift; convert to unsigned, then scale to [0,1).\r\n    return ((r ^ (r >>> 14)) >>> 0) / 4294967296; // 2^32\r\n  };\r\n}\r\n\r\n/**\r\n * Capture a snapshot of the RNG state together with the network's training step.\r\n *\r\n * Useful for implementing speculative evolutionary mutations where you may revert both the\r\n * structural change and the randomness timeline if accepting/rejecting a candidate.\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @returns Object containing current training step & 32\u2011bit RNG state (both possibly undefined if unseeded).\r\n * @example\r\n * const snap = net.snapshotRNG();\r\n * // ... perform operations\r\n * net.setRNGState(snap.state!);\r\n */\r\nexport function snapshotRNG(this: Network): RNGSnapshot {\r\n  return { step: (this as any)._trainingStep, state: (this as any)._rngState };\r\n}\r\n\r\n/**\r\n * Restore a previously captured RNG function implementation (advanced usage).\r\n *\r\n * This does NOT rehydrate _rngState (it explicitly sets it to undefined). Intended for scenarios\r\n * where a caller has customly serialized a full RNG closure or wants to inject a deterministic stub.\r\n * If you only need to restore the raw state word produced by {@link snapshotRNG}, prefer\r\n * {@link setRNGState} instead.\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @param fn - Function returning a pseudo\u2011random number in [0,1). Caller guarantees determinism if required.\r\n * @example\r\n * const original = net.getRandomFn();\r\n * net.restoreRNG(() => 0.5); // force constant RNG for a test\r\n * // ... test invariants ...\r\n * net.restoreRNG(original); // restore\r\n */\r\nexport function restoreRNG(this: Network, fn: () => number): void {\r\n  (this as any)._rand = fn;\r\n  (this as any)._rngState = undefined;\r\n}\r\n\r\n/**\r\n * Get the current internal 32\u2011bit RNG state value.\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @returns Unsigned 32\u2011bit state integer or undefined if generator not yet seeded or was reset.\r\n */\r\nexport function getRNGState(this: Network): number | undefined {\r\n  return (this as any)._rngState as number | undefined;\r\n}\r\n\r\n/**\r\n * Explicitly set (override) the internal 32\u2011bit RNG state without changing the generator function.\r\n *\r\n * This is a low\u2011level operation; typical clients should call {@link setSeed}. Provided for advanced\r\n * replay functionality where the same PRNG algorithm is assumed but you want to resume exactly at a\r\n * known state word.\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @param state - Any finite number (only low 32 bits used). Ignored if not numeric.\r\n */\r\nexport function setRNGState(this: Network, state: number): void {\r\n  if (typeof state === 'number') (this as any)._rngState = state >>> 0;\r\n}\r\n\r\n/**\r\n * Retrieve the active random function reference (for testing, instrumentation, or swapping).\r\n *\r\n * Mutating the returned function's closure variables (if any) is not recommended; prefer using\r\n * higher-level APIs (setSeed / restoreRNG) to manage state.\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @returns Function producing numbers in [0,1). May be undefined if never seeded (call setSeed first).\r\n */\r\nexport function getRandomFn(this: Network): (() => number) | undefined {\r\n  return (this as any)._rand as () => number;\r\n}\r\n\r\n/**\r\n * Default export bundle for convenient named imports.\r\n */\r\nexport default {\r\n  setSeed,\r\n  snapshotRNG,\r\n  restoreRNG,\r\n  getRNGState,\r\n  setRNGState,\r\n  getRandomFn,\r\n};\r\n", "import type Network from '../network';\r\n\r\n/**\r\n * Network statistics accessors.\r\n *\r\n * Currently exposes a single helper for retrieving the most recent regularization / stochasticity\r\n * metrics snapshot recorded during training or evaluation. The internal `_lastStats` field (on the\r\n * Network instance, typed as any) is expected to be populated elsewhere in the training loop with\r\n * values such as:\r\n *  - l1Penalty, l2Penalty\r\n *  - dropoutApplied (fraction of units dropped last pass)\r\n *  - weightNoiseStd (effective std dev used if noise injected)\r\n *  - sparsityRatio, prunedConnections\r\n *  - any custom user extensions (object is not strictly typed to allow experimentation)\r\n *\r\n * Design decision: We return a deep copy to prevent external mutation of internal accounting state.\r\n * If the object is large and copying becomes a bottleneck, future versions could offer a freeze\r\n * option or incremental diff interface.\r\n */\r\n\r\n/**\r\n * Deep clone utility with a resilient fallback strategy.\r\n *\r\n * Priority order:\r\n *  1. Use native structuredClone when available (handles typed arrays, dates, etc.).\r\n *  2. Fallback to JSON serialize/deserialize (sufficient for plain data objects).\r\n *  3. If serialization fails (rare circular or unsupported types), a second JSON attempt is made\r\n *     inside the catch to avoid throwing and to preserve backwards compatibility (will still throw\r\n *     if fundamentally non-serializable).\r\n *\r\n * NOTE: This is intentionally minimal; for richer cloning semantics consider a dedicated utility.\r\n */\r\nfunction deepCloneValue<T>(value: T): T {\r\n  try {\r\n    return (globalThis as any).structuredClone\r\n      ? (globalThis as any).structuredClone(value)\r\n      : JSON.parse(JSON.stringify(value));\r\n  } catch {\r\n    // Fallback: attempt JSON path again; if it fails this will throw\u2014acceptable for edge cases.\r\n    return JSON.parse(JSON.stringify(value));\r\n  }\r\n}\r\n\r\n/**\r\n * Obtain the last recorded regularization / stochastic statistics snapshot.\r\n *\r\n * Returns a defensive deep copy so callers can inspect metrics without risking mutation of the\r\n * internal `_lastStats` object maintained by the training loop (e.g., during pruning, dropout, or\r\n * noise scheduling updates).\r\n *\r\n * @returns A deep-cloned stats object or null if no stats have been recorded yet.\r\n */\r\nexport function getRegularizationStats(this: Network) {\r\n  /** Raw internal stats reference (may be undefined if never set). */\r\n  const lastStatsSnapshot = (this as any)._lastStats;\r\n  return lastStatsSnapshot ? deepCloneValue(lastStatsSnapshot) : null;\r\n}\r\n\r\nexport default { getRegularizationStats };\r\n", "import type Network from '../network';\r\nimport type Node from '../node';\r\n\r\n/**\r\n * Node removal utilities.\r\n *\r\n * This module provides a focused implementation for removing a single hidden node from a network\r\n * while attempting to preserve overall functional connectivity. The removal procedure mirrors the\r\n * legacy Neataptic logic but augments it with clearer documentation and explicit invariants.\r\n *\r\n * High\u2011level algorithm (removeNode):\r\n *  1. Guard: ensure the node exists and is not an input or output (those are structural anchors).\r\n *  2. Ungate: detach any connections gated BY the node (we don't currently reassign gater roles).\r\n *  3. Snapshot inbound / outbound connections (before mutation of adjacency lists).\r\n *  4. Disconnect all inbound, outbound, and self connections.\r\n *  5. Physically remove the node from the network's node array.\r\n *  6. Simple path repair heuristic: for every former inbound source and outbound target, add a\r\n *     direct connection if (a) both endpoints still exist, (b) they are distinct, and (c) no\r\n *     direct connection already exists. This keeps forward information flow possibilities.\r\n *  7. Mark topology / caches dirty so that subsequent activation / ordering passes rebuild state.\r\n *\r\n * Notes / Limitations:\r\n *  - We do NOT attempt to clone weights or distribute the removed node's function across new\r\n *    connections (more sophisticated strategies could average or compose weights).\r\n *  - Gating effects involving the removed node as a gater are dropped; downstream behavior may\r\n *    change\u2014callers relying heavily on gating may want a custom remap strategy.\r\n *  - Self connections are simply removed; no attempt is made to emulate recursion via alternative\r\n *    structures.\r\n */\r\n\r\n/**\r\n * Remove a hidden node from the network while minimally repairing connectivity.\r\n *\r\n * @param this Network instance (bound implicitly via method-style call).\r\n * @param node The node object to remove (must be of type 'hidden').\r\n * @throws If the node is not present or is an input / output node.\r\n *\r\n * Side Effects:\r\n *  - Mutates network.nodes, network.connections (via disconnect/connect calls), and network.gates.\r\n *  - Marks internal dirty flags so that future activation / ordering passes recompute derived state.\r\n */\r\nexport function removeNode(this: Network, node: Node) {\r\n  /** Cast to any to access internal dirty flags without changing public typing. */\r\n  const internalNet = this as any;\r\n  /** Index of the node in the network's node array (or -1 if not found). */\r\n  const idx = this.nodes.indexOf(node);\r\n  if (idx === -1) throw new Error('Node not in network');\r\n  // Structural guard: inputs/outputs are fixed anchors and cannot be removed.\r\n  if (node.type === 'input' || node.type === 'output') {\r\n    throw new Error('Cannot remove input or output node from the network.');\r\n  }\r\n\r\n  // 1. Ungate any connections gated BY this node (drop gating influence).\r\n  this.gates = this.gates.filter((c: any) => {\r\n    if (c.gater === node) {\r\n      (c as any).gater = null; // explicit null so legacy checks see it as ungated\r\n      return false; // remove from gates list\r\n    }\r\n    return true;\r\n  });\r\n\r\n  /** Snapshot of inbound connections prior to mutation for reconnection heuristic. */\r\n  const inbound = node.connections.in.slice();\r\n  /** Snapshot of outbound connections prior to mutation for reconnection heuristic. */\r\n  const outbound = node.connections.out.slice();\r\n\r\n  // 2. Disconnect all inbound connections.\r\n  inbound.forEach((c: any) => this.disconnect(c.from, c.to));\r\n  // 3. Disconnect all outbound connections.\r\n  outbound.forEach((c: any) => this.disconnect(c.from, c.to));\r\n  // 4. Disconnect self connections (if any recurrent self-loop).\r\n  node.connections.self.slice().forEach(() => this.disconnect(node, node));\r\n\r\n  // 5. Physically remove the node from the node list.\r\n  this.nodes.splice(idx, 1);\r\n\r\n  // 6. Reconnect every former inbound source to every former outbound target if a direct edge is missing.\r\n  inbound.forEach((ic: any) => {\r\n    outbound.forEach((oc: any) => {\r\n      if (!ic.from || !oc.to || ic.from === oc.to) return; // skip invalid or trivial (self) cases\r\n      /** True when a direct connection between source and target already exists. */\r\n      const exists = this.connections.some(\r\n        (c) => c.from === ic.from && c.to === oc.to\r\n      );\r\n      if (!exists) this.connect(ic.from, oc.to);\r\n    });\r\n  });\r\n\r\n  // 7. Mark derived structure caches dirty so they will be recomputed lazily.\r\n  internalNet._topoDirty = true;\r\n  internalNet._nodeIndexDirty = true;\r\n  internalNet._slabDirty = true;\r\n  internalNet._adjDirty = true;\r\n}\r\n\r\nexport default { removeNode };\r\n", "import type Network from '../network';\r\nimport Node from '../node';\r\nimport Connection from '../connection';\r\n\r\n/**\r\n * Network structural mutation helpers (connect / disconnect).\r\n *\r\n * This module centralizes the logic for adding and removing edges (connections) between\r\n * nodes in a {@link Network}. By isolating the book\u2011keeping here we keep the primary\r\n * Network class lean and ensure consistent handling of:\r\n *  - Acyclic constraints\r\n *  - Multiple low\u2011level connections returned by composite node operations\r\n *  - Gating & self\u2011connection invariants\r\n *  - Cache invalidation (topological order + packed activation slabs)\r\n *\r\n * Exported functions:\r\n *  - {@link connect}: Create one or more connections from a source node to a target node.\r\n *  - {@link disconnect}: Remove (at most) one direct connection from source to target.\r\n *\r\n * Key terminology:\r\n *  - Self\u2011connection: An edge where from === to (loop). Usually disallowed under acyclicity.\r\n *  - Gating: A mechanism where a third node modulates (gates) the weight / influence of a connection.\r\n *  - Slab: Packed typed\u2011array representation of connections for vectorized forward passes.\r\n *\r\n * @module network.connect\r\n */\r\n\r\n/**\r\n * Create and register one (or multiple) directed connection objects between two nodes.\r\n *\r\n * Some node types (or future composite structures) may return several low\u2011level connections when\r\n * their {@link Node.connect} is invoked (e.g., expanded recurrent templates). For that reason this\r\n * function always treats the result as an array and appends each edge to the appropriate collection.\r\n *\r\n * Algorithm outline:\r\n *  1. (Acyclic guard) If acyclicity is enforced and the source node appears after the target node in\r\n *     the network's node ordering, abort early and return an empty array (prevents back\u2011edge creation).\r\n *  2. Delegate to sourceNode.connect(targetNode, weight) to build the raw Connection object(s).\r\n *  3. For each created connection:\r\n *       a. If it's a self\u2011connection: either ignore (acyclic mode) or store in selfconns.\r\n *       b. Otherwise store in standard connections array.\r\n *  4. If any connection was added, mark structural caches dirty (_topoDirty & _slabDirty) so lazy\r\n *     rebuild can occur before the next forward pass.\r\n *\r\n * Complexity:\r\n *  - Time: O(k) where k is the number of low\u2011level connections returned (typically 1).\r\n *  - Space: O(k) new Connection instances (delegated to Node.connect).\r\n *\r\n * Edge cases & invariants:\r\n *  - Acyclic mode silently refuses back\u2011edges instead of throwing (makes evolutionary search easier).\r\n *  - Self\u2011connections are skipped entirely when acyclicity is enforced.\r\n *  - Weight initialization policy is delegated to Node.connect if not explicitly provided.\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @param from - Source node (emits signal).\r\n * @param to - Target node (receives signal).\r\n * @param weight - Optional explicit initial weight value.\r\n * @returns Array of created {@link Connection} objects (possibly empty if acyclicity rejected the edge).\r\n * @example\r\n * const [edge] = net.connect(nodeA, nodeB, 0.5);\r\n * @remarks For bulk layer-to-layer wiring see higher-level utilities that iterate groups.\r\n */\r\nexport function connect(\r\n  this: Network,\r\n  from: Node,\r\n  to: Node,\r\n  weight?: number\r\n): Connection[] {\r\n  // Step 1: Acyclic pre\u2011check \u2013 prevents cycles by disallowing edges that point \"backwards\" in order.\r\n  if (\r\n    (this as any)._enforceAcyclic &&\r\n    this.nodes.indexOf(from) > this.nodes.indexOf(to)\r\n  )\r\n    return [];\r\n\r\n  // Step 2: Delegate creation to the node. May return >1 low\u2011level connections (treat generically).\r\n  /** Array of new connection objects produced by the source node. */\r\n  const connections = from.connect(to, weight);\r\n\r\n  // Step 3: Register each new connection in the appropriate collection.\r\n  for (const c of connections) {\r\n    // c: individual low\u2011level connection\r\n    if (from !== to) {\r\n      // Standard edge (feed\u2011forward or recurrent) tracked in 'connections'.\r\n      this.connections.push(c);\r\n    } else {\r\n      // Self\u2011connection: only valid when acyclicity is not enforced.\r\n      if ((this as any)._enforceAcyclic) continue; // Skip silently to preserve invariant.\r\n      this.selfconns.push(c);\r\n    }\r\n  }\r\n\r\n  // Step 4: Invalidate caches if we materially changed structure (at least one edge added).\r\n  if (connections.length) {\r\n    (this as any)._topoDirty = true; // Topological ordering must be recomputed lazily.\r\n    (this as any)._slabDirty = true; // Packed connection slab requires rebuild for fast activation path.\r\n  }\r\n\r\n  return connections; // Return created edges so caller can inspect / further manipulate (e.g., gating).\r\n}\r\n\r\n/**\r\n * Remove (at most) one directed connection from source 'from' to target 'to'.\r\n *\r\n * Only a single direct edge is removed because typical graph configurations maintain at most\r\n * one logical connection between a given pair of nodes (excluding potential future multi\u2011edge\r\n * semantics). If the target edge is gated we first call {@link Network.ungate} to maintain\r\n * gating invariants (ensuring the gater node's internal gate list remains consistent).\r\n *\r\n * Algorithm outline:\r\n *  1. Choose the correct list (selfconns vs connections) based on whether from === to.\r\n *  2. Linear scan to find the first edge with matching endpoints.\r\n *  3. If gated, ungate to detach gater bookkeeping.\r\n *  4. Splice the edge out; exit loop (only one expected).\r\n *  5. Delegate per\u2011node cleanup via from.disconnect(to) (clears reverse references, traces, etc.).\r\n *  6. Mark structural caches dirty for lazy recomputation.\r\n *\r\n * Complexity:\r\n *  - Time: O(m) where m is length of the searched list (connections or selfconns).\r\n *  - Space: O(1) extra.\r\n *\r\n * Idempotence: If no such edge exists we still perform node-level disconnect and flag caches dirty \u2013\r\n * this conservative approach simplifies callers (they need not pre\u2011check existence).\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @param from - Source node.\r\n * @param to - Target node.\r\n * @example\r\n * net.disconnect(nodeA, nodeB);\r\n * @remarks For removing many edges consider higher\u2011level bulk utilities to avoid repeated scans.\r\n */\r\nexport function disconnect(this: Network, from: Node, to: Node): void {\r\n  // Step 1: Select list to search: selfconns for loops, otherwise normal connections.\r\n  /** Candidate list of connections to inspect for removal. */\r\n  const list = from === to ? this.selfconns : this.connections;\r\n\r\n  // Step 2: Linear scan \u2013 lists are typically small relative to node count; acceptable trade\u2011off.\r\n  for (let i = 0; i < list.length; i++) {\r\n    /** Connection currently inspected. */\r\n    const c = list[i];\r\n    if (c.from === from && c.to === to) {\r\n      // Found target edge\r\n      // Step 3: If gated, maintain gating invariants by ungating before removal.\r\n      if (c.gater) this.ungate(c);\r\n      // Step 4: Remove and exit (only one expected between a pair of nodes).\r\n      list.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Step 5: Node-level cleanup (clears internal references, derivative / eligibility traces, etc.).\r\n  from.disconnect(to);\r\n\r\n  // Step 6: Structural mutation => mark caches dirty so next activation can rebuild fast-path artifacts.\r\n  (this as any)._topoDirty = true;\r\n  (this as any)._slabDirty = true;\r\n}\r\n", "import type Network from '../network';\r\nimport Node from '../node';\r\nimport Connection from '../connection';\r\nimport * as methods from '../../methods/methods';\r\n\r\n/**\r\n * Serialization & deserialization helpers for Network instances.\r\n *\r\n * Provides two independent formats:\r\n *  1. Compact tuple (serialize/deserialize): optimized for fast structured clone / worker transfer.\r\n *  2. Verbose JSON (toJSONImpl/fromJSONImpl): stable, versioned representation retaining structural genes.\r\n *\r\n * Compact tuple format layout:\r\n *  [ activations: number[], states: number[], squashes: string[],\r\n *    connections: { from:number; to:number; weight:number; gater:number|null }[],\r\n *    inputSize: number, outputSize: number ]\r\n *\r\n * Design Principles:\r\n *  - Avoid deep nested objects to reduce serialization overhead.\r\n *  - Use current node ordering as canonical index mapping (caller must keep ordering stable between peers).\r\n *  - Include current activation/state for scenarios resuming partially evaluated populations.\r\n *  - Self connections placed in the same array as normal connections for uniform reconstruction.\r\n *\r\n * Verbose JSON (formatVersion = 2) adds:\r\n *  - Enabled flag for connections (innovation toggling).\r\n *  - Stable geneId (if tracked) on nodes.\r\n *  - Dropout probability.\r\n *\r\n * Future Ideas:\r\n *  - Delta / patch serialization for large evolving populations.\r\n *  - Compressed binary packing (e.g., Float32Array segments) for WASM pipelines.\r\n */\r\n\r\n/**\r\n * Instance-level lightweight serializer used primarily for fast inter-thread (WebWorker) transfer.\r\n * Produces a compact tuple style array instead of a verbose object graph.\r\n *\r\n * Layout:\r\n *  [ activations: number[], states: number[], squashes: string[],\r\n *    connections: { from:number; to:number; weight:number; gater:number|null }[],\r\n *    inputSize: number, outputSize: number ]\r\n *\r\n * Design notes:\r\n *  - Only minimal dynamic runtime values are captured (activation/state and current squash fn name).\r\n *  - Self connections are appended alongside normal connections (caller rehydrates uniformly).\r\n *  - Indices are derived from current node ordering; caller must ensure consistent ordering across workers.\r\n */\r\nexport function serialize(this: Network): any[] {\r\n  // Ensure indices are refreshed (fast paths may leave stale indices for performance; we enforce consistency here).\r\n  (this as any).nodes.forEach(\r\n    (nodeRef: any, nodeIndex: number) => (nodeRef.index = nodeIndex)\r\n  );\r\n  // At this point each node.index becomes our canonical ID used throughout the serialization.\r\n  // Indices are intentionally positional so the resulting arrays remain tightly packed and cache\u2011friendly.\r\n  /** Current activation values per node (index-aligned). */\r\n  const activations = (this as any).nodes.map(\r\n    (nodeRef: any) => nodeRef.activation\r\n  );\r\n  // activations[] captures the post-squash output of each neuron; when deserialized we can resume\r\n  // a simulation mid-stream (e.g. during evolutionary evaluation) if desired.\r\n  /** Current membrane/accumulator state per node. */\r\n  const states = (this as any).nodes.map((nodeRef: any) => nodeRef.state);\r\n  // states[] represent the pre-activation internal sum (or evolving state for recurrent / gated constructs).\r\n  /** Squash (activation function) names per node for later rehydration. */\r\n  const squashes = (this as any).nodes.map(\r\n    (nodeRef: any) => nodeRef.squash.name\r\n  );\r\n  // Instead of serializing function references we store the human-readable name; on import we map name->fn.\r\n  /** Combined forward + self connections flattened to plain indices + weights. */\r\n  const serializedConnections = (this as any).connections\r\n    .concat((this as any).selfconns)\r\n    .map((connInstance: any) => ({\r\n      from: connInstance.from.index,\r\n      to: connInstance.to.index,\r\n      weight: connInstance.weight,\r\n      gater: connInstance.gater ? connInstance.gater.index : null,\r\n    }));\r\n  // A single linear pass is used; order of connections is not semantically important because reconstruction\r\n  // will look up by (from,to) pairs. Self connections are treated uniformly (from === to) for simplicity.\r\n  /** Input layer size captured for reconstruction. */\r\n  const inputSize = (this as any).input;\r\n  /** Output layer size captured for reconstruction. */\r\n  const outputSize = (this as any).output;\r\n  // We intentionally return a plain Array rather than an object literal to minimize JSON overhead and\r\n  // reduce property name duplication during stringify/structuredClone operations.\r\n  return [\r\n    activations,\r\n    states,\r\n    squashes,\r\n    serializedConnections,\r\n    inputSize,\r\n    outputSize,\r\n  ];\r\n}\r\n\r\n/**\r\n * Static counterpart to {@link serialize}. Rebuilds a Network from the compact tuple form.\r\n * Accepts optional explicit input/output size overrides (useful when piping through evolvers that trim IO).\r\n */\r\nexport function deserialize(\r\n  data: any[],\r\n  inputSize?: number,\r\n  outputSize?: number\r\n): Network {\r\n  /** Destructured compact tuple payload produced by serialize(). */\r\n  const [\r\n    activations,\r\n    states,\r\n    squashes,\r\n    connections,\r\n    serializedInput,\r\n    serializedOutput,\r\n  ] = data;\r\n  /** Effective input size (override takes precedence). */\r\n  const input =\r\n    typeof inputSize === 'number' ? inputSize : serializedInput || 0;\r\n  /** Effective output size (override takes precedence). */\r\n  const output =\r\n    typeof outputSize === 'number' ? outputSize : serializedOutput || 0;\r\n  /** Newly constructed network shell with IO sizes. */\r\n  const net = new (require('../network').default)(input, output) as Network; // dynamic require to avoid circular dependency timing\r\n  (net as any).nodes = [];\r\n  (net as any).connections = [];\r\n  (net as any).selfconns = [];\r\n  (net as any).gates = [];\r\n  // Phase 1: Recreate nodes in positional order. We intentionally rebuild even input/output nodes so that\r\n  // any evolution-time modifications (bias, activation) are preserved.\r\n  activations.forEach((activation: number, nodeIndex: number) => {\r\n    /** Node type derived from index relative to IO spans. */\r\n    let type: string;\r\n    if (nodeIndex < input) type = 'input';\r\n    else if (nodeIndex >= (activations as any).length - output) type = 'output';\r\n    else type = 'hidden';\r\n    /** Rehydrated node instance. */\r\n    const node: any = new Node(type);\r\n    node.activation = activation;\r\n    node.state = states[nodeIndex];\r\n    /** Activation function name captured during serialization. */\r\n    const squashName = squashes[nodeIndex] as keyof typeof methods.Activation;\r\n    if (!(methods.Activation as any)[squashName]) {\r\n      console.warn(\r\n        `Unknown squash function '${String(\r\n          squashName\r\n        )}' encountered during deserialize. Falling back to identity.`\r\n      );\r\n    }\r\n    node.squash =\r\n      (methods.Activation as any)[squashName] || methods.Activation.identity;\r\n    node.index = nodeIndex;\r\n    (net as any).nodes.push(node);\r\n  });\r\n  // Phase 2: Recreate connections. We iterate the flat connection list and re-establish edges using indices.\r\n  // Self connections are seamlessly handled when from === to. Gating is re-applied after connection creation.\r\n  connections.forEach((serializedConn: any) => {\r\n    if (\r\n      serializedConn.from < (net as any).nodes.length &&\r\n      serializedConn.to < (net as any).nodes.length\r\n    ) {\r\n      /** Source node for reconstructed connection. */\r\n      const sourceNode = (net as any).nodes[serializedConn.from];\r\n      /** Target node for reconstructed connection. */\r\n      const targetNode = (net as any).nodes[serializedConn.to];\r\n      /** Newly created connection (array return from connect). */\r\n      const createdConnection = (net as any).connect(\r\n        sourceNode,\r\n        targetNode,\r\n        serializedConn.weight\r\n      )[0];\r\n      if (createdConnection && serializedConn.gater != null) {\r\n        if (serializedConn.gater < (net as any).nodes.length) {\r\n          // Only gate if the gater index is valid\u2014defensive against older or pruned models.\r\n          (net as any).gate(\r\n            (net as any).nodes[serializedConn.gater],\r\n            createdConnection\r\n          );\r\n        } else {\r\n          console.warn(\r\n            'Invalid gater index encountered during deserialize; skipping gater assignment.'\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      console.warn(\r\n        'Invalid connection indices encountered during deserialize; skipping connection.'\r\n      );\r\n    }\r\n  });\r\n  // Note: We intentionally do NOT rebuild any cached topological ordering here; callers invoking activation\r\n  // or mutation operations will trigger those lazy recomputations.\r\n  return net;\r\n}\r\n\r\n/**\r\n * Verbose JSON export (stable formatVersion). Omits transient runtime fields but keeps structural genetics.\r\n * formatVersion=2 adds: enabled flags, stable geneId (if present), dropout value.\r\n */\r\nexport function toJSONImpl(this: Network): object {\r\n  /** Accumulated verbose JSON representation (formatVersion = 2). */\r\n  const json: any = {\r\n    formatVersion: 2,\r\n    input: (this as any).input,\r\n    output: (this as any).output,\r\n    dropout: (this as any).dropout,\r\n    nodes: [],\r\n    connections: [],\r\n  };\r\n  // Node pass: capture minimal structural genetics (bias, activation, geneId) but exclude transient runtime state.\r\n  (this as any).nodes.forEach((node: any, nodeIndex: number) => {\r\n    node.index = nodeIndex; // refresh index for safety\r\n    json.nodes.push({\r\n      type: node.type,\r\n      bias: node.bias,\r\n      squash: node.squash.name,\r\n      index: nodeIndex,\r\n      geneId: (node as any).geneId,\r\n    });\r\n    if (node.connections.self.length > 0) {\r\n      /** Self connection reference (at most one). */\r\n      const selfConn = node.connections.self[0];\r\n      json.connections.push({\r\n        from: nodeIndex,\r\n        to: nodeIndex,\r\n        weight: selfConn.weight,\r\n        gater: selfConn.gater ? selfConn.gater.index : null,\r\n        enabled: (selfConn as any).enabled !== false,\r\n      });\r\n    }\r\n  });\r\n  // Connection pass: append forward connections preserving enabled state & gating relationships.\r\n  (this as any).connections.forEach((connInstance: any) => {\r\n    if (\r\n      typeof connInstance.from.index !== 'number' ||\r\n      typeof connInstance.to.index !== 'number'\r\n    )\r\n      return;\r\n    json.connections.push({\r\n      from: connInstance.from.index,\r\n      to: connInstance.to.index,\r\n      weight: connInstance.weight,\r\n      gater: connInstance.gater ? connInstance.gater.index : null,\r\n      enabled: (connInstance as any).enabled !== false,\r\n    });\r\n  });\r\n  // The resulting JSON is stable: ordering of nodes is deterministic, and connections list order derives from existing array ordering.\r\n  return json;\r\n}\r\n\r\n/**\r\n * Reconstruct a Network from the verbose JSON produced by {@link toJSONImpl} (formatVersion 2).\r\n * Defensive parsing retains forward compatibility (warns on unknown versions rather than aborting).\r\n */\r\nexport function fromJSONImpl(json: any): Network {\r\n  if (!json || typeof json !== 'object')\r\n    throw new Error('Invalid JSON for network.');\r\n  if (json.formatVersion !== 2)\r\n    console.warn('fromJSONImpl: Unknown formatVersion, attempting import.');\r\n  /** New network shell with recorded IO sizes. */\r\n  const net = new (require('../network').default)(\r\n    json.input,\r\n    json.output\r\n  ) as Network;\r\n  (net as any).dropout = json.dropout || 0;\r\n  (net as any).nodes = [];\r\n  (net as any).connections = [];\r\n  (net as any).selfconns = [];\r\n  (net as any).gates = [];\r\n  // Rebuild nodes first so that index-based connection references become valid.\r\n  json.nodes.forEach((nodeJson: any, nodeIndex: number) => {\r\n    /** Rehydrated node from JSON. */\r\n    const node: any = new Node(nodeJson.type);\r\n    node.bias = nodeJson.bias;\r\n    node.squash =\r\n      (methods.Activation as any)[nodeJson.squash] ||\r\n      methods.Activation.identity;\r\n    node.index = nodeIndex;\r\n    if (typeof nodeJson.geneId === 'number')\r\n      (node as any).geneId = nodeJson.geneId;\r\n    (net as any).nodes.push(node);\r\n  });\r\n  // Then recreate connections, applying gating and enabled status (innovation tracking) if present.\r\n  json.connections.forEach((connJson: any) => {\r\n    if (typeof connJson.from !== 'number' || typeof connJson.to !== 'number')\r\n      return;\r\n    /** Source node for connection gene. */\r\n    const sourceNode = (net as any).nodes[connJson.from];\r\n    /** Destination node for connection gene. */\r\n    const targetNode = (net as any).nodes[connJson.to];\r\n    /** Newly established connection instance. */\r\n    const createdConnection = (net as any).connect(\r\n      sourceNode,\r\n      targetNode,\r\n      connJson.weight\r\n    )[0];\r\n    if (\r\n      createdConnection &&\r\n      connJson.gater != null &&\r\n      typeof connJson.gater === 'number' &&\r\n      (net as any).nodes[connJson.gater]\r\n    ) {\r\n      (net as any).gate((net as any).nodes[connJson.gater], createdConnection);\r\n    }\r\n    if (createdConnection && typeof connJson.enabled !== 'undefined')\r\n      (createdConnection as any).enabled = connJson.enabled;\r\n  });\r\n  // As with deserialize(), we defer recalculating any cached orderings until first operational use.\r\n  return net;\r\n}\r\n\r\nexport { Connection }; // re-export for potential external tooling needing innovation IDs\r\n", "import type Network from '../network';\r\nimport Node from '../node';\r\nimport Connection from '../connection';\r\n\r\n/**\r\n * Genetic operator: NEAT\u2011style crossover (legacy merge operator removed).\r\n *\r\n * This module now focuses solely on producing recombinant offspring via {@link crossOver}.\r\n * The previous experimental Network.merge has been removed to reduce maintenance surface area\r\n * and avoid implying a misleading \u201Csequential composition\u201D guarantee.\r\n *\r\n * @module network.genetic\r\n */\r\n\r\n/**\r\n * NEAT-inspired crossover between two parent networks producing a single offspring.\r\n *\r\n * Simplifications relative to canonical NEAT:\r\n *  - Innovation ID is synthesized from (from.index, to.index) via Connection.innovationID instead of\r\n *    maintaining a global innovation number per mutation event.\r\n *  - Node alignment relies on current index ordering. This is weaker than historical innovation\r\n *    tracking, but adequate for many lightweight evolutionary experiments.\r\n *\r\n * High-level algorithm:\r\n *  1. Validate that parents have identical I/O dimensionality (required for compatibility).\r\n *  2. Decide offspring node array length:\r\n *       - If equal flag set or scores tied: random length in [minNodes, maxNodes].\r\n *       - Else: length of fitter parent.\r\n *  3. For each index up to chosen size, pick a node gene from parents per rules:\r\n *       - Input indices: always from parent1 (assumes identical input interface).\r\n *       - Output indices (aligned from end): randomly choose if both present else take existing.\r\n *       - Hidden indices: if both present pick randomly; else inherit from fitter (or either if equal).\r\n *  4. Reindex offspring nodes.\r\n *  5. Collect connections (standard + self) from each parent into maps keyed by innovationID capturing\r\n *     weight, enabled flag, and gater index.\r\n *  6. For overlapping genes (present in both), randomly choose one; if either disabled apply optional\r\n *     re-enable probability (reenableProb) to possibly re-activate.\r\n *  7. For disjoint/excess genes, inherit only from fitter parent (or both if equal flag set / scores tied).\r\n *  8. Materialize selected connection genes if their endpoints both exist in offspring; set weight & enabled state.\r\n *  9. Reattach gating if gater node exists in offspring.\r\n *\r\n * Enabled reactivation probability:\r\n *  - Parents may carry disabled connections; offspring may re-enable them with a probability derived\r\n *    from parent-specific _reenableProb (or default 0.25). This allows dormant structures to resurface.\r\n *\r\n * @param network1 - First parent (ties resolved in its favor when scores equal and equal=false for some cases).\r\n * @param network2 - Second parent.\r\n * @param equal - Force symmetric treatment regardless of fitness (true => node count random between sizes and both parents equally contribute disjoint genes).\r\n * @returns Offspring network instance.\r\n * @throws If input/output sizes differ.\r\n */\r\nexport function crossOver(\r\n  network1: Network,\r\n  network2: Network,\r\n  equal = false\r\n): Network {\r\n  if (network1.input !== network2.input || network1.output !== network2.output)\r\n    throw new Error(\r\n      'Parent networks must have the same input and output sizes for crossover.'\r\n    );\r\n  /** Offspring scaffold produced by recombination of parent networks. */\r\n  const offspring = new (require('../network').default)(\r\n    network1.input,\r\n    network1.output\r\n  ) as Network;\r\n  /** Mutable list of standard (non self) connections assigned during reconstruction. */\r\n  (offspring as any).connections = [];\r\n  /** Ordered list of cloned node genes composing the offspring topology. */\r\n  (offspring as any).nodes = [];\r\n  /** Self\u2013connections (loops) for offspring, rebuilt during connection materialization. */\r\n  (offspring as any).selfconns = [];\r\n  /** Collection of gated connections after inheritance. */\r\n  (offspring as any).gates = [];\r\n  /** Fitness (score) of parent 1 used for dominance decisions. */\r\n  const score1 = (network1 as any).score || 0;\r\n  /** Fitness (score) of parent 2 used for dominance decisions. */\r\n  const score2 = (network2 as any).score || 0;\r\n  /** Number of nodes in parent 1 (used to bound index-based selection). */\r\n  const n1Size = (network1 as any).nodes.length;\r\n  /** Number of nodes in parent 2 (used to bound index-based selection). */\r\n  const n2Size = (network2 as any).nodes.length;\r\n  // Decide offspring size based on equality / fitness.\r\n  /** Final number of node slots (including I/O) the offspring will contain. */\r\n  let size: number;\r\n  if (equal || score1 === score2) {\r\n    /** Upper bound on possible offspring node count when parents tied / equal mode. */\r\n    const max = Math.max(n1Size, n2Size);\r\n    /** Lower bound on possible offspring node count when parents tied / equal mode. */\r\n    const min = Math.min(n1Size, n2Size);\r\n    /** Random length chosen uniformly in [min, max]. */\r\n    size = Math.floor(Math.random() * (max - min + 1) + min);\r\n  } else size = score1 > score2 ? n1Size : n2Size;\r\n  /** Number of output nodes (shared by both parents). */\r\n  const outputSize = network1.output;\r\n  // Assign indices for deterministic innovation mapping later.\r\n  (network1 as any).nodes.forEach((n: any, i: number) => (n.index = i));\r\n  (network2 as any).nodes.forEach((n: any, i: number) => (n.index = i));\r\n  // Node gene selection loop.\r\n  for (let i = 0; i < size; i++) {\r\n    /** Chosen parent node gene for this index (if any). */\r\n    let chosen: any;\r\n    /** Parent 1 node gene at current index (undefined if beyond parent size). */\r\n    const node1 = i < n1Size ? (network1 as any).nodes[i] : undefined;\r\n    /** Parent 2 node gene at current index (undefined if beyond parent size). */\r\n    const node2 = i < n2Size ? (network2 as any).nodes[i] : undefined;\r\n    if (i < network1.input) chosen = node1;\r\n    // Always preserve consistent input interface.\r\n    else if (i >= size - outputSize) {\r\n      // Output region aligned from tail.\r\n      /** Index of candidate output node in parent 1 derived from tail alignment. */\r\n      const o1 = n1Size - (size - i);\r\n      /** Index of candidate output node in parent 2 derived from tail alignment. */\r\n      const o2 = n2Size - (size - i);\r\n      /** Parent 1 output node at aligned slot (if valid). */\r\n      const n1o =\r\n        o1 >= network1.input && o1 < n1Size\r\n          ? (network1 as any).nodes[o1]\r\n          : undefined;\r\n      /** Parent 2 output node at aligned slot (if valid). */\r\n      const n2o =\r\n        o2 >= network2.input && o2 < n2Size\r\n          ? (network2 as any).nodes[o2]\r\n          : undefined;\r\n      if (n1o && n2o)\r\n        chosen = ((network1 as any)._rand || Math.random)() >= 0.5 ? n1o : n2o;\r\n      else chosen = n1o || n2o;\r\n    } else {\r\n      // Hidden region.\r\n      if (node1 && node2)\r\n        chosen =\r\n          ((network1 as any)._rand || Math.random)() >= 0.5 ? node1 : node2;\r\n      else if (node1 && (score1 >= score2 || equal)) chosen = node1;\r\n      else if (node2 && (score2 >= score1 || equal)) chosen = node2;\r\n    }\r\n    if (chosen) {\r\n      // Clone structural gene (bias + activation function / squash) but do not copy connections yet.\r\n      const nn: any = new Node(chosen.type);\r\n      nn.bias = chosen.bias;\r\n      nn.squash = chosen.squash;\r\n      (offspring as any).nodes.push(nn);\r\n    }\r\n  }\r\n  // Reassign indices after constructing node list.\r\n  (offspring as any).nodes.forEach((n: any, i: number) => (n.index = i));\r\n  // Gather connection genes from both parents (including self connections) keyed by innovation id.\r\n  /** Map from innovation ID -> connection gene extracted from parent 1 (includes self connections). */\r\n  const n1conns: Record<string, any> = {};\r\n  /** Map from innovation ID -> connection gene extracted from parent 2 (includes self connections). */\r\n  const n2conns: Record<string, any> = {};\r\n  (network1 as any).connections\r\n    .concat((network1 as any).selfconns)\r\n    .forEach((c: any) => {\r\n      if (typeof c.from.index === 'number' && typeof c.to.index === 'number')\r\n        n1conns[Connection.innovationID(c.from.index, c.to.index)] = {\r\n          weight: c.weight,\r\n          from: c.from.index,\r\n          to: c.to.index,\r\n          gater: c.gater ? c.gater.index : -1,\r\n          enabled: (c as any).enabled !== false,\r\n        };\r\n    });\r\n  (network2 as any).connections\r\n    .concat((network2 as any).selfconns)\r\n    .forEach((c: any) => {\r\n      if (typeof c.from.index === 'number' && typeof c.to.index === 'number')\r\n        n2conns[Connection.innovationID(c.from.index, c.to.index)] = {\r\n          weight: c.weight,\r\n          from: c.from.index,\r\n          to: c.to.index,\r\n          gater: c.gater ? c.gater.index : -1,\r\n          enabled: (c as any).enabled !== false,\r\n        };\r\n    });\r\n  // Select connection genes: iterate parent1's map, handle overlaps, then optionally add remaining parent2 genes.\r\n  /** Accumulated list of chosen connection gene descriptors to materialize in offspring. */\r\n  const chosenConns: any[] = [];\r\n  /** Array of innovation IDs originating from parent 1 (iteration order). */\r\n  const keys1 = Object.keys(n1conns);\r\n  keys1.forEach((k) => {\r\n    /** Connection gene from parent 1 under current innovation ID. */\r\n    const c1 = n1conns[k];\r\n    if (n2conns[k]) {\r\n      // Matching gene.\r\n      /** Corresponding connection gene from parent 2 for matching innovation ID. */\r\n      const c2 = n2conns[k];\r\n      /** Selected gene (either c1 or c2) retained in offspring. */\r\n      const pick = ((network1 as any)._rand || Math.random)() >= 0.5 ? c1 : c2; // Randomly select weight / flags from one parent.\r\n      if (c1.enabled === false || c2.enabled === false) {\r\n        // If either disabled, chance to re-enable.\r\n        /** Probability threshold to re-enable a previously disabled matching connection. */\r\n        const rp =\r\n          (network1 as any)._reenableProb ??\r\n          (network2 as any)._reenableProb ??\r\n          0.25;\r\n        pick.enabled = Math.random() < rp;\r\n      }\r\n      chosenConns.push(pick);\r\n      delete n2conns[k]; // Remove from second map to mark consumed.\r\n    } else if (score1 >= score2 || equal) {\r\n      // Disjoint/excess gene from fitter or equal mode.\r\n      if (c1.enabled === false) {\r\n        /** Re-enable probability for a disabled disjoint/excess gene from parent1. */\r\n        const rp = (network1 as any)._reenableProb ?? 0.25;\r\n        c1.enabled = Math.random() < rp;\r\n      }\r\n      chosenConns.push(c1);\r\n    }\r\n  });\r\n  // Remaining genes from parent2 if it is fitter (or equal mode).\r\n  if (score2 >= score1 || equal)\r\n    Object.keys(n2conns).forEach((k) => {\r\n      const d = n2conns[k];\r\n      if (d.enabled === false) {\r\n        /** Re-enable probability for parent2 disjoint/excess gene. */ const rp =\r\n          (network2 as any)._reenableProb ?? 0.25;\r\n        d.enabled = Math.random() < rp;\r\n      }\r\n      chosenConns.push(d);\r\n    });\r\n  /** Number of nodes copied into offspring; used to validate endpoint indices of connection genes. */\r\n  const nodeCount = (offspring as any).nodes.length;\r\n  // Materialize connection genes in offspring network (skip if endpoint nodes not present due to size truncation).\r\n  chosenConns.forEach((cd) => {\r\n    if (cd.from < nodeCount && cd.to < nodeCount) {\r\n      const from = (offspring as any).nodes[cd.from];\r\n      const to = (offspring as any).nodes[cd.to];\r\n      // Always enforce feed-forward ordering for crossover offspring: skip any backward or self-loop\r\n      // edges (self loops handled elsewhere) to satisfy structural invariants expected by tests.\r\n      if (cd.from >= cd.to) return; // skip backward / non feed-forward edge\r\n      if (!from.isProjectingTo(to)) {\r\n        /** Newly constructed connection edge within offspring (first element of connect array). */ const conn = (offspring as any).connect(\r\n          from,\r\n          to\r\n        )[0];\r\n        if (conn) {\r\n          conn.weight = cd.weight;\r\n          (conn as any).enabled = cd.enabled !== false;\r\n          if (cd.gater !== -1 && cd.gater < nodeCount)\r\n            (offspring as any).gate((offspring as any).nodes[cd.gater], conn);\r\n        }\r\n      }\r\n    }\r\n  });\r\n  return offspring;\r\n}\r\n\r\nexport default { crossOver };\r\n", "import type Network from '../network';\r\nimport { activationArrayPool } from '../activationArrayPool';\r\n\r\n/**\r\n * Network activation helpers (forward pass utilities).\r\n *\r\n * This module provides progressively lower\u2013overhead entry points for performing\r\n * forward propagation through a {@link Network}. The emphasis is on:\r\n *  1. Educative clarity \u2013 each step is documented so newcomers can follow the\r\n *     life\u2011cycle of a forward pass in a neural network graph.\r\n *  2. Performance \u2013 fast paths avoid unnecessary allocation and bookkeeping when\r\n *     gradients / evolution traces are not needed.\r\n *  3. Safety \u2013 pooled buffers are never exposed directly to the public API.\r\n *\r\n * Exported functions:\r\n *  - {@link noTraceActivate}: ultra\u2011light inference (no gradients, minimal allocation).\r\n *  - {@link activateRaw}: thin semantic alias around the canonical Network.activate path.\r\n *  - {@link activateBatch}: simple mini\u2011batch loop utility.\r\n *\r\n * Design terminology used below:\r\n *  - Topological order: a sequence of nodes such that all directed connections flow forward.\r\n *  - Slab: a contiguous typed\u2011array structure packing node activations for vectorized math.\r\n *  - Trace / gradient bookkeeping: auxiliary data (e.g. eligibility traces, derivative caches)\r\n *    required for training algorithms; skipped in inference\u2011only modes.\r\n *  - Pool: an object managing reusable arrays to reduce garbage collection pressure.\r\n *\r\n * @module network.activate\r\n */\r\n\r\n/**\r\n * Perform a forward pass without creating or updating any training / gradient traces.\r\n *\r\n * This is the most allocation\u2011sensitive activation path. Internally it will attempt\r\n * to leverage a compact \"fast slab\" routine (an optimized, vectorized broadcast over\r\n * contiguous activation buffers) when the Network instance indicates that such a path\r\n * is currently valid. If that attempt fails (for instance because the slab is stale\r\n * after a structural mutation) execution gracefully falls back to a node\u2011by\u2011node loop.\r\n *\r\n * Algorithm outline:\r\n *  1. (Optional) Refresh cached topological order if the network enforces acyclicity\r\n *     and a structural change marked the order as dirty.\r\n *  2. Validate the input dimensionality.\r\n *  3. Try the fast slab path; if it throws, continue with the standard path.\r\n *  4. Acquire a pooled output buffer sized to the number of output neurons.\r\n *  5. Iterate all nodes in their internal order:\r\n *       - Input nodes: directly assign provided input values.\r\n *       - Hidden nodes: compute activation via Node.noTraceActivate (no bookkeeping).\r\n *       - Output nodes: compute activation and store it (in sequence) inside the\r\n *         pooled output buffer.\r\n *  6. Copy the pooled buffer into a fresh array (detaches user from the pool) and\r\n *     release the pooled buffer back to the pool.\r\n *\r\n * Complexity considerations:\r\n *  - Time: O(N + E) where N = number of nodes, E = number of inbound edges processed\r\n *    inside each Node.noTraceActivate call (not explicit here but inside the node).\r\n *  - Space: O(O) transient (O = number of outputs) due to the pooled output buffer.\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @param input - Flat numeric vector whose length must equal network.input.\r\n * @returns Array of output neuron activations (length == network.output).\r\n * @throws {Error} If the provided input vector length mismatches the network's input size.\r\n * @example\r\n * const out = net.noTraceActivate([0.1, 0.2, 0.3]);\r\n * console.log(out); // => e.g. [0.5123, 0.0441]\r\n * @remarks Safe for inference hot paths; not suitable when gradients / training traces are required.\r\n */\r\nexport function noTraceActivate(this: Network, input: number[]): number[] {\r\n  /**\r\n   * Reference to the network instance cast to any so internal/private helper properties\r\n   * (underscored fields & fast path flags) can be accessed without TypeScript complaints.\r\n   */\r\n  const self = this as any;\r\n\r\n  // Step 1: Ensure that if we require an acyclic graph, our cached topological\r\n  // ordering of nodes is current. A fresh order guarantees deterministic forward propagation.\r\n  if (self._enforceAcyclic && self._topoDirty)\r\n    (this as any)._computeTopoOrder();\r\n\r\n  // Step 2: Basic validation \u2013 mismatched length typically indicates a user error.\r\n  if (!Array.isArray(input) || input.length !== this.input) {\r\n    throw new Error(\r\n      `Input size mismatch: expected ${this.input}, got ${\r\n        input ? (input as any).length : 'undefined'\r\n      }`\r\n    );\r\n  }\r\n\r\n  // Step 3: Attempt a zero\u2011allocation vectorized activation over a packed slab. We wrap\r\n  // the call in a try/catch to avoid penalizing typical paths with conditional prechecks.\r\n  if ((this as any)._canUseFastSlab(false)) {\r\n    try {\r\n      return (this as any)._fastSlabActivate(input);\r\n    } catch {\r\n      // Silent fallback \u2013 correctness first; performance is opportunistic here.\r\n    }\r\n  }\r\n\r\n  // Step 4: Acquire a pooled typed array (or array\u2011like) sized to the number of outputs.\r\n  /** Pooled buffer to collect output activations in order. */\r\n  /**\r\n   * Pooled activation output buffer sized to the number of output neurons; will be cloned\r\n   * into a plain array before returning to the caller to avoid external mutation of pooled memory.\r\n   */\r\n  const output = activationArrayPool.acquire(this.output);\r\n\r\n  // Maintain a manual write index to decouple node iteration order from output layout.\r\n  /**\r\n   * Sequential index into the pooled output buffer. Increments each time we process\r\n   * an output node so we produce a dense, zero\u2011gap array matching logical output order.\r\n   */\r\n  /** Sequential write index into the pooled output buffer. */\r\n  let outIndex = 0;\r\n\r\n  // Step 5: Iterate every node once. For hidden nodes we simply invoke noTraceActivate;\r\n  // its internal logic will read predecessor activations already set during earlier steps.\r\n  this.nodes.forEach((node, index) => {\r\n    // Input nodes: feed value directly from the corresponding slot in the provided input vector.\r\n    if (node.type === 'input') node.noTraceActivate(input[index]);\r\n    // Output nodes: compute their activation (which implicitly uses upstream hidden/input nodes) and store.\r\n    else if (node.type === 'output')\r\n      (output as any)[outIndex++] = node.noTraceActivate();\r\n    // Hidden nodes: just activate (value stored internally on the node itself).\r\n    else node.noTraceActivate();\r\n  });\r\n\r\n  // Step 6: Copy pooled buffer to a fresh standard array so external callers cannot mutate\r\n  // the pooled object after it's released (which would create hard\u2011to\u2011trace bugs).\r\n  /** Detached plain array containing final output activations. */\r\n  /** Final detached output activation vector. */\r\n  const result = Array.from(output as any) as number[];\r\n\r\n  // Always release pooled resources promptly to keep memory pressure low for future calls.\r\n  activationArrayPool.release(output);\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Thin semantic alias to the network's main activation path.\r\n *\r\n * At present this simply forwards to {@link Network.activate}. The indirection is useful for:\r\n *  - Future differentiation between raw (immediate) activation and a mode that performs reuse /\r\n *    staged batching logic.\r\n *  - Providing a stable exported symbol for external tooling / instrumentation.\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @param input - Input vector (length == network.input).\r\n * @param training - Whether to retain training traces / gradients (delegated downstream).\r\n * @param maxActivationDepth - Guard against runaway recursion / cyclic activation attempts.\r\n * @returns Implementation-defined result of Network.activate (typically an output vector).\r\n * @example\r\n * const y = net.activateRaw([0,1,0]);\r\n * @remarks Keep this wrapper lightweight; heavy logic should live inside Network.activate itself.\r\n */\r\nexport function activateRaw(\r\n  this: Network,\r\n  input: number[],\r\n  training = false,\r\n  maxActivationDepth = 1000\r\n): any {\r\n  /** Access internal flags / helpers (private-ish) via a loose cast. */\r\n  const self = this as any;\r\n\r\n  // If the network is not reusing activation arrays there's nothing special to do \u2013 delegate.\r\n  if (!self._reuseActivationArrays)\r\n    return (this as any).activate(input, training, maxActivationDepth);\r\n\r\n  // Even when reuse is enabled we currently still just delegate; hook point for future optimization.\r\n  return (this as any).activate(input, training, maxActivationDepth);\r\n}\r\n\r\n/**\r\n * Activate the network over a mini\u2011batch (array) of input vectors, returning a 2\u2011D array of outputs.\r\n *\r\n * This helper simply loops, invoking {@link Network.activate} (or its bound variant) for each\r\n * sample. It is intentionally naive: no attempt is made to fuse operations across the batch.\r\n * For very large batch sizes or performance\u2011critical paths consider implementing a custom\r\n * vectorized backend that exploits SIMD, GPU kernels, or parallel workers.\r\n *\r\n * Input validation occurs per row to surface the earliest mismatch with a descriptive index.\r\n *\r\n * @param this - Bound {@link Network} instance.\r\n * @param inputs - Array of input vectors; each must have length == network.input.\r\n * @param training - Whether each activation should keep training traces.\r\n * @returns 2\u2011D array: outputs[i] is the activation result for inputs[i].\r\n * @throws {Error} If inputs is not an array, or any contained vector has an incorrect length.\r\n * @example\r\n * const batchOut = net.activateBatch([[0,0,1],[1,0,0],[0,1,0]]);\r\n * console.log(batchOut.length); // 3 rows\r\n * @remarks For small batches this is perfectly adequate and clear.\r\n */\r\nexport function activateBatch(\r\n  this: Network,\r\n  inputs: number[][],\r\n  training = false\r\n): number[][] {\r\n  // Global validation \u2013 ensure we can iterate as expected.\r\n  if (!Array.isArray(inputs))\r\n    throw new Error('inputs must be an array of input arrays');\r\n\r\n  /** Preallocate the output matrix at the correct height (one row per input). */\r\n  /** Output matrix (row-major) where each row corresponds to activation of one input vector. */\r\n  const out: number[][] = new Array(inputs.length);\r\n\r\n  // Iterate sequentially \u2013 early exit behavior (via throw) will surface the first invalid row.\r\n  for (let i = 0; i < inputs.length; i++) {\r\n    /** Current input vector under evaluation. */\r\n    /** Input vector at batch index i currently being processed. */\r\n    const x = inputs[i];\r\n    // Validate row dimensionality with a descriptive index for easier debugging.\r\n    if (!Array.isArray(x) || x.length !== this.input) {\r\n      throw new Error(\r\n        `Input[${i}] size mismatch: expected ${this.input}, got ${\r\n          x ? x.length : 'undefined'\r\n        }`\r\n      );\r\n    }\r\n    // Delegate to the network's activation (may perform tracing if training=true).\r\n    out[i] = (this as any).activate(x, training);\r\n  }\r\n\r\n  return out;\r\n}\r\n", "import Node from './node';\r\nimport Layer from './layer';\r\nimport { config } from '../config';\r\nimport * as methods from '../methods/methods';\r\n\r\n/**\r\n * Represents a collection of nodes functioning as a single unit within a network architecture.\r\n * Groups facilitate operations like collective activation, propagation, and connection management.\r\n */\r\nexport default class Group {\r\n  /**\r\n   * An array holding all the nodes within this group.\r\n   */\r\n  nodes: Node[];\r\n  /**\r\n   * Stores connection information related to this group.\r\n   * `in`: Connections coming into any node in this group from outside.\r\n   * `out`: Connections going out from any node in this group to outside.\r\n   * `self`: Connections between nodes within this same group (e.g., in ONE_TO_ONE connections).\r\n   */\r\n  connections: {\r\n    in: any[]; // Consider using a more specific type like `Connection[]` if available\r\n    out: any[]; // Consider using a more specific type like `Connection[]` if available\r\n    self: any[]; // Consider using a more specific type like `Connection[]` if available\r\n  };\r\n\r\n  /**\r\n   * Creates a new group comprised of a specified number of nodes.\r\n   * @param {number} size - The quantity of nodes to initialize within this group.\r\n   */\r\n  constructor(size: number) {\r\n    this.nodes = [];\r\n    this.connections = {\r\n      in: [],\r\n      out: [],\r\n      self: [],\r\n    };\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      this.nodes.push(new Node());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activates all nodes in the group. If input values are provided, they are assigned\r\n   * sequentially to the nodes before activation. Otherwise, nodes activate based on their\r\n   * existing states and incoming connections.\r\n   *\r\n   * @param {number[]} [value] - An optional array of input values. If provided, its length must match the number of nodes in the group.\r\n   * @returns {number[]} An array containing the activation value of each node in the group, in order.\r\n   * @throws {Error} If the `value` array is provided and its length does not match the number of nodes in the group.\r\n   */\r\n  activate(value?: number[]): number[] {\r\n    const values: number[] = [];\r\n\r\n    if (value !== undefined && value.length !== this.nodes.length) {\r\n      throw new Error(\r\n        'Array with values should be same as the amount of nodes!'\r\n      );\r\n    }\r\n\r\n    for (let i = 0; i < this.nodes.length; i++) {\r\n      const activation =\r\n        value === undefined\r\n          ? this.nodes[i].activate()\r\n          : this.nodes[i].activate(value[i]);\r\n      values.push(activation);\r\n    }\r\n\r\n    return values;\r\n  }\r\n\r\n  /**\r\n   * Propagates the error backward through all nodes in the group. If target values are provided,\r\n   * the error is calculated against these targets (typically for output layers). Otherwise,\r\n   * the error is calculated based on the error propagated from subsequent layers/nodes.\r\n   *\r\n   * @param {number} rate - The learning rate to apply during weight updates.\r\n   * @param {number} momentum - The momentum factor to apply during weight updates.\r\n   * @param {number[]} [target] - Optional target values for error calculation. If provided, its length must match the number of nodes.\r\n   * @throws {Error} If the `target` array is provided and its length does not match the number of nodes in the group.\r\n   */\r\n  propagate(rate: number, momentum: number, target?: number[]): void {\r\n    if (target !== undefined && target.length !== this.nodes.length) {\r\n      throw new Error(\r\n        'Array with values should be same as the amount of nodes!'\r\n      );\r\n    }\r\n\r\n    for (let i = this.nodes.length - 1; i >= 0; i--) {\r\n      if (target === undefined) {\r\n        this.nodes[i].propagate(rate, momentum, true, 0);\r\n      } else {\r\n        this.nodes[i].propagate(rate, momentum, true, 0, target[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Establishes connections from all nodes in this group to a target Group, Layer, or Node.\r\n   * The connection pattern (e.g., all-to-all, one-to-one) can be specified.\r\n   *\r\n   * @param {Group | Layer | Node} target - The destination entity (Group, Layer, or Node) to connect to.\r\n   * @param {methods.groupConnection | methods.connection} [method] - The connection method/type (e.g., `methods.groupConnection.ALL_TO_ALL`, `methods.groupConnection.ONE_TO_ONE`). Defaults depend on the target type and whether it's the same group.\r\n   * @param {number} [weight] - An optional fixed weight to assign to all created connections. If not provided, weights might be initialized randomly or based on node defaults.\r\n   * @returns {any[]} An array containing all the connection objects created. Consider using a more specific type like `Connection[]`.\r\n   * @throws {Error} If `methods.groupConnection.ONE_TO_ONE` is used and the source and target groups have different sizes.\r\n   */\r\n  connect(target: Group | Layer | Node, method?: any, weight?: number): any[] {\r\n    let connections: any[] = [];\r\n    let i, j;\r\n\r\n    // Connection to another Group\r\n    if (target instanceof Group) {\r\n      // Determine default connection method if none is provided\r\n      if (method === undefined) {\r\n        if (this !== target) {\r\n          // Default to ALL_TO_ALL if connecting to a different group\r\n          if (config.warnings)\r\n            console.warn(\r\n              'No group connection specified, using ALL_TO_ALL by default.'\r\n            );\r\n          method = methods.groupConnection.ALL_TO_ALL;\r\n        } else {\r\n          // Default to ONE_TO_ONE if connecting to the same group (self-connection)\r\n          if (config.warnings)\r\n            console.warn(\r\n              'Connecting group to itself, using ONE_TO_ONE by default.'\r\n            );\r\n          method = methods.groupConnection.ONE_TO_ONE;\r\n        }\r\n      }\r\n      // Handle ALL_TO_ALL and ALL_TO_ELSE connection methods\r\n      if (\r\n        method === methods.groupConnection.ALL_TO_ALL ||\r\n        method === methods.groupConnection.ALL_TO_ELSE\r\n      ) {\r\n        // Iterate over each node in the source group\r\n        for (i = 0; i < this.nodes.length; i++) {\r\n          // Iterate over each node in the target group\r\n          for (j = 0; j < target.nodes.length; j++) {\r\n            // Skip self-connection if method is ALL_TO_ELSE\r\n            if (\r\n              method === methods.groupConnection.ALL_TO_ELSE &&\r\n              this.nodes[i] === target.nodes[j]\r\n            )\r\n              continue;\r\n            // Create connection from source node to target node\r\n            let connection = this.nodes[i].connect(target.nodes[j], weight);\r\n            // Store the outgoing connection reference in the source group\r\n            this.connections.out.push(connection[0]);\r\n            // Store the incoming connection reference in the target group\r\n            target.connections.in.push(connection[0]);\r\n            // Add the created connection to the list of connections returned by this method\r\n            connections.push(connection[0]);\r\n          }\r\n        }\r\n        // Handle ONE_TO_ONE connection method\r\n      } else if (method === methods.groupConnection.ONE_TO_ONE) {\r\n        // Ensure groups are the same size for ONE_TO_ONE connection\r\n        if (this.nodes.length !== target.nodes.length) {\r\n          throw new Error(\r\n            'Cannot create ONE_TO_ONE connection: source and target groups must have the same size.'\r\n          );\r\n        }\r\n\r\n        // Iterate and connect corresponding nodes\r\n        for (i = 0; i < this.nodes.length; i++) {\r\n          let connection = this.nodes[i].connect(target.nodes[i], weight);\r\n          if (this === target) {\r\n            // Store self-connections (within the group)\r\n            this.connections.self.push(connection[0]);\r\n          } else {\r\n            // Store connections between different groups\r\n            this.connections.out.push(connection[0]);\r\n            target.connections.in.push(connection[0]);\r\n          }\r\n          connections.push(connection[0]);\r\n        }\r\n      }\r\n      // Connection to a Layer (delegates to the Layer's input method)\r\n    } else if (target instanceof Layer) {\r\n      connections = target.input(this, method, weight);\r\n      // Connection to a single Node\r\n    } else if (target instanceof Node) {\r\n      // Connect every node in this group to the target node\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        let connection = this.nodes[i].connect(target, weight);\r\n        // Store outgoing connections\r\n        this.connections.out.push(connection[0]);\r\n        connections.push(connection[0]);\r\n      }\r\n    }\r\n\r\n    return connections;\r\n  }\r\n\r\n  /**\r\n   * Configures nodes within this group to act as gates for the specified connection(s).\r\n   * Gating allows the output of a node in this group to modulate the flow of signal through the gated connection.\r\n   *\r\n   * @param {any | any[]} connections - A single connection object or an array of connection objects to be gated. Consider using a more specific type like `Connection | Connection[]`.\r\n   * @param {methods.gating} method - The gating mechanism to use (e.g., `methods.gating.INPUT`, `methods.gating.OUTPUT`, `methods.gating.SELF`). Specifies which part of the connection is influenced by the gater node.\r\n   * @throws {Error} If no gating `method` is specified.\r\n   */\r\n  gate(connections: any | any[], method: any): void {\r\n    if (method === undefined) {\r\n      throw new Error(\r\n        'Please specify a gating method: Gating.INPUT, Gating.OUTPUT, or Gating.SELF'\r\n      );\r\n    }\r\n\r\n    // Ensure connections is an array for uniform processing\r\n    if (!Array.isArray(connections)) {\r\n      connections = [connections];\r\n    }\r\n\r\n    // Collect unique source (from) and target (to) nodes from the connections to be gated\r\n    const nodes1: Node[] = []; // Source nodes\r\n    const nodes2: Node[] = []; // Target nodes\r\n\r\n    let i, j;\r\n    for (i = 0; i < connections.length; i++) {\r\n      const connection = connections[i];\r\n      if (!nodes1.includes(connection.from)) nodes1.push(connection.from);\r\n      if (!nodes2.includes(connection.to)) nodes2.push(connection.to);\r\n    }\r\n\r\n    switch (method) {\r\n      // Gate the input to the target node(s) of the connection(s)\r\n      case methods.gating.INPUT:\r\n        for (let i = 0; i < connections.length; i++) {\r\n          const conn = connections[i];\r\n          const gater = this.nodes[i % this.nodes.length];\r\n          gater.gate(conn);\r\n        }\r\n        break;\r\n\r\n      // Gate the output from the source node(s) of the connection(s)\r\n      case methods.gating.OUTPUT:\r\n        for (i = 0; i < nodes1.length; i++) {\r\n          let node = nodes1[i]; // Source node of a connection\r\n          // Select a gater node from this group\r\n          let gater = this.nodes[i % this.nodes.length];\r\n\r\n          // Find outgoing connections from the source node that are in the provided list\r\n          for (j = 0; j < node.connections.out.length; j++) {\r\n            let conn = node.connections.out[j];\r\n            if (connections.includes(conn)) {\r\n              // Apply gating from the selected gater node to this connection\r\n              gater.gate(conn);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n\r\n      // Gate the self-connection of the node(s) involved\r\n      case methods.gating.SELF:\r\n        for (i = 0; i < nodes1.length; i++) {\r\n          let node = nodes1[i]; // Node with the self-connection\r\n          let gater = this.nodes[i % this.nodes.length];\r\n          // Get the actual self-connection object (first element)\r\n          const selfConn = Array.isArray(node.connections.self)\r\n            ? node.connections.self[0]\r\n            : node.connections.self;\r\n          if (connections.includes(selfConn)) {\r\n            gater.gate(selfConn);\r\n          }\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets specific properties (like bias, squash function, or type) for all nodes within the group.\r\n   *\r\n   * @param {{ bias?: number; squash?: any; type?: string }} values - An object containing the properties and their new values. Only provided properties are updated.\r\n   *        `bias`: Sets the bias term for all nodes.\r\n   *        `squash`: Sets the activation function (squashing function) for all nodes.\r\n   *        `type`: Sets the node type (e.g., 'input', 'hidden', 'output') for all nodes.\r\n   */\r\n  set(values: { bias?: number; squash?: any; type?: string }): void {\r\n    for (let i = 0; i < this.nodes.length; i++) {\r\n      if (values.bias !== undefined) {\r\n        this.nodes[i].bias = values.bias;\r\n      }\r\n      this.nodes[i].squash = values.squash || this.nodes[i].squash;\r\n      this.nodes[i].type = values.type || this.nodes[i].type;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes connections between nodes in this group and a target Group or Node.\r\n   *\r\n   * @param {Group | Node} target - The Group or Node to disconnect from.\r\n   * @param {boolean} [twosided=false] - If true, also removes connections originating from the `target` and ending in this group. Defaults to false (only removes connections from this group to the target).\r\n   */\r\n  disconnect(target: Group | Node, twosided: boolean = false): void {\r\n    let i, j, k;\r\n\r\n    // Disconnecting from another Group\r\n    if (target instanceof Group) {\r\n      // Iterate through nodes in this group\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        // Iterate through nodes in the target group\r\n        for (j = 0; j < target.nodes.length; j++) {\r\n          // Disconnect individual nodes (handles internal node connection state)\r\n          this.nodes[i].disconnect(target.nodes[j], twosided);\r\n\r\n          // Remove the connection reference from this group's outgoing connections list\r\n          for (k = this.connections.out.length - 1; k >= 0; k--) {\r\n            let conn = this.connections.out[k];\r\n            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {\r\n              this.connections.out.splice(k, 1);\r\n              break; // Assume only one connection between two specific nodes\r\n            }\r\n          }\r\n\r\n          // If twosided, also remove the reverse connection references from group lists\r\n          if (twosided) {\r\n            // Remove from this group's incoming list\r\n            for (k = this.connections.in.length - 1; k >= 0; k--) {\r\n              let conn = this.connections.in[k];\r\n              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {\r\n                this.connections.in.splice(k, 1);\r\n                break; // Assume only one connection\r\n              }\r\n            }\r\n            // Remove from target group's outgoing list\r\n            for (k = target.connections.out.length - 1; k >= 0; k--) {\r\n              let conn = target.connections.out[k];\r\n              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {\r\n                target.connections.out.splice(k, 1);\r\n                break; // Assume only one connection\r\n              }\r\n            }\r\n            // Remove from target group's incoming list (forward connection)\r\n            for (k = target.connections.in.length - 1; k >= 0; k--) {\r\n              let conn = target.connections.in[k];\r\n              if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {\r\n                target.connections.in.splice(k, 1);\r\n                break; // Assume only one connection\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // Disconnecting from a single Node\r\n    } else if (target instanceof Node) {\r\n      // Iterate through nodes in this group\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        // Disconnect the node in this group from the target node\r\n        this.nodes[i].disconnect(target, twosided);\r\n\r\n        // Remove the connection reference from this group's outgoing connections list\r\n        for (j = this.connections.out.length - 1; j >= 0; j--) {\r\n          let conn = this.connections.out[j];\r\n          if (conn.from === this.nodes[i] && conn.to === target) {\r\n            this.connections.out.splice(j, 1);\r\n            break; // Assume only one connection\r\n          }\r\n        }\r\n\r\n        // If twosided, also remove the connection reference from this group's incoming connections list\r\n        if (twosided) {\r\n          for (j = this.connections.in.length - 1; j >= 0; j--) {\r\n            const conn = this.connections.in[j];\r\n            if (conn.from === target && conn.to === this.nodes[i]) {\r\n              this.connections.in.splice(j, 1);\r\n              break; // Assume only one connection\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the state of all nodes in the group. This typically involves clearing\r\n   * activation values, state, and propagated errors, preparing the group for a new input pattern,\r\n   * especially relevant in recurrent networks or sequence processing.\r\n   */\r\n  clear(): void {\r\n    for (let i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Serializes the group into a JSON-compatible format, avoiding circular references.\r\n   * Only includes node indices and connection counts.\r\n   *\r\n   * @returns {object} A JSON-compatible representation of the group.\r\n   */\r\n  toJSON() {\r\n    return {\r\n      size: this.nodes.length,\r\n      nodeIndices: this.nodes.map((n) => n.index),\r\n      connections: {\r\n        in: this.connections.in.length,\r\n        out: this.connections.out.length,\r\n        self: this.connections.self.length,\r\n      },\r\n    };\r\n  }\r\n}\r\n", "import Node from './node';\r\nimport Group from './group';\r\nimport * as methods from '../methods/methods';\r\nimport { activationArrayPool } from './activationArrayPool';\r\n\r\n/**\r\n * Represents a functional layer within a neural network architecture.\r\n *\r\n * Layers act as organizational units for nodes, facilitating the creation of\r\n * complex network structures like Dense, LSTM, GRU, or Memory layers.\r\n * They manage the collective behavior of their nodes, including activation,\r\n * propagation, and connection to other network components.\r\n */\r\nexport default class Layer {\r\n  /**\r\n   * An array containing all the nodes (neurons or groups) that constitute this layer.\r\n   * The order of nodes might be relevant depending on the layer type and its connections.\r\n   */\r\n  nodes: Node[]; // Note: While typed as Node[], can contain Group instances in practice for memory layers.\r\n\r\n  /**\r\n   * Stores connection information related to this layer. This is often managed\r\n   * by the network or higher-level structures rather than directly by the layer itself.\r\n   * `in`: Incoming connections to the layer's nodes.\r\n   * `out`: Outgoing connections from the layer's nodes.\r\n   * `self`: Self-connections within the layer's nodes.\r\n   */\r\n  connections: { in: any[]; out: any[]; self: any[] };\r\n\r\n  /**\r\n   * Represents the primary output group of nodes for this layer.\r\n   * This group is typically used when connecting this layer *to* another layer or group.\r\n   * It might be null if the layer is not yet fully constructed or is an input layer.\r\n   */\r\n  output: Group | null;\r\n\r\n  /**\r\n   * Dropout rate for this layer (0 to 1). If > 0, all nodes in the layer are masked together during training.\r\n   * Layer-level dropout takes precedence over node-level dropout for nodes in this layer.\r\n   */\r\n  dropout: number = 0;\r\n\r\n  /**\r\n   * Initializes a new Layer instance.\r\n   */\r\n  constructor() {\r\n    this.output = null;\r\n    this.nodes = [];\r\n    this.connections = { in: [], out: [], self: [] }; // Initialize connection tracking\r\n  }\r\n\r\n  /**\r\n   * Activates all nodes within the layer, computing their output values.\r\n   *\r\n   * If an input `value` array is provided, it's used as the initial activation\r\n   * for the corresponding nodes in the layer. Otherwise, nodes compute their\r\n   * activation based on their incoming connections.\r\n   *\r\n   * During training, layer-level dropout is applied, masking all nodes in the layer together.\r\n   * During inference, all masks are set to 1.\r\n   *\r\n   * @param value - An optional array of activation values to set for the layer's nodes. The length must match the number of nodes.\r\n   * @param training - A boolean indicating whether the layer is in training mode. Defaults to false.\r\n   * @returns An array containing the activation value of each node in the layer after activation.\r\n   * @throws {Error} If the provided `value` array's length does not match the number of nodes in the layer.\r\n   */\r\n  activate(value?: number[], training: boolean = false): number[] {\r\n    const out = activationArrayPool.acquire(this.nodes.length);\r\n\r\n    // Input validation\r\n    if (value !== undefined && value.length !== this.nodes.length) {\r\n      throw new Error(\r\n        'Array with values should be same as the amount of nodes!'\r\n      );\r\n    }\r\n\r\n    // --- Layer-level dropout logic ---\r\n    let layerMask = 1;\r\n    if (training && this.dropout > 0) {\r\n      // Fix: Use comparison with dropout rate directly to ensure both 0 and 1 masks occur\r\n      layerMask = Math.random() >= this.dropout ? 1 : 0;\r\n      this.nodes.forEach((node) => {\r\n        node.mask = layerMask;\r\n      });\r\n    } else {\r\n      // In inference or no dropout, ensure all masks are 1\r\n      this.nodes.forEach((node) => {\r\n        node.mask = 1;\r\n      });\r\n    }\r\n\r\n    // Activate each node\r\n    for (let i = 0; i < this.nodes.length; i++) {\r\n      let activation: number;\r\n      if (value === undefined) {\r\n        activation = this.nodes[i].activate();\r\n      } else {\r\n        activation = this.nodes[i].activate(value[i]);\r\n      }\r\n      (out as any)[i] = activation;\r\n    }\r\n    const cloned = Array.from(out as any) as number[];\r\n    activationArrayPool.release(out);\r\n    return cloned; // Return the activation values of all nodes\r\n  }\r\n\r\n  /**\r\n   * Propagates the error backward through all nodes in the layer.\r\n   *\r\n   * This is a core step in the backpropagation algorithm used for training.\r\n   * If a `target` array is provided (typically for the output layer), it's used\r\n   * to calculate the initial error for each node. Otherwise, nodes calculate\r\n   * their error based on the error propagated from subsequent layers.\r\n   *\r\n   * @param rate - The learning rate, controlling the step size of weight adjustments.\r\n   * @param momentum - The momentum factor, used to smooth weight updates and escape local minima.\r\n   * @param target - An optional array of target values (expected outputs) for the layer's nodes. The length must match the number of nodes.\r\n   * @throws {Error} If the provided `target` array's length does not match the number of nodes in the layer.\r\n   */\r\n  propagate(rate: number, momentum: number, target?: number[]) {\r\n    // Input validation\r\n    if (target !== undefined && target.length !== this.nodes.length) {\r\n      throw new Error(\r\n        'Array with values should be same as the amount of nodes!'\r\n      );\r\n    }\r\n\r\n    // Propagate error backward through nodes (iterate in reverse order)\r\n    for (let i = this.nodes.length - 1; i >= 0; i--) {\r\n      if (target === undefined) {\r\n        this.nodes[i].propagate(rate, momentum, true, 0);\r\n      } else {\r\n        this.nodes[i].propagate(rate, momentum, true, 0, target[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Connects this layer's output to a target component (Layer, Group, or Node).\r\n   *\r\n   * This method delegates the connection logic primarily to the layer's `output` group\r\n   * or the target layer's `input` method. It establishes the forward connections\r\n   * necessary for signal propagation.\r\n   *\r\n   * @param target - The destination Layer, Group, or Node to connect to.\r\n   * @param method - The connection method (e.g., `ALL_TO_ALL`, `ONE_TO_ONE`) defining the connection pattern. See `methods.groupConnection`.\r\n   * @param weight - An optional fixed weight to assign to all created connections.\r\n   * @returns An array containing the newly created connection objects.\r\n   * @throws {Error} If the layer's `output` group is not defined.\r\n   */\r\n  connect(target: Group | Node | Layer, method?: any, weight?: number): any[] {\r\n    // Ensure the output group is defined before connecting\r\n    if (!this.output) {\r\n      throw new Error(\r\n        'Layer output is not defined. Cannot connect from this layer.'\r\n      );\r\n    }\r\n\r\n    let connections: any[] = [];\r\n    if (target instanceof Layer) {\r\n      // Delegate connection ONLY to the target layer's input method\r\n      connections = target.input(this, method, weight);\r\n    } else if (target instanceof Group || target instanceof Node) {\r\n      // Connect the layer's output group to the target Group or Node\r\n      connections = this.output.connect(target, method, weight);\r\n    }\r\n\r\n    return connections;\r\n  }\r\n\r\n  /**\r\n   * Applies gating to a set of connections originating from this layer's output group.\r\n   *\r\n   * Gating allows the activity of nodes in this layer (specifically, the output group)\r\n   * to modulate the flow of information through the specified `connections`.\r\n   *\r\n   * @param connections - An array of connection objects to be gated.\r\n   * @param method - The gating method (e.g., `INPUT`, `OUTPUT`, `SELF`) specifying how the gate influences the connection. See `methods.gating`.\r\n   * @throws {Error} If the layer's `output` group is not defined.\r\n   */\r\n  gate(connections: any[], method: any) {\r\n    // Ensure the output group is defined before gating\r\n    if (!this.output) {\r\n      throw new Error(\r\n        'Layer output is not defined. Cannot gate from this layer.'\r\n      );\r\n    }\r\n    // Delegate gating to the output group\r\n    this.output.gate(connections, method);\r\n  }\r\n\r\n  /**\r\n   * Configures properties for all nodes within the layer.\r\n   *\r\n   * Allows batch setting of common node properties like bias, activation function (`squash`),\r\n   * or node type. If a node within the `nodes` array is actually a `Group` (e.g., in memory layers),\r\n   * the configuration is applied recursively to the nodes within that group.\r\n   *\r\n   * @param values - An object containing the properties and their values to set.\r\n   *                 Example: `{ bias: 0.5, squash: methods.Activation.ReLU }`\r\n   */\r\n  set(values: { bias?: number; squash?: any; type?: string }) {\r\n    for (let i = 0; i < this.nodes.length; i++) {\r\n      let node = this.nodes[i];\r\n\r\n      if (node instanceof Node) {\r\n        // Apply settings directly to Node instances\r\n        if (values.bias !== undefined) {\r\n          node.bias = values.bias;\r\n        }\r\n        // Use provided squash function or keep the existing one\r\n        node.squash = values.squash || node.squash;\r\n        // Use provided type or keep the existing one\r\n        node.type = values.type || node.type;\r\n      } else if (this.isGroup(node)) {\r\n        // If it's a Group (possible in memory layers), apply settings recursively\r\n        (node as Group).set(values);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes connections between this layer's nodes and a target Group or Node.\r\n   *\r\n   * @param target - The Group or Node to disconnect from.\r\n   * @param twosided - If true, removes connections in both directions (from this layer to target, and from target to this layer). Defaults to false.\r\n   */\r\n  disconnect(target: Group | Node, twosided?: boolean) {\r\n    twosided = twosided || false; // Default to false if not provided\r\n\r\n    let i, j, k;\r\n    // Determine if the target is a Group or a single Node\r\n    if (target instanceof Group) {\r\n      // Iterate through all nodes in this layer and the target group\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        for (j = 0; j < target.nodes.length; j++) {\r\n          // Disconnect individual nodes\r\n          this.nodes[i].disconnect(target.nodes[j], twosided);\r\n\r\n          // Clean up connection tracking within the layer object (outgoing)\r\n          for (k = this.connections.out.length - 1; k >= 0; k--) {\r\n            let conn = this.connections.out[k];\r\n            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {\r\n              this.connections.out.splice(k, 1);\r\n              break; // Assume only one connection between two nodes here\r\n            }\r\n          }\r\n\r\n          // Clean up connection tracking (incoming) if twosided\r\n          if (twosided) {\r\n            for (k = this.connections.in.length - 1; k >= 0; k--) {\r\n              let conn = this.connections.in[k];\r\n              if (conn.from === target.nodes[j] && conn.to === this.nodes[i]) {\r\n                this.connections.in.splice(k, 1);\r\n                break; // Assume only one connection\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (target instanceof Node) {\r\n      // Iterate through all nodes in this layer\r\n      for (i = 0; i < this.nodes.length; i++) {\r\n        // Disconnect from the target node\r\n        this.nodes[i].disconnect(target, twosided);\r\n\r\n        // Clean up connection tracking (outgoing)\r\n        for (j = this.connections.out.length - 1; j >= 0; j--) {\r\n          let conn = this.connections.out[j];\r\n          if (conn.from === this.nodes[i] && conn.to === target) {\r\n            this.connections.out.splice(j, 1);\r\n            break; // Assume only one connection\r\n          }\r\n        }\r\n\r\n        // Clean up connection tracking (incoming) if twosided\r\n        if (twosided) {\r\n          for (k = this.connections.in.length - 1; k >= 0; k--) {\r\n            let conn = this.connections.in[k];\r\n            if (conn.from === target && conn.to === this.nodes[i]) {\r\n              this.connections.in.splice(k, 1);\r\n              break; // Assume only one connection\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the activation state of all nodes within the layer.\r\n   * This is typically done before processing a new input sequence or sample.\r\n   */\r\n  clear() {\r\n    for (let i = 0; i < this.nodes.length; i++) {\r\n      this.nodes[i].clear(); // Delegate clearing to individual nodes/groups\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles the connection logic when this layer is the *target* of a connection.\r\n   *\r\n   * It connects the output of the `from` layer or group to this layer's primary\r\n   * input mechanism (which is often the `output` group itself, but depends on the layer type).\r\n   * This method is usually called by the `connect` method of the source layer/group.\r\n   *\r\n   * @param from - The source Layer or Group connecting *to* this layer.\r\n   * @param method - The connection method (e.g., `ALL_TO_ALL`). Defaults to `ALL_TO_ALL`.\r\n   * @param weight - An optional fixed weight for the connections.\r\n   * @returns An array containing the newly created connection objects.\r\n   * @throws {Error} If the layer's `output` group (acting as input target here) is not defined.\r\n   */\r\n  input(from: Layer | Group, method?: any, weight?: number): any[] {\r\n    // If connecting from another Layer, use its output group as the source\r\n    if (from instanceof Layer) from = from.output!;\r\n    // Default connection method if not specified\r\n    method = method || methods.groupConnection.ALL_TO_ALL;\r\n    // Ensure this layer's target group (output) is defined\r\n    if (!this.output) {\r\n      throw new Error('Layer output (acting as input target) is not defined.');\r\n    }\r\n    // Connect the source group 'from' to this layer's 'output' group\r\n    return from.connect(this.output, method, weight);\r\n  }\r\n\r\n  // Static Layer Factory Methods\r\n\r\n  /**\r\n   * Creates a standard fully connected (dense) layer.\r\n   *\r\n   * All nodes in the source layer/group will connect to all nodes in this layer\r\n   * when using the default `ALL_TO_ALL` connection method via `layer.input()`.\r\n   *\r\n   * @param size - The number of nodes (neurons) in this layer.\r\n   * @returns A new Layer instance configured as a dense layer.\r\n   */\r\n  static dense(size: number): Layer {\r\n    // Initialize a new Layer\r\n    const layer = new Layer();\r\n\r\n    // Create a single group containing all nodes for this layer\r\n    const block = new Group(size);\r\n\r\n    // Add the nodes from the group to the layer's node list\r\n    layer.nodes.push(...block.nodes);\r\n    // Set the group as the primary output (and input target) for this layer\r\n    layer.output = block;\r\n\r\n    // Override the default input method to connect directly to the 'block' group\r\n    layer.input = (\r\n      from: Layer | Group,\r\n      method?: any,\r\n      weight?: number\r\n    ): any[] => {\r\n      if (from instanceof Layer) from = from.output!; // Use output group of source layer\r\n      method = method || methods.groupConnection.ALL_TO_ALL; // Default connection\r\n      // Connect the source 'from' to this layer's 'block'\r\n      return from.connect(block, method, weight);\r\n    };\r\n\r\n    return layer;\r\n  }\r\n\r\n  /**\r\n   * Creates a Long Short-Term Memory (LSTM) layer.\r\n   *\r\n   * LSTMs are a type of recurrent neural network (RNN) cell capable of learning\r\n   * long-range dependencies. This implementation uses standard LSTM architecture\r\n   * with input, forget, and output gates, and a memory cell.\r\n   *\r\n   * @param size - The number of LSTM units (and nodes in each gate/cell group).\r\n   * @returns A new Layer instance configured as an LSTM layer.\r\n   */\r\n  static lstm(size: number): Layer {\r\n    // Initialize a new Layer\r\n    const layer = new Layer();\r\n\r\n    // Create the core components (groups of nodes) of the LSTM cell\r\n    const inputGate = new Group(size); // Controls flow of new information into the cell\r\n    const forgetGate = new Group(size); // Controls what information to throw away from the cell state\r\n    const memoryCell = new Group(size); // Stores the internal cell state over time\r\n    const outputGate = new Group(size); // Controls what parts of the cell state to output\r\n    const outputBlock = new Group(size); // Final output of the LSTM unit for this time step\r\n\r\n    // Set initial biases for gates (common practice to initialize near 1 or 0)\r\n    inputGate.set({ bias: 1 });\r\n    forgetGate.set({ bias: 1 });\r\n    outputGate.set({ bias: 1 });\r\n    // Set initial bias for memory cell and output block to 0 (modern practice)\r\n    memoryCell.set({ bias: 0 });\r\n    outputBlock.set({ bias: 0 });\r\n\r\n    // Internal connections within the LSTM unit\r\n    // Connections to gates influence their activation\r\n    memoryCell.connect(inputGate, methods.groupConnection.ALL_TO_ALL);\r\n    memoryCell.connect(forgetGate, methods.groupConnection.ALL_TO_ALL);\r\n    memoryCell.connect(outputGate, methods.groupConnection.ALL_TO_ALL);\r\n    // Recurrent connection from memory cell back to itself (gated by forget gate)\r\n    memoryCell.connect(memoryCell, methods.groupConnection.ONE_TO_ONE);\r\n    // Connection from memory cell to the final output block (gated by output gate)\r\n    const output = memoryCell.connect(\r\n      outputBlock,\r\n      methods.groupConnection.ALL_TO_ALL\r\n    );\r\n\r\n    // Apply gating mechanisms\r\n    // Output gate controls the connection from the memory cell to the output block\r\n    outputGate.gate(output, methods.gating.OUTPUT);\r\n\r\n    // Apply forget gate to self-connections directly\r\n    memoryCell.nodes.forEach((node, i) => {\r\n      // Find the self-connection on the node\r\n      const selfConnection = node.connections.self.find(\r\n        (conn) => conn.to === node && conn.from === node\r\n      );\r\n      if (selfConnection) {\r\n        // Assign the corresponding forget gate node as the gater\r\n        selfConnection.gater = forgetGate.nodes[i];\r\n        // Ensure the gater node knows about the connection it gates\r\n        if (!forgetGate.nodes[i].connections.gated.includes(selfConnection)) {\r\n          forgetGate.nodes[i].connections.gated.push(selfConnection);\r\n        }\r\n      } else {\r\n        // This case should ideally not happen if connect worked correctly\r\n        console.warn(\r\n          `LSTM Warning: No self-connection found for memory cell node ${i}`\r\n        );\r\n      }\r\n    });\r\n\r\n    // Aggregate all nodes from the internal groups into the layer's node list\r\n    layer.nodes = [\r\n      ...inputGate.nodes,\r\n      ...forgetGate.nodes,\r\n      ...memoryCell.nodes,\r\n      ...outputGate.nodes,\r\n      ...outputBlock.nodes,\r\n    ];\r\n\r\n    // Set the final output block as the layer's primary output\r\n    layer.output = outputBlock;\r\n\r\n    // Define how external inputs connect to this LSTM layer\r\n    layer.input = (\r\n      from: Layer | Group,\r\n      method?: any,\r\n      weight?: number\r\n    ): any[] => {\r\n      if (from instanceof Layer) from = from.output!; // Use output group of source layer\r\n      method = method || methods.groupConnection.ALL_TO_ALL; // Default connection\r\n      let connections: any[] = [];\r\n\r\n      // Connect external input to the memory cell (candidate values) and all three gates\r\n      const input = from.connect(memoryCell, method, weight); // Input to cell calculation\r\n      connections = connections.concat(input);\r\n      connections = connections.concat(from.connect(inputGate, method, weight)); // Input to Input Gate\r\n      connections = connections.concat(\r\n        from.connect(outputGate, method, weight)\r\n      ); // Input to Output Gate\r\n      connections = connections.concat(\r\n        from.connect(forgetGate, method, weight)\r\n      ); // Input to Forget Gate\r\n\r\n      // Input gate controls the influence of the external input on the memory cell state update\r\n      inputGate.gate(input, methods.gating.INPUT);\r\n\r\n      return connections; // Return all created connections\r\n    };\r\n\r\n    return layer;\r\n  }\r\n\r\n  /**\r\n   * Creates a Gated Recurrent Unit (GRU) layer.\r\n   *\r\n   * GRUs are another type of recurrent neural network cell, often considered\r\n   * simpler than LSTMs but achieving similar performance on many tasks.\r\n   * They use an update gate and a reset gate to manage information flow.\r\n   *\r\n   * @param size - The number of GRU units (and nodes in each gate/cell group).\r\n   * @returns A new Layer instance configured as a GRU layer.\r\n   */\r\n  static gru(size: number): Layer {\r\n    // Initialize a new Layer\r\n    const layer = new Layer();\r\n\r\n    // Create the core components (groups of nodes) of the GRU cell\r\n    const updateGate = new Group(size); // Determines how much of the previous state to keep\r\n    const inverseUpdateGate = new Group(size); // Computes (1 - updateGate output)\r\n    const resetGate = new Group(size); // Determines how much of the previous state to forget\r\n    const memoryCell = new Group(size); // Calculates candidate activation\r\n    const output = new Group(size); // Final output of the GRU unit for this time step\r\n    const previousOutput = new Group(size); // Stores the output from the previous time step\r\n\r\n    // Configure node properties for specific components\r\n    previousOutput.set({\r\n      bias: 0,\r\n      squash: methods.Activation.identity, // Pass through previous output directly\r\n      type: 'variant', // Custom type identifier\r\n    });\r\n    memoryCell.set({\r\n      squash: methods.Activation.tanh, // Tanh activation for candidate state\r\n    });\r\n    inverseUpdateGate.set({\r\n      bias: 0,\r\n      squash: methods.Activation.inverse, // Activation computes 1 - input\r\n      type: 'variant', // Custom type identifier\r\n    });\r\n    updateGate.set({ bias: 1 }); // Initialize update gate bias (common practice)\r\n    resetGate.set({ bias: 0 }); // Initialize reset gate bias\r\n\r\n    // Internal connections within the GRU unit\r\n    // Previous output influences gates\r\n    previousOutput.connect(updateGate, methods.groupConnection.ALL_TO_ALL);\r\n    previousOutput.connect(resetGate, methods.groupConnection.ALL_TO_ALL);\r\n\r\n    // Update gate feeds into inverse update gate\r\n    updateGate.connect(\r\n      inverseUpdateGate,\r\n      methods.groupConnection.ONE_TO_ONE,\r\n      1\r\n    ); // Weight of 1 for direct inversion\r\n\r\n    // Previous output, gated by reset gate, influences memory cell candidate calculation\r\n    const reset = previousOutput.connect(\r\n      memoryCell,\r\n      methods.groupConnection.ALL_TO_ALL\r\n    );\r\n    resetGate.gate(reset, methods.gating.OUTPUT); // Reset gate controls this connection\r\n\r\n    // Calculate final output: combination of previous output and candidate activation, controlled by update gate\r\n    const update1 = previousOutput.connect(\r\n      output,\r\n      methods.groupConnection.ALL_TO_ALL\r\n    ); // Connection from previous output\r\n    const update2 = memoryCell.connect(\r\n      output,\r\n      methods.groupConnection.ALL_TO_ALL\r\n    ); // Connection from candidate activation\r\n\r\n    // Apply gating by update gate and its inverse\r\n    updateGate.gate(update1, methods.gating.OUTPUT); // Update gate controls influence of previous output\r\n    inverseUpdateGate.gate(update2, methods.gating.OUTPUT); // Inverse update gate controls influence of candidate activation\r\n\r\n    // Store the current output for the next time step\r\n    output.connect(previousOutput, methods.groupConnection.ONE_TO_ONE, 1); // Direct copy with weight 1\r\n\r\n    // Aggregate all nodes into the layer's node list\r\n    layer.nodes = [\r\n      ...updateGate.nodes,\r\n      ...inverseUpdateGate.nodes,\r\n      ...resetGate.nodes,\r\n      ...memoryCell.nodes,\r\n      ...output.nodes,\r\n      ...previousOutput.nodes,\r\n    ];\r\n\r\n    // Set the 'output' group as the layer's primary output\r\n    layer.output = output;\r\n\r\n    // Define how external inputs connect to this GRU layer\r\n    layer.input = (\r\n      from: Layer | Group,\r\n      method?: any,\r\n      weight?: number\r\n    ): any[] => {\r\n      if (from instanceof Layer) from = from.output!; // Use output group of source layer\r\n      method = method || methods.groupConnection.ALL_TO_ALL; // Default connection\r\n      let connections: any[] = [];\r\n\r\n      // Connect external input to update gate, reset gate, and memory cell candidate calculation\r\n      connections = connections.concat(\r\n        from.connect(updateGate, method, weight)\r\n      );\r\n      connections = connections.concat(from.connect(resetGate, method, weight));\r\n      connections = connections.concat(\r\n        from.connect(memoryCell, method, weight)\r\n      );\r\n\r\n      return connections; // Return all created connections\r\n    };\r\n\r\n    return layer;\r\n  }\r\n\r\n  /**\r\n   * Creates a Memory layer, designed to hold state over a fixed number of time steps.\r\n   *\r\n   * This layer consists of multiple groups (memory blocks), each holding the state\r\n   * from a previous time step. The input connects to the most recent block, and\r\n   * information propagates backward through the blocks. The layer's output\r\n   * concatenates the states of all memory blocks.\r\n   *\r\n   * @param size - The number of nodes in each memory block (must match the input size).\r\n   * @param memory - The number of time steps to remember (number of memory blocks).\r\n   * @returns A new Layer instance configured as a Memory layer.\r\n   * @throws {Error} If the connecting layer's size doesn't match the memory block `size`.\r\n   */\r\n  static memory(size: number, memory: number): Layer {\r\n    // Initialize a new Layer\r\n    const layer = new Layer();\r\n\r\n    let previous: Group | null = null; // Keep track of the previously created block\r\n    // Create 'memory' number of blocks\r\n    for (let i = 0; i < memory; i++) {\r\n      const block = new Group(size); // Each block has 'size' nodes\r\n\r\n      // Configure memory block nodes: linear activation, no bias\r\n      block.set({\r\n        squash: methods.Activation.identity,\r\n        bias: 0,\r\n        type: 'variant', // Custom type identifier\r\n      });\r\n\r\n      // Connect the previous block to the current block (propagates state backward)\r\n      if (previous != null) {\r\n        // ONE_TO_ONE connection with weight 1 copies state directly\r\n        previous.connect(block, methods.groupConnection.ONE_TO_ONE, 1);\r\n      }\r\n\r\n      // Add the *Group* itself to the layer's nodes list (unlike other layer types)\r\n      // This requires the `set` method to handle Groups internally.\r\n      layer.nodes.push((block as unknown) as Node); // Cast needed due to `nodes: Node[]` type hint\r\n      previous = block; // Update previous block reference\r\n    }\r\n\r\n    // Reverse the order of blocks so index 0 is the oldest memory\r\n    layer.nodes.reverse();\r\n\r\n    // Optional: Reverse nodes within each block if needed (depends on desired output order)\r\n    // for (let i = 0; i < layer.nodes.length; i++) {\r\n    //   layer.nodes[i].nodes.reverse(); // Assuming nodes property exists and is mutable\r\n    // }\r\n\r\n    // Create a single output group that concatenates nodes from all memory blocks\r\n    const outputGroup = new Group(0); // Start with an empty group\r\n    for (const group of layer.nodes) {\r\n      // Iterate through the blocks (which are Groups)\r\n      // Check if the item is actually a group before accessing nodes\r\n      if (this.prototype.isGroup(group)) {\r\n        outputGroup.nodes = outputGroup.nodes.concat(group.nodes);\r\n      } else {\r\n        // Handle cases where a Node might be directly in layer.nodes, though unlikely for memory layer\r\n        console.warn(\r\n          'Unexpected Node type found directly in Memory layer nodes list during output group creation.'\r\n        );\r\n      }\r\n    }\r\n    // Set the concatenated group as the layer's output\r\n    layer.output = outputGroup;\r\n\r\n    // Define how external inputs connect to this Memory layer\r\n    layer.input = (\r\n      from: Layer | Group,\r\n      method?: any,\r\n      weight?: number\r\n    ): any[] => {\r\n      if (from instanceof Layer) from = from.output!; // Use output group of source layer\r\n      // Method is typically ignored here as we force ONE_TO_ONE to the last block\r\n      method = method || methods.groupConnection.ALL_TO_ALL; // Keep for signature consistency\r\n\r\n      // Get the most recent memory block (last element after reversal)\r\n      const inputBlock = layer.nodes[layer.nodes.length - 1];\r\n      // Ensure the input block is a Group before accessing its nodes\r\n      if (!this.prototype.isGroup(inputBlock)) {\r\n        throw new Error('Memory layer input block is not a Group.');\r\n      }\r\n\r\n      // Validate that the input size matches the memory block size\r\n      if (from.nodes.length !== inputBlock.nodes.length) {\r\n        throw new Error(\r\n          `Previous layer size (${from.nodes.length}) must be same as memory size (${inputBlock.nodes.length})`\r\n        );\r\n      }\r\n\r\n      // Connect the external input directly to the most recent memory block\r\n      // ONE_TO_ONE with weight 1 copies the input into the block's state\r\n      return from.connect(inputBlock, methods.groupConnection.ONE_TO_ONE, 1);\r\n    };\r\n\r\n    return layer;\r\n  }\r\n\r\n  /**\r\n   * Creates a batch normalization layer.\r\n   * Applies batch normalization to the activations of the nodes in this layer during activation.\r\n   * @param size - The number of nodes in this layer.\r\n   * @returns A new Layer instance configured as a batch normalization layer.\r\n   */\r\n  static batchNorm(size: number): Layer {\r\n    const layer = Layer.dense(size);\r\n    (layer as any).batchNorm = true;\r\n    // Override activate to apply batch normalization\r\n    const baseActivate = layer.activate.bind(layer);\r\n    layer.activate = function (\r\n      value?: number[],\r\n      training: boolean = false\r\n    ): number[] {\r\n      const activations = baseActivate(value, training);\r\n      // Compute mean and variance\r\n      const mean = activations.reduce((a, b) => a + b, 0) / activations.length;\r\n      const variance =\r\n        activations.reduce((a, b) => a + (b - mean) ** 2, 0) /\r\n        activations.length;\r\n      const epsilon = 1e-5;\r\n      // Normalize\r\n      return activations.map((a) => (a - mean) / Math.sqrt(variance + epsilon));\r\n    };\r\n    return layer;\r\n  }\r\n\r\n  /**\r\n   * Creates a layer normalization layer.\r\n   * Applies layer normalization to the activations of the nodes in this layer during activation.\r\n   * @param size - The number of nodes in this layer.\r\n   * @returns A new Layer instance configured as a layer normalization layer.\r\n   */\r\n  static layerNorm(size: number): Layer {\r\n    const layer = Layer.dense(size);\r\n    (layer as any).layerNorm = true;\r\n    // Override activate to apply layer normalization\r\n    const baseActivate = layer.activate.bind(layer);\r\n    layer.activate = function (\r\n      value?: number[],\r\n      training: boolean = false\r\n    ): number[] {\r\n      const activations = baseActivate(value, training);\r\n      // Compute mean and variance (per sample, but here per layer)\r\n      const mean = activations.reduce((a, b) => a + b, 0) / activations.length;\r\n      const variance =\r\n        activations.reduce((a, b) => a + (b - mean) ** 2, 0) /\r\n        activations.length;\r\n      const epsilon = 1e-5;\r\n      // Normalize\r\n      return activations.map((a) => (a - mean) / Math.sqrt(variance + epsilon));\r\n    };\r\n    return layer;\r\n  }\r\n\r\n  /**\r\n   * Creates a 1D convolutional layer (stub implementation).\r\n   * @param size - Number of output nodes (filters).\r\n   * @param kernelSize - Size of the convolution kernel.\r\n   * @param stride - Stride of the convolution (default 1).\r\n   * @param padding - Padding (default 0).\r\n   * @returns A new Layer instance representing a 1D convolutional layer.\r\n   */\r\n  static conv1d(\r\n    size: number,\r\n    kernelSize: number,\r\n    stride: number = 1,\r\n    padding: number = 0\r\n  ): Layer {\r\n    const layer = new Layer();\r\n    layer.nodes = Array.from({ length: size }, () => new Node());\r\n    layer.output = new Group(size);\r\n    // Store conv params for future use\r\n    (layer as any).conv1d = { kernelSize, stride, padding };\r\n    // Placeholder: actual convolution logic would be in a custom activate method\r\n    layer.activate = function (value?: number[]): number[] {\r\n      // For now, just pass through or slice input as a stub\r\n      if (!value) return this.nodes.map((n) => n.activate());\r\n      // Simple stub: take the first 'size' values\r\n      return value.slice(0, size);\r\n    };\r\n    return layer;\r\n  }\r\n\r\n  /**\r\n   * Creates a multi-head self-attention layer (stub implementation).\r\n   * @param size - Number of output nodes.\r\n   * @param heads - Number of attention heads (default 1).\r\n   * @returns A new Layer instance representing an attention layer.\r\n   */\r\n  static attention(size: number, heads: number = 1): Layer {\r\n    const layer = new Layer();\r\n    layer.nodes = Array.from({ length: size }, () => new Node());\r\n    layer.output = new Group(size);\r\n    (layer as any).attention = { heads };\r\n    // Placeholder: actual attention logic would be in a custom activate method\r\n    layer.activate = function (value?: number[]): number[] {\r\n      // For now, just average the input as a stub\r\n      if (!value) return this.nodes.map((n) => n.activate());\r\n      const avg = value.reduce((a, b) => a + b, 0) / value.length;\r\n      return Array(size).fill(avg);\r\n    };\r\n    return layer;\r\n  }\r\n\r\n  /**\r\n   * Type guard to check if an object is likely a `Group`.\r\n   *\r\n   * This is a duck-typing check based on the presence of expected properties\r\n   * (`set` method and `nodes` array). Used internally where `layer.nodes`\r\n   * might contain `Group` instances (e.g., in `Memory` layers).\r\n   *\r\n   * @param obj - The object to inspect.\r\n   * @returns `true` if the object has `set` and `nodes` properties matching a Group, `false` otherwise.\r\n   */\r\n  private isGroup(obj: any): obj is Group {\r\n    // Check for existence and type of key properties\r\n    return !!obj && typeof obj.set === 'function' && Array.isArray(obj.nodes);\r\n  }\r\n}\r\n", "import type Network from '../network';\r\nimport Node from '../node';\r\nimport mutation from '../../methods/mutation';\r\nimport { config } from '../../config';\r\n\r\n/**\r\n * Network structural & parametric mutation utilities.\r\n *\r\n * This module exposes {@link mutateImpl} which delegates to small, focused internal helper\r\n * functions (one per mutation type). Extracting each case into its own function improves\r\n * readability, testability, and allows rich per-operator documentation.\r\n *\r\n * Mutations supported (see individual helper docs):\r\n *  - Topology: add/remove nodes, forward connections, backward connections, self connections.\r\n *  - Parameters: modify weights, biases, activations; swap node params.\r\n *  - Gating: add/remove gates.\r\n *  - Recurrent blocks: insert minimal LSTM / GRU macro-nodes.\r\n *\r\n * Internal helpers are intentionally un-exported (private to module) and are named with an\r\n * underscore prefix, e.g. {@link _addNode}.\r\n *\r\n * @module network.mutate\r\n */\r\n\r\n/**\r\n * Dispatcher from mutation identity -> implementation.\r\n *\r\n * Why a map instead of a giant switch?\r\n *  - O(1) lookup keeps code flatter and makes tree\u2011shaking friendlier.\r\n *  - Enables meta\u2011programming (e.g. listing supported mutations) in tooling/docs.\r\n */\r\nconst MUTATION_DISPATCH: Record<\r\n  string,\r\n  (this: Network, method?: any) => void\r\n> = {\r\n  ADD_NODE: _addNode,\r\n  SUB_NODE: _subNode,\r\n  ADD_CONN: _addConn,\r\n  SUB_CONN: _subConn,\r\n  MOD_WEIGHT: _modWeight,\r\n  MOD_BIAS: _modBias,\r\n  MOD_ACTIVATION: _modActivation,\r\n  ADD_SELF_CONN: _addSelfConn,\r\n  SUB_SELF_CONN: _subSelfConn,\r\n  ADD_GATE: _addGate,\r\n  SUB_GATE: _subGate,\r\n  ADD_BACK_CONN: _addBackConn,\r\n  SUB_BACK_CONN: _subBackConn,\r\n  SWAP_NODES: _swapNodes,\r\n  ADD_LSTM_NODE: _addLSTMNode,\r\n  ADD_GRU_NODE: _addGRUNode,\r\n  REINIT_WEIGHT: _reinitWeight,\r\n  BATCH_NORM: _batchNorm,\r\n};\r\n\r\n/**\r\n * Public entry point: apply a single mutation operator to the network.\r\n *\r\n * Steps:\r\n *  1. Validate the supplied method (enum value or descriptor object).\r\n *  2. Resolve helper implementation from the dispatch map (supports objects exposing name/type/identity).\r\n *  3. Invoke helper (passing through method for parameterized operators).\r\n *  4. Flag topology caches dirty so ordering / slabs rebuild lazily.\r\n *\r\n * Accepts either the raw enum value (e.g. `mutation.ADD_NODE`) or an object carrying an\r\n * identifying `name | type | identity` field allowing future parameterization without breaking call sites.\r\n *\r\n * @param this Network instance (bound).\r\n * @param method Mutation enum value or descriptor object.\r\n */\r\nexport function mutateImpl(this: Network, method: any): void {\r\n  if (method == null) throw new Error('No (correct) mutate method given!');\r\n\r\n  // Some mutation method objects may contain additional config but carry an identity equal to enum value.\r\n  let key: string | undefined;\r\n  if (typeof method === 'string') key = method;\r\n  else key = method?.name ?? method?.type ?? method?.identity;\r\n  if (!key) {\r\n    // Fallback: identity match against exported mutation objects\r\n    for (const k in mutation) {\r\n      if (method === (mutation as any)[k]) {\r\n        key = k;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  const fn = key ? MUTATION_DISPATCH[key] : undefined;\r\n  if (!fn) {\r\n    if (config.warnings) {\r\n      // eslint-disable-next-line no-console\r\n      console.warn('[mutate] Unknown mutation method ignored:', key);\r\n    }\r\n    return; // graceful no-op for invalid method objects\r\n  }\r\n  fn.call(this, method);\r\n  (this as any)._topoDirty = true; // Mark topology/order caches invalid.\r\n}\r\n\r\n// ======================= Individual mutation helpers ======================= //\r\n\r\n/**\r\n * ADD_NODE: Insert a new hidden node by splitting an existing connection.\r\n *\r\n * Deterministic test mode (config.deterministicChainMode):\r\n *  - Maintain an internal linear chain (input \u2192 hidden* \u2192 output).\r\n *  - Always split the chain's terminal edge, guaranteeing depth +1 per call.\r\n *  - Prune side edges from chain nodes to keep depth measurement unambiguous.\r\n *\r\n * Standard evolutionary mode:\r\n *  - Sample a random existing connection and perform the classical NEAT split.\r\n *\r\n * Core algorithm (stochastic variant):\r\n *  1. Pick connection (random).\r\n *  2. Disconnect it (preserve any gater reference).\r\n *  3. Create hidden node (random activation mutation).\r\n *  4. Insert before output tail to preserve ordering invariants.\r\n *  5. Connect source\u2192hidden and hidden\u2192target.\r\n *  6. Reassign gater uniformly to one of the new edges.\r\n */\r\nfunction _addNode(this: Network): void {\r\n  const internal = this as any;\r\n  if (internal._enforceAcyclic) internal._topoDirty = true;\r\n\r\n  // Deterministic linear chain growth: always split the terminal edge of a persisted chain.\r\n  if (config.deterministicChainMode) {\r\n    const inputNode = this.nodes.find((n) => n.type === 'input');\r\n    const outputNode = this.nodes.find((n) => n.type === 'output');\r\n    if (!inputNode || !outputNode) return;\r\n    // Initialize chain & seed direct edge only once (first invocation) so subsequent splits extend depth.\r\n    if (!internal._detChain) {\r\n      if (\r\n        !this.connections.some(\r\n          (c) => c.from === inputNode && c.to === outputNode\r\n        )\r\n      ) {\r\n        this.connect(inputNode, outputNode);\r\n      }\r\n      internal._detChain = [inputNode]; // store chain nodes (excluding output)\r\n    }\r\n    const chain: any[] = internal._detChain;\r\n    const tail = chain[chain.length - 1];\r\n    // Ensure tail -> output edge exists (recreate if pruned earlier)\r\n    let terminal = this.connections.find(\r\n      (c) => c.from === tail && c.to === outputNode\r\n    );\r\n    if (!terminal) terminal = this.connect(tail, outputNode)[0];\r\n    const prevGater = terminal.gater;\r\n    this.disconnect(terminal.from, terminal.to);\r\n    const hidden = new Node('hidden', undefined, internal._rand);\r\n    hidden.mutate(mutation.MOD_ACTIVATION);\r\n    const outIndex = this.nodes.indexOf(outputNode);\r\n    const insertIndex = Math.min(outIndex, this.nodes.length - this.output);\r\n    this.nodes.splice(insertIndex, 0, hidden);\r\n    internal._nodeIndexDirty = true;\r\n    const c1 = this.connect(tail, hidden)[0];\r\n    const c2 = this.connect(hidden, outputNode)[0];\r\n    chain.push(hidden);\r\n    internal._preferredChainEdge = c2; // maintain legacy pointer for opportunistic logic elsewhere\r\n    if (prevGater) this.gate(prevGater, internal._rand() >= 0.5 ? c1 : c2);\r\n    // Prune any extra outgoing edges from chain nodes so path stays linear & depth metric stable.\r\n    for (let i = 0; i < chain.length; i++) {\r\n      const node = chain[i];\r\n      const target = i + 1 < chain.length ? chain[i + 1] : outputNode;\r\n      const keep = node.connections.out.find((e: any) => e.to === target);\r\n      if (keep) {\r\n        for (const extra of node.connections.out.slice()) {\r\n          if (extra !== keep) {\r\n            try {\r\n              this.disconnect(extra.from, extra.to);\r\n            } catch {}\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return; // done deterministic path\r\n  }\r\n\r\n  // Non-deterministic (original) behaviour: split a random connection. Abort if no connections yet.\r\n  if (this.connections.length === 0) {\r\n    // If no connections (fresh network), proactively create a random input->output edge to enable future splits.\r\n    const input = this.nodes.find((n) => n.type === 'input');\r\n    const output = this.nodes.find((n) => n.type === 'output');\r\n    if (input && output) this.connect(input, output);\r\n    else return;\r\n  }\r\n  const connection = this.connections[\r\n    Math.floor(internal._rand() * this.connections.length)\r\n  ];\r\n  if (!connection) return;\r\n  const prevGater = connection.gater;\r\n  this.disconnect(connection.from, connection.to);\r\n  const hidden = new Node('hidden', undefined, internal._rand);\r\n  hidden.mutate(mutation.MOD_ACTIVATION);\r\n  const targetIndex = this.nodes.indexOf(connection.to);\r\n  const insertIndex = Math.min(targetIndex, this.nodes.length - this.output);\r\n  this.nodes.splice(insertIndex, 0, hidden);\r\n  internal._nodeIndexDirty = true;\r\n  const c1 = this.connect(connection.from, hidden)[0];\r\n  const c2 = this.connect(hidden, connection.to)[0];\r\n  internal._preferredChainEdge = c2;\r\n  if (prevGater) this.gate(prevGater, internal._rand() >= 0.5 ? c1 : c2);\r\n}\r\n\r\n/**\r\n * SUB_NODE: Remove a random hidden node (if any remain).\r\n * After removal a tiny deterministic weight nudge encourages observable phenotype change in tests.\r\n */\r\nfunction _subNode(this: Network): void {\r\n  const hidden = this.nodes.filter((n) => n.type === 'hidden');\r\n  if (hidden.length === 0) {\r\n    if (config.warnings) console.warn('No hidden nodes left to remove!');\r\n    return;\r\n  }\r\n  const internal = this as any;\r\n  const victim = hidden[Math.floor(internal._rand() * hidden.length)];\r\n  this.remove(victim);\r\n  // Nudge a weight slightly so tests expecting output change are robust.\r\n  const anyConn = this.connections[0];\r\n  if (anyConn) anyConn.weight += 1e-4;\r\n}\r\n\r\n/**\r\n * ADD_CONN: Add a new forward (acyclic) connection between two previously unconnected nodes.\r\n * Recurrent edges are handled separately by ADD_BACK_CONN.\r\n */\r\nfunction _addConn(this: Network): void {\r\n  const netInternal = this as any;\r\n  if (netInternal._enforceAcyclic) netInternal._topoDirty = true;\r\n  /** Candidate pairs [source,target]. */\r\n  const forwardConnectionCandidates: Array<[any, any]> = [];\r\n  for (\r\n    let sourceIndex = 0;\r\n    sourceIndex < this.nodes.length - this.output;\r\n    sourceIndex++\r\n  ) {\r\n    const sourceNode = this.nodes[sourceIndex];\r\n    for (\r\n      let targetIndex = Math.max(sourceIndex + 1, this.input);\r\n      targetIndex < this.nodes.length;\r\n      targetIndex++\r\n    ) {\r\n      const targetNode = this.nodes[targetIndex];\r\n      if (!sourceNode.isProjectingTo(targetNode))\r\n        forwardConnectionCandidates.push([sourceNode, targetNode]);\r\n    }\r\n  }\r\n  if (forwardConnectionCandidates.length === 0) return;\r\n  /** Selected pair to connect. */\r\n  const selectedPair =\r\n    forwardConnectionCandidates[\r\n      Math.floor(netInternal._rand() * forwardConnectionCandidates.length)\r\n    ];\r\n  this.connect(selectedPair[0], selectedPair[1]);\r\n}\r\n\r\n/**\r\n * SUB_CONN: Remove a forward connection chosen under redundancy heuristics to avoid disconnects.\r\n */\r\nfunction _subConn(this: Network): void {\r\n  const netInternal = this as any;\r\n  /** Candidate removable forward connections. */\r\n  const removableForwardConnections = this.connections.filter(\r\n    (candidateConn) => {\r\n      const sourceHasMultipleOutgoing =\r\n        candidateConn.from.connections.out.length > 1;\r\n      const targetHasMultipleIncoming =\r\n        candidateConn.to.connections.in.length > 1;\r\n      const targetLayerPeers = this.nodes.filter(\r\n        (n) =>\r\n          n.type === candidateConn.to.type &&\r\n          Math.abs(\r\n            this.nodes.indexOf(n) - this.nodes.indexOf(candidateConn.to)\r\n          ) < Math.max(this.input, this.output)\r\n      );\r\n      let wouldDisconnectLayerPeerGroup = false;\r\n      if (targetLayerPeers.length > 0) {\r\n        const peerConnectionsFromSource = this.connections.filter(\r\n          (c) =>\r\n            c.from === candidateConn.from && targetLayerPeers.includes(c.to)\r\n        );\r\n        if (peerConnectionsFromSource.length <= 1)\r\n          wouldDisconnectLayerPeerGroup = true;\r\n      }\r\n      return (\r\n        sourceHasMultipleOutgoing &&\r\n        targetHasMultipleIncoming &&\r\n        this.nodes.indexOf(candidateConn.to) >\r\n          this.nodes.indexOf(candidateConn.from) &&\r\n        !wouldDisconnectLayerPeerGroup\r\n      );\r\n    }\r\n  );\r\n  if (removableForwardConnections.length === 0) return;\r\n  /** Connection chosen for removal. */\r\n  const connectionToRemove =\r\n    removableForwardConnections[\r\n      Math.floor(netInternal._rand() * removableForwardConnections.length)\r\n    ];\r\n  this.disconnect(connectionToRemove.from, connectionToRemove.to);\r\n}\r\n\r\n/**\r\n * MOD_WEIGHT: Perturb a single (possibly self) connection weight by uniform delta in [min,max].\r\n */\r\nfunction _modWeight(this: Network, method: any): void {\r\n  /** Combined list of normal and self connections. */\r\n  const allConnections = this.connections.concat(this.selfconns);\r\n  if (allConnections.length === 0) return;\r\n  /** Random connection to perturb. */\r\n  const connectionToPerturb =\r\n    allConnections[Math.floor((this as any)._rand() * allConnections.length)];\r\n  /** Delta sampled uniformly from [min,max]. */\r\n  const modification =\r\n    (this as any)._rand() * (method.max - method.min) + method.min;\r\n  connectionToPerturb.weight += modification;\r\n}\r\n\r\n/**\r\n * MOD_BIAS: Delegate to node.mutate to adjust bias of a random non\u2011input node.\r\n */\r\nfunction _modBias(this: Network, method: any): void {\r\n  if (this.nodes.length <= this.input) return;\r\n  /** Index of target node (excluding inputs). */\r\n  const targetNodeIndex = Math.floor(\r\n    (this as any)._rand() * (this.nodes.length - this.input) + this.input\r\n  );\r\n  /** Selected node for bias mutation. */\r\n  const nodeForBiasMutation = this.nodes[targetNodeIndex];\r\n  nodeForBiasMutation.mutate(method);\r\n}\r\n\r\n/**\r\n * MOD_ACTIVATION: Swap activation (squash) of a random eligible node; may exclude outputs.\r\n */\r\nfunction _modActivation(this: Network, method: any): void {\r\n  /** Whether output nodes may be mutated. */\r\n  const canMutateOutput = method.mutateOutput ?? true;\r\n  /** Count of nodes available for mutation. */\r\n  const numMutableNodes =\r\n    this.nodes.length - this.input - (canMutateOutput ? 0 : this.output);\r\n  if (numMutableNodes <= 0) {\r\n    if (config.warnings)\r\n      console.warn(\r\n        'No nodes available for activation function mutation based on config.'\r\n      );\r\n    return;\r\n  }\r\n  /** Index of chosen node. */\r\n  const targetNodeIndex = Math.floor(\r\n    (this as any)._rand() * numMutableNodes + this.input\r\n  );\r\n  /** Target node. */\r\n  const targetNode = this.nodes[targetNodeIndex];\r\n  targetNode.mutate(method);\r\n}\r\n\r\n/**\r\n * ADD_SELF_CONN: Add a self loop to a random eligible node (only when cycles allowed).\r\n */\r\nfunction _addSelfConn(this: Network): void {\r\n  const netInternal = this as any;\r\n  if (netInternal._enforceAcyclic) return;\r\n  /** Nodes without an existing self connection (excluding inputs). */\r\n  const nodesWithoutSelfLoop = this.nodes.filter(\r\n    (n, idx) => idx >= this.input && n.connections.self.length === 0\r\n  );\r\n  if (nodesWithoutSelfLoop.length === 0) {\r\n    if (config.warnings)\r\n      console.warn('All eligible nodes already have self-connections.');\r\n    return;\r\n  }\r\n  /** Node selected to receive self loop. */\r\n  const nodeReceivingSelfLoop =\r\n    nodesWithoutSelfLoop[\r\n      Math.floor(netInternal._rand() * nodesWithoutSelfLoop.length)\r\n    ];\r\n  this.connect(nodeReceivingSelfLoop, nodeReceivingSelfLoop);\r\n}\r\n\r\n/**\r\n * SUB_SELF_CONN: Remove a random existing self loop.\r\n */\r\nfunction _subSelfConn(this: Network): void {\r\n  if (this.selfconns.length === 0) {\r\n    if (config.warnings) console.warn('No self-connections exist to remove.');\r\n    return;\r\n  }\r\n  /** Chosen self connection for removal. */\r\n  const selfConnectionToRemove = this.selfconns[\r\n    Math.floor((this as any)._rand() * this.selfconns.length)\r\n  ];\r\n  this.disconnect(selfConnectionToRemove.from, selfConnectionToRemove.to);\r\n}\r\n\r\n/**\r\n * ADD_GATE: Assign a random (hidden/output) node to gate a random ungated connection.\r\n */\r\nfunction _addGate(this: Network): void {\r\n  const netInternal = this as any;\r\n  /** All connections (including self connections). */\r\n  const allConnectionsIncludingSelf = this.connections.concat(this.selfconns);\r\n  /** Ungated connection candidates. */\r\n  const ungatedConnectionCandidates = allConnectionsIncludingSelf.filter(\r\n    (c: any) => c.gater === null\r\n  );\r\n  if (\r\n    ungatedConnectionCandidates.length === 0 ||\r\n    this.nodes.length <= this.input\r\n  ) {\r\n    if (config.warnings) console.warn('All connections are already gated.');\r\n    return;\r\n  }\r\n  /** Index for gating node (hidden or output). */\r\n  const gatingNodeIndex = Math.floor(\r\n    netInternal._rand() * (this.nodes.length - this.input) + this.input\r\n  );\r\n  /** Gating node. */\r\n  const gatingNode = this.nodes[gatingNodeIndex];\r\n  /** Connection to gate. */\r\n  const connectionToGate =\r\n    ungatedConnectionCandidates[\r\n      Math.floor(netInternal._rand() * ungatedConnectionCandidates.length)\r\n    ];\r\n  this.gate(gatingNode, connectionToGate);\r\n}\r\n\r\n/**\r\n * SUB_GATE: Remove gating from a random previously gated connection.\r\n */\r\nfunction _subGate(this: Network): void {\r\n  if (this.gates.length === 0) {\r\n    if (config.warnings) console.warn('No gated connections to ungate.');\r\n    return;\r\n  }\r\n  /** Random gated connection reference. */\r\n  const gatedConnectionIndex = Math.floor(\r\n    (this as any)._rand() * this.gates.length\r\n  );\r\n  const gatedConnection = this.gates[gatedConnectionIndex];\r\n  this.ungate(gatedConnection);\r\n}\r\n\r\n/**\r\n * ADD_BACK_CONN: Add a backward (recurrent) connection (acyclic mode must be off).\r\n */\r\nfunction _addBackConn(this: Network): void {\r\n  const netInternal = this as any;\r\n  if (netInternal._enforceAcyclic) return;\r\n  /** Candidate backward pairs [laterNode, earlierNode]. */\r\n  const backwardConnectionCandidates: Array<[any, any]> = [];\r\n  for (\r\n    let laterIndex = this.input;\r\n    laterIndex < this.nodes.length;\r\n    laterIndex++\r\n  ) {\r\n    const laterNode = this.nodes[laterIndex];\r\n    for (\r\n      let earlierIndex = this.input;\r\n      earlierIndex < laterIndex;\r\n      earlierIndex++\r\n    ) {\r\n      const earlierNode = this.nodes[earlierIndex];\r\n      if (!laterNode.isProjectingTo(earlierNode))\r\n        backwardConnectionCandidates.push([laterNode, earlierNode]);\r\n    }\r\n  }\r\n  if (backwardConnectionCandidates.length === 0) return;\r\n  /** Chosen backward pair. */\r\n  const selectedBackwardPair =\r\n    backwardConnectionCandidates[\r\n      Math.floor(netInternal._rand() * backwardConnectionCandidates.length)\r\n    ];\r\n  this.connect(selectedBackwardPair[0], selectedBackwardPair[1]);\r\n}\r\n\r\n/**\r\n * SUB_BACK_CONN: Remove a backward connection meeting redundancy heuristics.\r\n */\r\nfunction _subBackConn(this: Network): void {\r\n  /** Candidate backward connections to remove. */\r\n  const removableBackwardConnections = this.connections.filter(\r\n    (candidateConn) =>\r\n      candidateConn.from.connections.out.length > 1 &&\r\n      candidateConn.to.connections.in.length > 1 &&\r\n      this.nodes.indexOf(candidateConn.from) >\r\n        this.nodes.indexOf(candidateConn.to)\r\n  );\r\n  if (removableBackwardConnections.length === 0) return;\r\n  /** Selected backward connection. */\r\n  const backwardConnectionToRemove =\r\n    removableBackwardConnections[\r\n      Math.floor((this as any)._rand() * removableBackwardConnections.length)\r\n    ];\r\n  this.disconnect(\r\n    backwardConnectionToRemove.from,\r\n    backwardConnectionToRemove.to\r\n  );\r\n}\r\n\r\n/**\r\n * SWAP_NODES: Exchange bias & activation function between two random eligible nodes.\r\n */\r\nfunction _swapNodes(this: Network, method: any): void {\r\n  const netInternal = this as any;\r\n  /** Whether output nodes may be included. */\r\n  const canSwapOutput = method.mutateOutput ?? true;\r\n  /** Number of nodes eligible for swapping. */\r\n  const numSwappableNodes =\r\n    this.nodes.length - this.input - (canSwapOutput ? 0 : this.output);\r\n  if (numSwappableNodes < 2) return;\r\n  /** First random index. */\r\n  let firstNodeIndex = Math.floor(\r\n    netInternal._rand() * numSwappableNodes + this.input\r\n  );\r\n  /** Second random index (distinct). */\r\n  let secondNodeIndex = Math.floor(\r\n    netInternal._rand() * numSwappableNodes + this.input\r\n  );\r\n  while (firstNodeIndex === secondNodeIndex)\r\n    secondNodeIndex = Math.floor(\r\n      netInternal._rand() * numSwappableNodes + this.input\r\n    );\r\n  /** First node. */\r\n  const firstNode = this.nodes[firstNodeIndex];\r\n  /** Second node. */\r\n  const secondNode = this.nodes[secondNodeIndex];\r\n  /** Temporary store for bias before swap. */\r\n  const tempBias = firstNode.bias;\r\n  /** Temporary store for activation function before swap. */\r\n  const tempSquash = firstNode.squash;\r\n  firstNode.bias = secondNode.bias;\r\n  firstNode.squash = secondNode.squash;\r\n  secondNode.bias = tempBias;\r\n  secondNode.squash = tempSquash;\r\n}\r\n\r\n/**\r\n * ADD_LSTM_NODE: Replace a random connection with a minimal 1\u2011unit LSTM block (macro mutation).\r\n */\r\nfunction _addLSTMNode(this: Network): void {\r\n  const netInternal = this as any;\r\n  if (netInternal._enforceAcyclic) return;\r\n  if (this.connections.length === 0) return;\r\n  /** Connection selected to expand into an LSTM block. */\r\n  const connectionToExpand = this.connections[\r\n    Math.floor(Math.random() * this.connections.length)\r\n  ];\r\n  /** Original gater to reapply to new outgoing edge. */\r\n  const gaterLSTM = connectionToExpand.gater;\r\n  this.disconnect(connectionToExpand.from, connectionToExpand.to);\r\n  // Dynamic import of layer factory (kept lazy to avoid circular refs if any).\r\n  const Layer = require('../layer').default;\r\n  const lstmLayer = Layer.lstm(1);\r\n  // Convert produced layer's nodes to hidden and append to network node list.\r\n  lstmLayer.nodes.forEach((n: any) => {\r\n    n.type = 'hidden';\r\n    this.nodes.push(n);\r\n  });\r\n  // Reconnect using first internal node as entry & layer output node as exit.\r\n  this.connect(connectionToExpand.from, lstmLayer.nodes[0]);\r\n  this.connect(lstmLayer.output.nodes[0], connectionToExpand.to);\r\n  if (gaterLSTM)\r\n    this.gate(gaterLSTM, this.connections[this.connections.length - 1]);\r\n}\r\n\r\n/**\r\n * ADD_GRU_NODE: Replace a random connection with a minimal 1\u2011unit GRU block.\r\n */\r\nfunction _addGRUNode(this: Network): void {\r\n  const netInternal = this as any;\r\n  if (netInternal._enforceAcyclic) return;\r\n  if (this.connections.length === 0) return;\r\n  /** Connection selected to expand into a GRU block. */\r\n  const connectionToExpand = this.connections[\r\n    Math.floor(Math.random() * this.connections.length)\r\n  ];\r\n  /** Original gater (if any). */\r\n  const gaterGRU = connectionToExpand.gater;\r\n  this.disconnect(connectionToExpand.from, connectionToExpand.to);\r\n  const Layer = require('../layer').default;\r\n  const gruLayer = Layer.gru(1);\r\n  gruLayer.nodes.forEach((n: any) => {\r\n    n.type = 'hidden';\r\n    this.nodes.push(n);\r\n  });\r\n  this.connect(connectionToExpand.from, gruLayer.nodes[0]);\r\n  this.connect(gruLayer.output.nodes[0], connectionToExpand.to);\r\n  if (gaterGRU)\r\n    this.gate(gaterGRU, this.connections[this.connections.length - 1]);\r\n}\r\n\r\n/**\r\n * REINIT_WEIGHT: Reinitialize all incoming/outgoing/self connection weights for a random node.\r\n * Useful as a heavy mutation to escape local minima. Falls back silently if no eligible node.\r\n */\r\nfunction _reinitWeight(this: Network, method: any): void {\r\n  if (this.nodes.length <= this.input) return;\r\n  const internal = this as any;\r\n  const idx = Math.floor(\r\n    internal._rand() * (this.nodes.length - this.input) + this.input\r\n  );\r\n  const node = this.nodes[idx];\r\n  const min = method?.min ?? -1;\r\n  const max = method?.max ?? 1;\r\n  const sample = () => internal._rand() * (max - min) + min;\r\n  // Incoming\r\n  for (const c of node.connections.in) c.weight = sample();\r\n  // Outgoing\r\n  for (const c of node.connections.out) c.weight = sample();\r\n  // Self\r\n  for (const c of node.connections.self) c.weight = sample();\r\n}\r\n\r\n/**\r\n * BATCH_NORM: Placeholder mutation \u2013 marks a random hidden node with a flag for potential\r\n * future batch normalization integration. Currently a no-op beyond tagging.\r\n */\r\nfunction _batchNorm(this: Network): void {\r\n  const hidden = this.nodes.filter((n) => n.type === 'hidden');\r\n  if (!hidden.length) return;\r\n  const internal = this as any;\r\n  const node = hidden[Math.floor(internal._rand() * hidden.length)] as any;\r\n  node._batchNorm = true; // simple tag; downstream training code could act on this.\r\n}\r\n", "/**\r\n * Training pipeline utilities (migrated from legacy architecture/network.train.ts).\r\n *\r\n * Provides:\r\n *  - Gradient clipping (global / layerwise; norm / percentile variants).\r\n *  - Mini & micro-batch gradient accumulation.\r\n *  - Optimizer step dispatch (SGD + adaptive optimizers + lookahead wrapper).\r\n *  - Simple mixed precision dynamic loss scaling (overflow detection heuristic).\r\n *  - Multiple moving-average smoothing strategies for error monitoring (SMA, EMA, adaptive EMA,\r\n *    median, gaussian, trimmed mean, WMA) plus separate plateau averaging.\r\n *  - Early stopping, schedule hooks, pruning hooks, and checkpoint callbacks.\r\n *\r\n * Notes:\r\n *  - This module intentionally keeps imperative style for clarity/perf (avoids heap churn in hot loops).\r\n *  - Refactor changes here are documentation & naming only; numerical behavior preserved.\r\n */\r\nimport * as methods from '../../methods/methods';\r\nimport { config } from '../../config';\r\nimport type Network from '../network';\r\n\r\n/**\r\n * -----------------------------------------------------------------------------\r\n * Internal Type Definitions (documentation only; optional for callers)\r\n * -----------------------------------------------------------------------------\r\n */\r\n/** Cost function signature used by training. */\r\nexport type CostFunction = (target: number[], output: number[]) => number;\r\n\r\n/** Gradient clipping configuration accepted by options.gradientClip. */\r\nexport interface GradientClipConfig {\r\n  mode?: 'norm' | 'percentile' | 'layerwiseNorm' | 'layerwisePercentile';\r\n  /** Max L2 norm (for *Norm modes). */\r\n  maxNorm?: number;\r\n  /** Percentile threshold (0-100) for *Percentile modes (clamps absolute values). */\r\n  percentile?: number;\r\n  /** Whether to treat bias separately (currently informational flag \u2013 behavior parity preserved). */\r\n  separateBias?: boolean;\r\n}\r\n\r\n/** Mixed precision configuration. */\r\nexport interface MixedPrecisionDynamicConfig {\r\n  /** Minimum loss scale when scaling down after overflows. */\r\n  minScale?: number;\r\n  /** Maximum allowed loss scale for automatic increases. */\r\n  maxScale?: number;\r\n  /** Steps of stable (non-overflow) updates before doubling loss scale. */\r\n  increaseEvery?: number; // alias stableStepsForIncrease\r\n  /** Legacy alias: stable steps threshold for increase. */\r\n  stableStepsForIncrease?: number;\r\n}\r\nexport interface MixedPrecisionConfig {\r\n  /** Initial loss scale (larger -> more mantissa preservation but higher overflow risk). */\r\n  lossScale?: number;\r\n  /** Enable dynamic (auto increase/decrease) logic. */\r\n  dynamic?: MixedPrecisionDynamicConfig;\r\n}\r\n\r\n/** Optimizer configuration (subset \u2013 delegated to node.applyBatchUpdatesWithOptimizer). */\r\nexport interface OptimizerConfigBase {\r\n  type: string; // normalized to lowercase\r\n  baseType?: string; // for lookahead\r\n  beta1?: number;\r\n  beta2?: number;\r\n  eps?: number;\r\n  weightDecay?: number;\r\n  momentum?: number;\r\n  la_k?: number; // lookahead sync interval\r\n  la_alpha?: number; // lookahead interpolation factor\r\n}\r\n\r\n/** Checkpoint callback spec. */\r\nexport interface CheckpointConfig {\r\n  /** Save final state each iteration. */\r\n  last?: boolean;\r\n  /** Save best (lowest error) state. */\r\n  best?: boolean;\r\n  /** Persist function invoked with metadata + serialized network. */\r\n  save: (payload: {\r\n    type: 'last' | 'best';\r\n    iteration: number;\r\n    error: number;\r\n    network: any;\r\n  }) => void;\r\n}\r\n\r\n/** Schedule hook executed every N iterations. */\r\nexport interface ScheduleConfig {\r\n  iterations: number; // frequency\r\n  function: (info: { error: number; iteration: number }) => void;\r\n}\r\n\r\n/** Metrics hook signature. */\r\nexport type MetricsHook = (m: {\r\n  iteration: number;\r\n  error: number;\r\n  plateauError?: number;\r\n  gradNorm: number;\r\n}) => void;\r\n\r\n/** Moving average strategy identifiers. */\r\nexport type MovingAverageType =\r\n  | 'sma'\r\n  | 'ema'\r\n  | 'adaptive-ema'\r\n  | 'median'\r\n  | 'gaussian'\r\n  | 'trimmed'\r\n  | 'wma';\r\n\r\n/** Primary training options object (public shape). */\r\nexport interface TrainingOptions {\r\n  iterations?: number; // stopping condition: max passes\r\n  error?: number; // stopping condition: target monitored (smoothed) error\r\n  rate?: number; // base learning rate\r\n  momentum?: number; // momentum for SGD / sometimes consumed by wrappers\r\n  optimizer?: string | OptimizerConfigBase; // adaptive optimizer choice\r\n  dropout?: number; // dropout probability applied per forward (mutable net.dropout)\r\n  batchSize?: number; // mini-batch size; if > dataset length => error\r\n  accumulationSteps?: number; // gradient accumulation factor (micro-batches per optimizer step)\r\n  accumulationReduction?: 'average' | 'sum'; // scaling mode for accumulated gradients\r\n  gradientClip?: GradientClipConfig; // gradient clipping configuration\r\n  mixedPrecision?: boolean | MixedPrecisionConfig; // enable FP16-like scaling logic\r\n  cost?: CostFunction | { fn?: CostFunction; calculate?: CostFunction }; // cost interface variants\r\n  movingAverageWindow?: number; // smoothing window size\r\n  movingAverageType?: MovingAverageType; // smoothing algorithm\r\n  emaAlpha?: number; // override alpha for EMA\r\n  adaptiveEmaBaseAlpha?: number; // (not currently used \u2013 placeholder)\r\n  trimmedRatio?: number; // fraction dropped from each tail for trimmed mean (0..0.49)\r\n  plateauMovingAverageWindow?: number; // independent plateau window\r\n  plateauMovingAverageType?: MovingAverageType; // independent plateau strategy\r\n  plateauEmaAlpha?: number; // plateau EMA alpha override\r\n  earlyStopPatience?: number; // iterations with no improvement before stop\r\n  earlyStopMinDelta?: number; // required improvement beyond previous best\r\n  checkpoint?: CheckpointConfig; // persistence callbacks\r\n  schedule?: ScheduleConfig; // periodic hook\r\n  metricsHook?: MetricsHook; // telemetry per iteration\r\n}\r\n\r\n/** ---------------------------------------------------------------------------\r\n * Internal Helper Utilities (non-exported)\r\n * ---------------------------------------------------------------------------\r\n * These functions encapsulate cohesive sub-steps of the training pipeline so the\r\n * main exported functions remain readable while preserving original behavior.\r\n * Each helper is intentionally pure where reasonable or documents its side-effects.\r\n */\r\n\r\n/** State container for EMA / Adaptive EMA smoothing values. */\r\ninterface PrimarySmoothingState {\r\n  /** Classic EMA value (when movingAverageType === 'ema'). */\r\n  emaValue?: number;\r\n  /** Baseline EMA part of adaptive EMA (slower). */\r\n  adaptiveBaseEmaValue?: number;\r\n  /** Fast adaptive EMA (higher alpha under variance). */\r\n  adaptiveEmaValue?: number;\r\n}\r\n\r\n/** State container for plateau EMA smoothing. */\r\ninterface PlateauSmoothingState {\r\n  plateauEmaValue?: number;\r\n}\r\n\r\n/** Configuration passed to monitored (primary) smoothing computation. */\r\ninterface MonitoredSmoothingConfig {\r\n  type: MovingAverageType;\r\n  window: number;\r\n  emaAlpha?: number; // optional override (only for EMA types)\r\n  trimmedRatio?: number; // for trimmed mean strategy\r\n}\r\n\r\n/** Configuration for plateau smoothing computation. */\r\ninterface PlateauSmoothingConfig {\r\n  type: MovingAverageType;\r\n  window: number;\r\n  emaAlpha?: number;\r\n}\r\n\r\n/**\r\n * Compute the monitored (primary) smoothed error given recent raw errors.\r\n *\r\n * Behavior:\r\n *  - For SMA-like strategies uses the supplied window slice directly.\r\n *  - For EMA it mutates state.emaValue.\r\n *  - For adaptive-ema maintains dual EMA tracks inside state and returns the min for stability.\r\n *  - For median / gaussian / trimmed / wma applies algorithmic weighting as documented inline.\r\n *\r\n * Inputs:\r\n *  - trainError: Current raw mean error for this iteration.\r\n *  - recentErrors: Chronological array (oldest->newest) of last N raw errors.\r\n *  - cfg: Algorithm selection + parameters.\r\n *  - state: Mutable smoothing state (ema / adaptive fields updated in-place).\r\n *\r\n * Returns: Smoothed/monitored error metric (may equal trainError if no smoothing active).\r\n */\r\nfunction computeMonitoredError(\r\n  trainError: number,\r\n  recentErrors: number[],\r\n  cfg: MonitoredSmoothingConfig,\r\n  state: PrimarySmoothingState\r\n): number {\r\n  // Fast path: no smoothing window / algorithm requiring history.\r\n  if (cfg.window <= 1 && cfg.type !== 'ema' && cfg.type !== 'adaptive-ema') {\r\n    return trainError;\r\n  }\r\n  const type = cfg.type;\r\n  if (type === 'median') {\r\n    const sorted = [...recentErrors].sort((a, b) => a - b);\r\n    const midIndex = Math.floor(sorted.length / 2);\r\n    return sorted.length % 2\r\n      ? sorted[midIndex]\r\n      : (sorted[midIndex - 1] + sorted[midIndex]) / 2;\r\n  }\r\n  if (type === 'ema') {\r\n    // Standard exponential moving average.\r\n    if (state.emaValue == null) state.emaValue = trainError;\r\n    else\r\n      state.emaValue =\r\n        state.emaValue + cfg.emaAlpha! * (trainError - state.emaValue);\r\n    return state.emaValue;\r\n  }\r\n  if (type === 'adaptive-ema') {\r\n    // Adaptive EMA: baseline alpha + volatility-inflated alpha, final metric is more conservative (min).\r\n    const mean = recentErrors.reduce((a, b) => a + b, 0) / recentErrors.length;\r\n    const variance =\r\n      recentErrors.reduce((a, b) => a + (b - mean) * (b - mean), 0) /\r\n      recentErrors.length;\r\n    const baseAlpha = cfg.emaAlpha || 2 / (cfg.window + 1);\r\n    const varianceScaled = variance / Math.max(mean * mean, 1e-8);\r\n    const adaptiveAlpha = Math.min(\r\n      0.95,\r\n      Math.max(baseAlpha, baseAlpha * (1 + 2 * varianceScaled))\r\n    );\r\n    if (state.adaptiveBaseEmaValue == null) {\r\n      state.adaptiveBaseEmaValue = trainError;\r\n      state.adaptiveEmaValue = trainError;\r\n    } else {\r\n      state.adaptiveBaseEmaValue =\r\n        state.adaptiveBaseEmaValue +\r\n        baseAlpha * (trainError - state.adaptiveBaseEmaValue);\r\n      state.adaptiveEmaValue =\r\n        state.adaptiveEmaValue! +\r\n        adaptiveAlpha * (trainError - state.adaptiveEmaValue!);\r\n    }\r\n    return Math.min(state.adaptiveEmaValue!, state.adaptiveBaseEmaValue!);\r\n  }\r\n  if (type === 'gaussian') {\r\n    // Gaussian kernel weights centered at newest element (index length-1).\r\n    const sigma = cfg.window / 3 || 1; // heuristic: cover window ~3 sigma\r\n    let weightSum = 0;\r\n    let weightedAccumulator = 0;\r\n    const length = recentErrors.length;\r\n    for (let i = 0; i < length; i++) {\r\n      const weight = Math.exp(-0.5 * Math.pow((i - (length - 1)) / sigma, 2));\r\n      weightSum += weight;\r\n      weightedAccumulator += weight * recentErrors[i];\r\n    }\r\n    return weightedAccumulator / (weightSum || 1);\r\n  }\r\n  if (type === 'trimmed') {\r\n    // Trim symmetric tails before averaging to reduce outlier influence.\r\n    const ratio = Math.min(0.49, Math.max(0, cfg.trimmedRatio || 0.1));\r\n    const sorted = [...recentErrors].sort((a, b) => a - b);\r\n    const drop = Math.floor(sorted.length * ratio);\r\n    const trimmed = sorted.slice(drop, sorted.length - drop);\r\n    return trimmed.reduce((a, b) => a + b, 0) / (trimmed.length || 1);\r\n  }\r\n  if (type === 'wma') {\r\n    // Linear weighting (oldest weight=1 ... newest weight=n).\r\n    let weightSum = 0;\r\n    let weightedAccumulator = 0;\r\n    for (let i = 0; i < recentErrors.length; i++) {\r\n      const weight = i + 1;\r\n      weightSum += weight;\r\n      weightedAccumulator += weight * recentErrors[i];\r\n    }\r\n    return weightedAccumulator / (weightSum || 1);\r\n  }\r\n  // Default: arithmetic mean (SMA).\r\n  return recentErrors.reduce((a, b) => a + b, 0) / recentErrors.length;\r\n}\r\n\r\n/**\r\n * Compute plateau metric (may differ in strategy from primary monitored error).\r\n * Only algorithms actually supported for plateau in current pipeline are SMA, median and EMA.\r\n * Provided flexibility keeps room for extension; unsupported types silently fallback to mean.\r\n */\r\nfunction computePlateauMetric(\r\n  trainError: number,\r\n  plateauErrors: number[],\r\n  cfg: PlateauSmoothingConfig,\r\n  state: PlateauSmoothingState\r\n): number {\r\n  if (cfg.window <= 1 && cfg.type !== 'ema') return trainError;\r\n  if (cfg.type === 'median') {\r\n    const sorted = [...plateauErrors].sort((a, b) => a - b);\r\n    const mid = Math.floor(sorted.length / 2);\r\n    return sorted.length % 2\r\n      ? sorted[mid]\r\n      : (sorted[mid - 1] + sorted[mid]) / 2;\r\n  }\r\n  if (cfg.type === 'ema') {\r\n    if (state.plateauEmaValue == null) state.plateauEmaValue = trainError;\r\n    else\r\n      state.plateauEmaValue =\r\n        state.plateauEmaValue +\r\n        cfg.emaAlpha! * (trainError - state.plateauEmaValue);\r\n    return state.plateauEmaValue;\r\n  }\r\n  // Fallback default mean.\r\n  return plateauErrors.reduce((a, b) => a + b, 0) / plateauErrors.length;\r\n}\r\n\r\n// Internal export bundle (test-only usage) to enable direct branch coverage of smoothing helpers.\r\n// Marked with double underscore to discourage production use.\r\nexport const __trainingInternals = {\r\n  computeMonitoredError,\r\n  computePlateauMetric,\r\n};\r\n\r\n/**\r\n * Detect mixed precision overflow (NaN / Inf) in bias values if mixed precision enabled.\r\n * Side-effect: may clear internal trigger _forceNextOverflow.\r\n */\r\nfunction detectMixedPrecisionOverflow(net: Network, internalNet: any): boolean {\r\n  if (!internalNet._mixedPrecision.enabled) return false;\r\n  if (internalNet._forceNextOverflow) {\r\n    internalNet._forceNextOverflow = false;\r\n    return true;\r\n  }\r\n  let overflow = false;\r\n  net.nodes.forEach((node) => {\r\n    if ((node as any)._fp32Bias !== undefined) {\r\n      if (!Number.isFinite((node as any).bias)) overflow = true;\r\n    }\r\n  });\r\n  return overflow;\r\n}\r\n\r\n/** Zero-out accumulated gradient buffers after an overflow to discard invalid updates. */\r\nfunction zeroAccumulatedGradients(net: Network) {\r\n  net.nodes.forEach((node) => {\r\n    (node as any).connections.in.forEach((c: any) => {\r\n      c.totalDeltaWeight = 0;\r\n    });\r\n    (node as any).connections.self.forEach((c: any) => {\r\n      c.totalDeltaWeight = 0;\r\n    });\r\n    if (typeof (node as any).totalDeltaBias === 'number')\r\n      (node as any).totalDeltaBias = 0;\r\n    (node as any).previousDeltaBias = 0;\r\n  });\r\n}\r\n\r\n/** Divide accumulated gradients by accumulationSteps (average reduction mode). */\r\nfunction averageAccumulatedGradients(net: Network, accumulationSteps: number) {\r\n  if (accumulationSteps <= 1) return;\r\n  net.nodes.forEach((node) => {\r\n    (node as any).connections.in.forEach((c: any) => {\r\n      if (typeof c.totalDeltaWeight === 'number')\r\n        c.totalDeltaWeight /= accumulationSteps;\r\n    });\r\n    (node as any).connections.self.forEach((c: any) => {\r\n      if (typeof c.totalDeltaWeight === 'number')\r\n        c.totalDeltaWeight /= accumulationSteps;\r\n    });\r\n    if (typeof (node as any).totalDeltaBias === 'number')\r\n      (node as any).totalDeltaBias /= accumulationSteps;\r\n  });\r\n}\r\n\r\n/** Apply optimizer update step across all nodes; returns gradient L2 norm (approx). */\r\nfunction applyOptimizerStep(\r\n  net: Network,\r\n  optimizer: any,\r\n  currentRate: number,\r\n  momentum: number,\r\n  internalNet: any\r\n): number {\r\n  let sumSq = 0;\r\n  net.nodes.forEach((node) => {\r\n    if (node.type === 'input') return;\r\n    (node as any).applyBatchUpdatesWithOptimizer({\r\n      type: optimizer.type,\r\n      baseType: optimizer.baseType,\r\n      beta1: optimizer.beta1,\r\n      beta2: optimizer.beta2,\r\n      eps: optimizer.eps,\r\n      weightDecay: optimizer.weightDecay,\r\n      momentum: optimizer.momentum ?? momentum,\r\n      lrScale: currentRate,\r\n      t: internalNet._optimizerStep,\r\n      la_k: optimizer.la_k,\r\n      la_alpha: optimizer.la_alpha,\r\n    });\r\n    (node as any).connections.in.forEach((c: any) => {\r\n      if (typeof c.previousDeltaWeight === 'number')\r\n        sumSq += c.previousDeltaWeight * c.previousDeltaWeight;\r\n    });\r\n    (node as any).connections.self.forEach((c: any) => {\r\n      if (typeof c.previousDeltaWeight === 'number')\r\n        sumSq += c.previousDeltaWeight * c.previousDeltaWeight;\r\n    });\r\n  });\r\n  return Math.sqrt(sumSq);\r\n}\r\n\r\n/** Update dynamic loss scaling after a successful (non-overflow) optimizer step. */\r\nfunction maybeIncreaseLossScale(internalNet: any) {\r\n  internalNet._mixedPrecisionState.goodSteps++;\r\n  const incEvery = internalNet._mpIncreaseEvery || 200;\r\n  if (\r\n    internalNet._mixedPrecisionState.goodSteps >= incEvery &&\r\n    internalNet._mixedPrecision.lossScale <\r\n      internalNet._mixedPrecisionState.maxLossScale\r\n  ) {\r\n    internalNet._mixedPrecision.lossScale *= 2;\r\n    internalNet._mixedPrecisionState.goodSteps = 0;\r\n    internalNet._mixedPrecisionState.scaleUpEvents =\r\n      (internalNet._mixedPrecisionState.scaleUpEvents || 0) + 1;\r\n  }\r\n}\r\n\r\n/** Respond to a mixed precision overflow by shrinking loss scale & bookkeeping. */\r\nfunction handleOverflow(internalNet: any) {\r\n  internalNet._mixedPrecisionState.badSteps++;\r\n  internalNet._mixedPrecisionState.goodSteps = 0;\r\n  internalNet._mixedPrecision.lossScale = Math.max(\r\n    internalNet._mixedPrecisionState.minLossScale,\r\n    Math.floor(internalNet._mixedPrecision.lossScale / 2) || 1\r\n  );\r\n  internalNet._mixedPrecisionState.overflowCount =\r\n    (internalNet._mixedPrecisionState.overflowCount || 0) + 1;\r\n  internalNet._mixedPrecisionState.scaleDownEvents =\r\n    (internalNet._mixedPrecisionState.scaleDownEvents || 0) + 1;\r\n  internalNet._lastOverflowStep = internalNet._optimizerStep;\r\n}\r\n\r\n/**\r\n * Apply gradient clipping to accumulated connection deltas / bias deltas.\r\n *\r\n * Modes:\r\n *  - norm / layerwiseNorm: L2 norm scaling (global vs per group).\r\n *  - percentile / layerwisePercentile: element-wise clamp at absolute percentile threshold.\r\n *\r\n * Grouping:\r\n *  - If layerwise* and net.layers exists -> each defined layer is a group.\r\n *  - Else if layerwise* -> each non-input node becomes its own group.\r\n *  - Otherwise a single global group containing all learnable params.\r\n */\r\nexport function applyGradientClippingImpl(\r\n  net: Network,\r\n  cfg: {\r\n    mode: 'norm' | 'percentile' | 'layerwiseNorm' | 'layerwisePercentile';\r\n    maxNorm?: number;\r\n    percentile?: number;\r\n  }\r\n) {\r\n  const internalNet = net as any;\r\n  /**\r\n   * Build arrays of gradient values grouped according to chosen clipping mode.\r\n   * Each group is later processed independently (layerwise modes) or as a single global set.\r\n   */\r\n  const collectGroups = () => {\r\n    const collected: number[][] = [];\r\n    if (cfg.mode.startsWith('layerwise')) {\r\n      if ((net as any).layers && (net as any).layers.length > 0) {\r\n        for (let li = 0; li < (net as any).layers.length; li++) {\r\n          const layer = (net as any).layers[li];\r\n          if (!layer || !layer.nodes) continue;\r\n          const groupVals: number[] = [];\r\n          layer.nodes.forEach((node: any) => {\r\n            if (!node || node.type === 'input') return;\r\n            node.connections.in.forEach((c: any) => {\r\n              if (typeof c.totalDeltaWeight === 'number')\r\n                groupVals.push(c.totalDeltaWeight);\r\n            });\r\n            node.connections.self.forEach((c: any) => {\r\n              if (typeof c.totalDeltaWeight === 'number')\r\n                groupVals.push(c.totalDeltaWeight);\r\n            });\r\n            if (typeof node.totalDeltaBias === 'number')\r\n              groupVals.push(node.totalDeltaBias);\r\n          });\r\n          if (groupVals.length) collected.push(groupVals);\r\n        }\r\n      } else {\r\n        net.nodes.forEach((node) => {\r\n          if (node.type === 'input') return;\r\n          const groupVals: number[] = [];\r\n          (node as any).connections.in.forEach((c: any) => {\r\n            if (typeof c.totalDeltaWeight === 'number')\r\n              groupVals.push(c.totalDeltaWeight);\r\n          });\r\n          (node as any).connections.self.forEach((c: any) => {\r\n            if (typeof c.totalDeltaWeight === 'number')\r\n              groupVals.push(c.totalDeltaWeight);\r\n          });\r\n          if (typeof (node as any).totalDeltaBias === 'number')\r\n            groupVals.push((node as any).totalDeltaBias);\r\n          if (groupVals.length) collected.push(groupVals);\r\n        });\r\n      }\r\n    } else {\r\n      const globalVals: number[] = [];\r\n      net.nodes.forEach((node) => {\r\n        (node as any).connections.in.forEach((c: any) => {\r\n          if (typeof c.totalDeltaWeight === 'number')\r\n            globalVals.push(c.totalDeltaWeight);\r\n        });\r\n        (node as any).connections.self.forEach((c: any) => {\r\n          if (typeof c.totalDeltaWeight === 'number')\r\n            globalVals.push(c.totalDeltaWeight);\r\n        });\r\n        if (typeof (node as any).totalDeltaBias === 'number')\r\n          globalVals.push((node as any).totalDeltaBias);\r\n      });\r\n      if (globalVals.length) collected.push(globalVals);\r\n    }\r\n    return collected;\r\n  };\r\n  /**\r\n   * Gradient groups discovered for clipping (size: 1 for global modes).\r\n   * Each entry is an array of parameter delta values belonging to a logical group (layer or node level).\r\n   */\r\n  const groups = collectGroups();\r\n  /** Tracking for diagnostics / potential external tooling. */\r\n  internalNet._lastGradClipGroupCount = groups.length;\r\n  /**\r\n   * Compute absolute percentile threshold (e.g. percentile=99 => value whose |value| is at the 99th percentile).\r\n   * Sorting by absolute value guarantees consistent clipping for symmetric distributions.\r\n   */\r\n  const computeAbsolutePercentileThreshold = (\r\n    values: number[],\r\n    percentile: number\r\n  ) => {\r\n    if (!values.length) return 0;\r\n    const sortedByAbs = [...values].sort((a, b) => Math.abs(a) - Math.abs(b));\r\n    const rank = Math.min(\r\n      sortedByAbs.length - 1,\r\n      Math.max(0, Math.floor((percentile / 100) * sortedByAbs.length - 1))\r\n    );\r\n    return Math.abs(sortedByAbs[rank]);\r\n  };\r\n  /**\r\n   * Iterate all learnable parameters applying a transform function.\r\n   * The transform receives the current value and the owning group so it can selectively scale only\r\n   * the active group (when computing per-group scaling factor yet iterating entire model).\r\n   */\r\n  const applyScale = (\r\n    scaleFn: (currentValue: number, owningGroup: number[]) => number\r\n  ) => {\r\n    let groupIndex = 0; // advances only for layerwise modes\r\n    net.nodes.forEach((node) => {\r\n      if (cfg.mode.startsWith('layerwise') && node.type === 'input') return; // skip input nodes in layerwise grouping\r\n      const activeGroup = cfg.mode.startsWith('layerwise')\r\n        ? groups[groupIndex++]\r\n        : groups[0];\r\n      (node as any).connections.in.forEach((c: any) => {\r\n        if (typeof c.totalDeltaWeight === 'number')\r\n          c.totalDeltaWeight = scaleFn(c.totalDeltaWeight, activeGroup);\r\n      });\r\n      (node as any).connections.self.forEach((c: any) => {\r\n        if (typeof c.totalDeltaWeight === 'number')\r\n          c.totalDeltaWeight = scaleFn(c.totalDeltaWeight, activeGroup);\r\n      });\r\n      if (typeof (node as any).totalDeltaBias === 'number')\r\n        (node as any).totalDeltaBias = scaleFn(\r\n          (node as any).totalDeltaBias,\r\n          activeGroup\r\n        );\r\n    });\r\n  };\r\n  if (cfg.mode === 'norm' || cfg.mode === 'layerwiseNorm') {\r\n    /** Maximum allowed L2 norm per group (or global). */\r\n    const maxAllowedNorm = cfg.maxNorm || 1;\r\n    groups.forEach((groupValues) => {\r\n      /** Current group L2 norm. */\r\n      const groupL2Norm = Math.sqrt(\r\n        groupValues.reduce((sum, v) => sum + v * v, 0)\r\n      );\r\n      if (groupL2Norm > maxAllowedNorm && groupL2Norm > 0) {\r\n        /** Scaling factor applied uniformly to bring norm to boundary. */\r\n        const normScaleFactor = maxAllowedNorm / groupL2Norm;\r\n        applyScale((currentValue, owningGroup) =>\r\n          owningGroup === groupValues\r\n            ? currentValue * normScaleFactor\r\n            : currentValue\r\n        );\r\n      }\r\n    });\r\n  } else if (cfg.mode === 'percentile' || cfg.mode === 'layerwisePercentile') {\r\n    /** Percentile specifying absolute magnitude cutoff (values above are clamped). */\r\n    const percentileSetting = cfg.percentile || 99;\r\n    groups.forEach((groupValues) => {\r\n      const percentileThreshold = computeAbsolutePercentileThreshold(\r\n        groupValues,\r\n        percentileSetting\r\n      );\r\n      if (percentileThreshold <= 0) return;\r\n      applyScale((currentValue, owningGroup) =>\r\n        owningGroup === groupValues &&\r\n        Math.abs(currentValue) > percentileThreshold\r\n          ? percentileThreshold * Math.sign(currentValue)\r\n          : currentValue\r\n      );\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Execute one full pass over dataset (epoch) with optional accumulation & adaptive optimizer.\r\n * Returns mean cost across processed samples.\r\n */\r\nexport function trainSetImpl(\r\n  net: Network,\r\n  set: { input: number[]; output: number[] }[],\r\n  batchSize: number,\r\n  accumulationSteps: number,\r\n  currentRate: number,\r\n  momentum: number,\r\n  regularization: any,\r\n  costFunction: (target: number[], output: number[]) => number,\r\n  optimizer?: any\r\n): number {\r\n  const internalNet = net as any;\r\n  /** Sum of raw (unsmoothed) cost values across valid samples. */\r\n  let cumulativeError = 0;\r\n  /** Number of samples processed in current mini-batch (resets after potential optimizer step). */\r\n  let batchSampleCount = 0;\r\n  /** Counter of micro-batches contributing to current accumulated gradient set. */\r\n  internalNet._gradAccumMicroBatches = 0;\r\n  /** Total number of dataset samples actually processed (dimension-valid). */\r\n  let totalProcessedSamples = 0;\r\n  /** Cached list of output layer nodes (backprop order requires targets). */\r\n  const outputNodes = net.nodes.filter((n) => n.type === 'output');\r\n  /** Unified cost evaluation function resolved from provided cost variant. */\r\n  let computeError: (t: number[], o: number[]) => number;\r\n  if (typeof costFunction === 'function') computeError = costFunction as any;\r\n  else if (\r\n    (costFunction as any) &&\r\n    typeof (costFunction as any).fn === 'function'\r\n  )\r\n    computeError = (costFunction as any).fn;\r\n  else if (\r\n    (costFunction as any) &&\r\n    typeof (costFunction as any).calculate === 'function'\r\n  )\r\n    computeError = (costFunction as any).calculate;\r\n  else computeError = () => 0;\r\n\r\n  for (let sampleIndex = 0; sampleIndex < set.length; sampleIndex++) {\r\n    /** Current training sample record (input + target). */\r\n    const dataPoint = set[sampleIndex];\r\n    /** Input feature vector (validated for dimension). */\r\n    const input = dataPoint.input;\r\n    /** Target output vector (validated for dimension). */\r\n    const target = dataPoint.output;\r\n    if (input.length !== net.input || target.length !== net.output) {\r\n      if (config.warnings)\r\n        console.warn(\r\n          `Data point ${sampleIndex} has incorrect dimensions (input: ${input.length}/${net.input}, output: ${target.length}/${net.output}), skipping.`\r\n        );\r\n      continue;\r\n    }\r\n    try {\r\n      // Forward pass with training flag (enables dropout / any stochastic layers).\r\n      const output = (net as any).activate(input, true);\r\n      if (optimizer && optimizer.type && optimizer.type !== 'sgd') {\r\n        // Accumulate gradients for adaptive optimizers (no immediate weight update inside propagate).\r\n        for (let outIndex = 0; outIndex < outputNodes.length; outIndex++)\r\n          (outputNodes[outIndex] as any).propagate(\r\n            currentRate,\r\n            momentum,\r\n            false,\r\n            regularization,\r\n            target[outIndex]\r\n          );\r\n        for (\r\n          let reverseIndex = net.nodes.length - 1;\r\n          reverseIndex >= 0;\r\n          reverseIndex--\r\n        ) {\r\n          const node = net.nodes[reverseIndex];\r\n          if (node.type === 'output' || node.type === 'input') continue;\r\n          (node as any).propagate(currentRate, momentum, false, regularization);\r\n        }\r\n      } else {\r\n        // SGD mode: propagate performs immediate parameter updates using deltas.\r\n        for (let outIndex = 0; outIndex < outputNodes.length; outIndex++)\r\n          (outputNodes[outIndex] as any).propagate(\r\n            currentRate,\r\n            momentum,\r\n            true,\r\n            regularization,\r\n            target[outIndex]\r\n          );\r\n        for (\r\n          let reverseIndex = net.nodes.length - 1;\r\n          reverseIndex >= 0;\r\n          reverseIndex--\r\n        ) {\r\n          const node = net.nodes[reverseIndex];\r\n          if (node.type === 'output' || node.type === 'input') continue;\r\n          (node as any).propagate(currentRate, momentum, true, regularization);\r\n        }\r\n      }\r\n      cumulativeError += computeError(target, output);\r\n      batchSampleCount++;\r\n      totalProcessedSamples++;\r\n    } catch (e: any) {\r\n      if (config.warnings)\r\n        console.warn(\r\n          `Error processing data point ${sampleIndex} (input: ${JSON.stringify(\r\n            input\r\n          )}): ${e.message}. Skipping.`\r\n        );\r\n    }\r\n    // Mini-batch / end-of-dataset flush condition.\r\n    if (\r\n      batchSampleCount > 0 &&\r\n      ((sampleIndex + 1) % batchSize === 0 || sampleIndex === set.length - 1)\r\n    ) {\r\n      if (optimizer && optimizer.type && optimizer.type !== 'sgd') {\r\n        // Only adaptive optimizers delay the step; vanilla SGD already updated weights per sample.\r\n        internalNet._gradAccumMicroBatches++;\r\n        /** True when we have accumulated sufficient micro-batches or reached dataset end. */\r\n        const readyForStep =\r\n          internalNet._gradAccumMicroBatches % accumulationSteps === 0 ||\r\n          sampleIndex === set.length - 1;\r\n        if (readyForStep) {\r\n          /** 1-based optimizer step counter (used for bias-correction terms by adaptive methods). */\r\n          internalNet._optimizerStep = (internalNet._optimizerStep || 0) + 1;\r\n          /** Detect overflow under mixed precision (NaN/Inf). */\r\n          const overflowDetected = detectMixedPrecisionOverflow(\r\n            net,\r\n            internalNet\r\n          );\r\n          if (overflowDetected) {\r\n            // Discard invalid gradients & shrink loss scale.\r\n            zeroAccumulatedGradients(net);\r\n            if (internalNet._mixedPrecision.enabled)\r\n              handleOverflow(internalNet);\r\n            internalNet._lastGradNorm = 0;\r\n          } else {\r\n            // Optional gradient clipping before optimizer math.\r\n            if (internalNet._currentGradClip)\r\n              applyGradientClippingImpl(net, internalNet._currentGradClip);\r\n            // Average accumulated micro-batch gradients if configured.\r\n            if (\r\n              accumulationSteps > 1 &&\r\n              internalNet._accumulationReduction === 'average'\r\n            ) {\r\n              averageAccumulatedGradients(net, accumulationSteps);\r\n            }\r\n            // Apply optimizer updates and compute gradient norm.\r\n            internalNet._lastGradNorm = applyOptimizerStep(\r\n              net,\r\n              optimizer,\r\n              currentRate,\r\n              momentum,\r\n              internalNet\r\n            );\r\n            // Dynamic loss scaling increase if conditions satisfied.\r\n            if (internalNet._mixedPrecision.enabled)\r\n              maybeIncreaseLossScale(internalNet);\r\n          }\r\n        }\r\n        batchSampleCount = 0; // reset mini-batch sample counter\r\n      }\r\n    }\r\n  }\r\n  if (internalNet._lastGradNorm == null) internalNet._lastGradNorm = 0;\r\n  return totalProcessedSamples > 0\r\n    ? cumulativeError / totalProcessedSamples\r\n    : 0;\r\n}\r\n\r\n/**\r\n * High-level training orchestration with early stopping, smoothing & callbacks.\r\n */\r\nexport function trainImpl(\r\n  net: Network,\r\n  set: { input: number[]; output: number[] }[],\r\n  options: TrainingOptions\r\n): { error: number; iterations: number; time: number } {\r\n  const internalNet = net as any;\r\n  if (\r\n    !set ||\r\n    set.length === 0 ||\r\n    set[0].input.length !== net.input ||\r\n    set[0].output.length !== net.output\r\n  ) {\r\n    throw new Error(\r\n      'Dataset is invalid or dimensions do not match network input/output size!'\r\n    );\r\n  }\r\n  options = options || {};\r\n  if (\r\n    typeof options.iterations === 'undefined' &&\r\n    typeof options.error === 'undefined'\r\n  ) {\r\n    if (config.warnings)\r\n      console.warn('Missing `iterations` or `error` option.');\r\n    throw new Error(\r\n      'Missing `iterations` or `error` option. Training requires a stopping condition.'\r\n    );\r\n  }\r\n  if (config.warnings) {\r\n    if (typeof options.rate === 'undefined') {\r\n      console.warn('Missing `rate` option');\r\n      console.warn('Missing `rate` option, using default learning rate 0.3.');\r\n    }\r\n    if (typeof options.iterations === 'undefined')\r\n      console.warn(\r\n        'Missing `iterations` option. Training will run potentially indefinitely until `error` threshold is met.'\r\n      );\r\n  }\r\n  /** Target monitored (smoothed) error threshold for early termination. */\r\n  let targetError = options.error ?? -Infinity;\r\n  /** Cost function (defaults to MSE) resolved from provided variant. */\r\n  const cost = options.cost || methods.Cost.mse;\r\n  if (\r\n    typeof cost !== 'function' &&\r\n    !(\r\n      typeof cost === 'object' &&\r\n      (typeof (cost as any).fn === 'function' ||\r\n        typeof (cost as any).calculate === 'function')\r\n    )\r\n  ) {\r\n    throw new Error('Invalid cost function provided to Network.train.');\r\n  }\r\n  /** Base learning rate used as scaling factor for optimizer weight updates. */\r\n  const baseRate = options.rate ?? 0.3;\r\n  /** Dropout probability applied each forward pass (0 disables). */\r\n  const dropout = options.dropout || 0;\r\n  if (dropout < 0 || dropout >= 1) throw new Error('dropout must be in [0,1)');\r\n  /** Momentum factor for SGD or reused by optimizers expecting momentum param. */\r\n  const momentum = options.momentum || 0;\r\n  /** Mini-batch size (#samples per gradient accumulation flush). */\r\n  const batchSize = options.batchSize || 1;\r\n  if (batchSize > set.length)\r\n    throw new Error('Batch size cannot be larger than the dataset length.');\r\n  /** Gradient accumulation factor (micro-batches per optimizer step). */\r\n  const accumulationSteps = options.accumulationSteps || 1;\r\n  internalNet._accumulationReduction =\r\n    options.accumulationReduction === 'sum' ? 'sum' : 'average';\r\n  if (accumulationSteps < 1 || !Number.isFinite(accumulationSteps))\r\n    throw new Error('accumulationSteps must be >=1');\r\n  if (options.gradientClip) {\r\n    const gc = options.gradientClip;\r\n    if (gc.mode)\r\n      internalNet._currentGradClip = {\r\n        mode: gc.mode,\r\n        maxNorm: gc.maxNorm,\r\n        percentile: gc.percentile,\r\n      } as any;\r\n    else if (typeof gc.maxNorm === 'number')\r\n      internalNet._currentGradClip = { mode: 'norm', maxNorm: gc.maxNorm };\r\n    else if (typeof gc.percentile === 'number')\r\n      internalNet._currentGradClip = {\r\n        mode: 'percentile',\r\n        percentile: gc.percentile,\r\n      } as any;\r\n    internalNet._gradClipSeparateBias = !!gc.separateBias;\r\n  } else {\r\n    internalNet._currentGradClip = undefined;\r\n    internalNet._gradClipSeparateBias = false;\r\n  }\r\n  if (options.mixedPrecision) {\r\n    const mp =\r\n      options.mixedPrecision === true\r\n        ? { lossScale: 1024 }\r\n        : options.mixedPrecision;\r\n    internalNet._mixedPrecision.enabled = true;\r\n    internalNet._mixedPrecision.lossScale = mp.lossScale || 1024;\r\n    const dyn = mp.dynamic || {};\r\n    internalNet._mixedPrecisionState.minLossScale = dyn.minScale || 1;\r\n    internalNet._mixedPrecisionState.maxLossScale = dyn.maxScale || 65536;\r\n    internalNet._mpIncreaseEvery =\r\n      dyn.increaseEvery || dyn.stableStepsForIncrease || 200;\r\n    net.connections.forEach((c) => {\r\n      (c as any)._fp32Weight = c.weight;\r\n    });\r\n    net.nodes.forEach((n) => {\r\n      if (n.type !== 'input') (n as any)._fp32Bias = n.bias;\r\n    });\r\n  } else {\r\n    internalNet._mixedPrecision.enabled = false;\r\n    internalNet._mixedPrecision.lossScale = 1;\r\n    internalNet._mpIncreaseEvery = 200;\r\n  }\r\n  /** Supported optimizer algorithm identifiers (lowercased). */\r\n  const allowedOptimizers = new Set([\r\n    'sgd',\r\n    'rmsprop',\r\n    'adagrad',\r\n    'adam',\r\n    'adamw',\r\n    'amsgrad',\r\n    'adamax',\r\n    'nadam',\r\n    'radam',\r\n    'lion',\r\n    'adabelief',\r\n    'lookahead',\r\n  ]);\r\n  /** Normalized optimizer configuration or undefined for pure SGD mode. */\r\n  let optimizerConfig: any = undefined;\r\n  if (typeof options.optimizer !== 'undefined') {\r\n    if (typeof options.optimizer === 'string')\r\n      optimizerConfig = { type: options.optimizer.toLowerCase() };\r\n    else if (\r\n      typeof options.optimizer === 'object' &&\r\n      options.optimizer !== null\r\n    ) {\r\n      optimizerConfig = { ...options.optimizer };\r\n      if (typeof optimizerConfig.type === 'string')\r\n        optimizerConfig.type = optimizerConfig.type.toLowerCase();\r\n    } else\r\n      throw new Error('Invalid optimizer option; must be string or object');\r\n    if (!allowedOptimizers.has(optimizerConfig.type))\r\n      throw new Error(`Unknown optimizer type: ${optimizerConfig.type}`);\r\n    if (optimizerConfig.type === 'lookahead') {\r\n      if (!optimizerConfig.baseType) optimizerConfig.baseType = 'adam';\r\n      if (optimizerConfig.baseType === 'lookahead')\r\n        throw new Error(\r\n          'Nested lookahead (baseType lookahead) is not supported'\r\n        );\r\n      if (!allowedOptimizers.has(optimizerConfig.baseType))\r\n        throw new Error(\r\n          `Unknown baseType for lookahead: ${optimizerConfig.baseType}`\r\n        );\r\n      optimizerConfig.la_k = optimizerConfig.la_k || 5;\r\n      optimizerConfig.la_alpha = optimizerConfig.la_alpha ?? 0.5;\r\n    }\r\n  }\r\n  /** Maximum training iterations permitted (guard against infinite loops w/ only error criterion). */\r\n  const iterations = options.iterations ?? Number.MAX_SAFE_INTEGER;\r\n  /** Wall-clock start time for duration metric. */\r\n  const start = Date.now();\r\n  /** Most recent monitored (smoothed) error value. */\r\n  let finalError = Infinity;\r\n  /** Window length for primary moving average smoothing. */\r\n  const movingAverageWindow = Math.max(1, options.movingAverageWindow || 1);\r\n  /** Selected smoothing algorithm kind. */\r\n  const movingAverageType = options.movingAverageType || 'sma';\r\n  /** EMA alpha (if EMA selected) computed via CMA formula unless explicitly overridden. */\r\n  const emaAlpha = (() => {\r\n    if (movingAverageType !== 'ema') return undefined;\r\n    if (options.emaAlpha && options.emaAlpha > 0 && options.emaAlpha <= 1)\r\n      return options.emaAlpha;\r\n    return 2 / (movingAverageWindow + 1);\r\n  })();\r\n  /** Separate window for plateau detection (defaults to primary window). */\r\n  const plateauWindow = Math.max(\r\n    1,\r\n    options.plateauMovingAverageWindow || movingAverageWindow\r\n  );\r\n  /** Smoothing algorithm used specifically for plateau (scheduler / early-stop) metrics. */\r\n  const plateauType = options.plateauMovingAverageType || movingAverageType;\r\n  /** EMA alpha for plateau smoothing if needed. */\r\n  const plateauEmaAlpha = (() => {\r\n    if (plateauType !== 'ema') return undefined;\r\n    if (\r\n      options.plateauEmaAlpha &&\r\n      options.plateauEmaAlpha > 0 &&\r\n      options.plateauEmaAlpha <= 1\r\n    )\r\n      return options.plateauEmaAlpha;\r\n    return 2 / (plateauWindow + 1);\r\n  })();\r\n  /** Max consecutive non-improving iterations tolerated before early stop (undefined => disabled). */\r\n  const earlyStopPatience = options.earlyStopPatience;\r\n  /** Minimal decrease required to qualify as improvement. */\r\n  const earlyStopMinDelta = options.earlyStopMinDelta || 0;\r\n  /** Best (lowest) monitored error observed so far. */\r\n  let bestError = Infinity;\r\n  /** Count of successive iterations without sufficient improvement. */\r\n  let noImproveCount = 0;\r\n  /** Capacity of circular buffer for recent errors. */\r\n  const recentErrorsCapacity = movingAverageWindow;\r\n  /** Circular buffer holding recent raw training errors (for smoothing). */\r\n  const recentErrorsBuf: number[] = new Array(recentErrorsCapacity);\r\n  /** Current number of valid entries in buffer (grows until capacity). */\r\n  let recentErrorsCount = 0;\r\n  /** Next write index within circular buffer. */\r\n  let recentErrorsWriteIdx = 0;\r\n  /** Push a new error value into circular buffer (overwriting oldest when full). */\r\n  const recentErrorsPush = (value: number) => {\r\n    if (recentErrorsCapacity === 1) {\r\n      recentErrorsBuf[0] = value;\r\n      recentErrorsCount = 1;\r\n      recentErrorsWriteIdx = 0;\r\n      return;\r\n    }\r\n    recentErrorsBuf[recentErrorsWriteIdx] = value;\r\n    recentErrorsWriteIdx = (recentErrorsWriteIdx + 1) % recentErrorsCapacity;\r\n    if (recentErrorsCount < recentErrorsCapacity) recentErrorsCount++;\r\n  };\r\n  /** Produce chronologically ordered snapshot of buffered errors. */\r\n  const recentErrorsChrono = (): number[] => {\r\n    if (recentErrorsCount === 0) return [];\r\n    if (recentErrorsCount < recentErrorsCapacity)\r\n      return recentErrorsBuf.slice(0, recentErrorsCount);\r\n    const out = new Array(recentErrorsCount);\r\n    const start = recentErrorsWriteIdx;\r\n    for (let i = 0; i < recentErrorsCount; i++)\r\n      out[i] = recentErrorsBuf[(start + i) % recentErrorsCapacity];\r\n    return out;\r\n  };\r\n  /** Exponential moving average state for classic EMA smoothing. */\r\n  let emaValue: number | undefined = undefined;\r\n  /** Base EMA state for adaptive EMA (lower variance baseline). */\r\n  let adaptiveBaseEmaValue: number | undefined = undefined;\r\n  /** Adaptive EMA state (higher alpha when volatility detected). */\r\n  let adaptiveEmaValue: number | undefined = undefined;\r\n  /** Capacity of plateau circular buffer. */\r\n  const plateauCapacity = plateauWindow;\r\n  /** Raw errors buffer for plateau smoothing. */\r\n  const plateauBuf: number[] = new Array(plateauCapacity);\r\n  /** Current number of plateau entries filled. */\r\n  let plateauCount = 0;\r\n  /** Next write index for plateau buffer. */\r\n  let plateauWriteIdx = 0;\r\n  /** Insert new training error into plateau buffer. */\r\n  const plateauPush = (value: number) => {\r\n    if (plateauCapacity === 1) {\r\n      plateauBuf[0] = value;\r\n      plateauCount = 1;\r\n      plateauWriteIdx = 0;\r\n      return;\r\n    }\r\n    plateauBuf[plateauWriteIdx] = value;\r\n    plateauWriteIdx = (plateauWriteIdx + 1) % plateauCapacity;\r\n    if (plateauCount < plateauCapacity) plateauCount++;\r\n  };\r\n  /** Chronologically ordered plateau buffer snapshot. */\r\n  const plateauChrono = (): number[] => {\r\n    if (plateauCount === 0) return [];\r\n    if (plateauCount < plateauCapacity)\r\n      return plateauBuf.slice(0, plateauCount);\r\n    const out = new Array(plateauCount);\r\n    const start = plateauWriteIdx;\r\n    for (let i = 0; i < plateauCount; i++)\r\n      out[i] = plateauBuf[(start + i) % plateauCapacity];\r\n    return out;\r\n  };\r\n  /** Plateau-specific EMA state (if plateauType === 'ema'). */\r\n  let plateauEmaValue: number | undefined = undefined;\r\n  /** Mutate network dropout probability for upcoming epoch iterations. */\r\n  net.dropout = dropout;\r\n  /** Number of iterations actually executed (in case of early stopping). */\r\n  let performedIterations = 0;\r\n  for (let iter = 1; iter <= iterations; iter++) {\r\n    // -----------------------------\r\n    // Iteration prologue\r\n    // -----------------------------\r\n    // 'iter' is 1-based to align with common optimizer bias-correction formulae (Adam etc.).\r\n    if ((net as any)._maybePrune) {\r\n      (net as any)._maybePrune((internalNet._globalEpoch || 0) + iter);\r\n    }\r\n    // Run one epoch pass over dataset (mini-batching handled internally) and obtain raw mean error.\r\n    const trainError = trainSetImpl(\r\n      net,\r\n      set,\r\n      batchSize,\r\n      accumulationSteps,\r\n      baseRate,\r\n      momentum,\r\n      {},\r\n      cost as any,\r\n      optimizerConfig\r\n    );\r\n    // Record that this iteration was fully executed (used if we early break afterwards).\r\n    performedIterations = iter;\r\n    // Push raw error into smoothing buffer(s) for subsequent moving-average computation.\r\n    recentErrorsPush(trainError);\r\n    /** Monitored error value after smoothing strategy is applied (initially raw). */\r\n    let monitored = trainError;\r\n    // -----------------------------\r\n    // Primary moving-average smoothing block\r\n    // -----------------------------\r\n    // Conditions: apply if window > 1 or a strategy that inherently disregards window size (ema/adaptive).\r\n    if (\r\n      movingAverageWindow > 1 ||\r\n      movingAverageType === 'ema' ||\r\n      movingAverageType === 'adaptive-ema'\r\n    ) {\r\n      const recentArr = recentErrorsChrono();\r\n      if (movingAverageType === 'median') {\r\n        // Robust central tendency; reduces influence of transient spikes.\r\n        const sorted = [...recentArr].sort((a, b) => a - b);\r\n        const mid = Math.floor(sorted.length / 2); // middle index\r\n        monitored =\r\n          sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;\r\n      } else if (movingAverageType === 'ema') {\r\n        // Classic exponentially weighted moving average (constant alpha).\r\n        if (emaValue == null) emaValue = trainError;\r\n        else emaValue = emaValue + emaAlpha! * (trainError - emaValue);\r\n        monitored = emaValue;\r\n      } else if (movingAverageType === 'adaptive-ema') {\r\n        // Dual EMA: baseline + adaptive alpha that expands under variance to speed reaction, then we keep min.\r\n        const mean = recentArr.reduce((a, b) => a + b, 0) / recentArr.length;\r\n        const variance =\r\n          recentArr.reduce((a, b) => a + (b - mean) * (b - mean), 0) /\r\n          recentArr.length;\r\n        const baseAlpha = emaAlpha || 2 / (movingAverageWindow + 1);\r\n        const varScaled = variance / Math.max(mean * mean, 1e-8);\r\n        const adaptAlpha = Math.min(\r\n          0.95,\r\n          Math.max(baseAlpha, baseAlpha * (1 + 2 * varScaled))\r\n        );\r\n        if (adaptiveBaseEmaValue == null) {\r\n          adaptiveBaseEmaValue = trainError;\r\n          adaptiveEmaValue = trainError;\r\n        } else {\r\n          adaptiveBaseEmaValue =\r\n            adaptiveBaseEmaValue +\r\n            baseAlpha * (trainError - adaptiveBaseEmaValue);\r\n          adaptiveEmaValue =\r\n            adaptiveEmaValue! + adaptAlpha * (trainError - adaptiveEmaValue!);\r\n        }\r\n        monitored = Math.min(adaptiveEmaValue!, adaptiveBaseEmaValue!);\r\n      } else if (movingAverageType === 'gaussian') {\r\n        // Weighted by Gaussian kernel centered at newest point; older (earlier) points get progressively less weight.\r\n        const gaussianWindow = recentArr;\r\n        const windowLength = gaussianWindow.length;\r\n        const sigma = movingAverageWindow / 3 || 1; // heuristic: cover window with ~3 sigma\r\n        let gaussianWeightSum = 0;\r\n        let gaussianWeightedAccumulator = 0;\r\n        for (let gi = 0; gi < windowLength; gi++) {\r\n          const weight = Math.exp(\r\n            -0.5 * Math.pow((gi - (windowLength - 1)) / sigma, 2)\r\n          );\r\n          gaussianWeightSum += weight;\r\n          gaussianWeightedAccumulator += weight * gaussianWindow[gi];\r\n        }\r\n        monitored = gaussianWeightedAccumulator / (gaussianWeightSum || 1);\r\n      } else if (movingAverageType === 'trimmed') {\r\n        // Trim symmetrical tails to damp outliers before averaging.\r\n        const tailTrimRatio = Math.min(\r\n          0.49,\r\n          Math.max(0, options.trimmedRatio || 0.1)\r\n        );\r\n        const sorted = [...recentArr].sort((a, b) => a - b);\r\n        const elementsToDropEachSide = Math.floor(\r\n          sorted.length * tailTrimRatio\r\n        );\r\n        const trimmedSegment = sorted.slice(\r\n          elementsToDropEachSide,\r\n          sorted.length - elementsToDropEachSide\r\n        );\r\n        monitored =\r\n          trimmedSegment.reduce((a, b) => a + b, 0) /\r\n          (trimmedSegment.length || 1);\r\n      } else if (movingAverageType === 'wma') {\r\n        // Linear weights: newer samples more influential.\r\n        let linearWeightSum = 0;\r\n        let linearWeightedAccumulator = 0;\r\n        for (let li = 0; li < recentArr.length; li++) {\r\n          const weight = li + 1; // oldest gets 1, newest gets N\r\n          linearWeightSum += weight;\r\n          linearWeightedAccumulator += weight * recentArr[li];\r\n        }\r\n        monitored = linearWeightedAccumulator / (linearWeightSum || 1);\r\n      } else {\r\n        // Simple arithmetic mean (SMA).\r\n        monitored = recentArr.reduce((a, b) => a + b, 0) / recentArr.length;\r\n      }\r\n    }\r\n    // Update finalError with the smoothed/selected monitored metric.\r\n    finalError = monitored;\r\n    // Store raw trainError (not smoothed) for plateau evaluation buffer.\r\n    plateauPush(trainError);\r\n    /** Plateau-smoothed error (could use different smoothing strategy than monitored). */\r\n    let plateauError: number | undefined = trainError;\r\n    if (plateauWindow > 1 || plateauType === 'ema') {\r\n      if (plateauType === 'median') {\r\n        // Median for plateau stability over variable noise.\r\n        const sorted = [...plateauChrono()].sort((a, b) => a - b);\r\n        const mid = Math.floor(sorted.length / 2);\r\n        plateauError =\r\n          sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;\r\n      } else if (plateauType === 'ema') {\r\n        // EMA variant for plateau detection (faster adaptation with controlled lag).\r\n        if (plateauEmaValue == null) plateauEmaValue = trainError;\r\n        else\r\n          plateauEmaValue =\r\n            plateauEmaValue + plateauEmaAlpha! * (trainError - plateauEmaValue);\r\n        plateauError = plateauEmaValue;\r\n      } else {\r\n        // Default plateau = arithmetic mean over plateau window.\r\n        const arr = plateauChrono();\r\n        plateauError = arr.reduce((a, b) => a + b, 0) / arr.length;\r\n      }\r\n    }\r\n    if (typeof options.metricsHook === 'function') {\r\n      try {\r\n        // User hook for live metrics logging / dashboards / adaptive schedulers.\r\n        options.metricsHook({\r\n          iteration: iter,\r\n          error: finalError,\r\n          plateauError,\r\n          gradNorm: internalNet._lastGradNorm ?? 0,\r\n        });\r\n      } catch {}\r\n    }\r\n    if (options.checkpoint && typeof options.checkpoint.save === 'function') {\r\n      if (options.checkpoint.last) {\r\n        try {\r\n          // Always save most recent network state.\r\n          options.checkpoint.save({\r\n            type: 'last',\r\n            iteration: iter,\r\n            error: finalError,\r\n            network: net.toJSON(),\r\n          });\r\n        } catch {}\r\n      }\r\n      if (options.checkpoint.best) {\r\n        if (\r\n          finalError < (net as any)._checkpointBestError ||\r\n          (net as any)._checkpointBestError == null\r\n        ) {\r\n          // New best model discovered under monitored error metric.\r\n          (net as any)._checkpointBestError = finalError;\r\n          try {\r\n            options.checkpoint.save({\r\n              type: 'best',\r\n              iteration: iter,\r\n              error: finalError,\r\n              network: net.toJSON(),\r\n            });\r\n          } catch {}\r\n        }\r\n      }\r\n    }\r\n    if (\r\n      options.schedule &&\r\n      options.schedule.iterations &&\r\n      iter % options.schedule.iterations === 0\r\n    ) {\r\n      try {\r\n        // Periodic user-defined callback (e.g., adjust LR, print status, inject curriculum changes).\r\n        options.schedule.function({ error: finalError, iteration: iter });\r\n      } catch {}\r\n    }\r\n    // -----------------------------\r\n    // Early stopping logic\r\n    // -----------------------------\r\n    if (finalError < bestError - earlyStopMinDelta) {\r\n      // Sufficient improvement: update best and reset stagnation counter.\r\n      bestError = finalError;\r\n      noImproveCount = 0;\r\n    } else if (earlyStopPatience) {\r\n      // Track consecutive non-improving iterations.\r\n      noImproveCount++;\r\n    }\r\n    // Patience exhaustion: terminate.\r\n    if (earlyStopPatience && noImproveCount >= earlyStopPatience) break;\r\n    // Target error reached: terminate.\r\n    if (finalError <= targetError) break;\r\n  }\r\n  net.nodes.forEach((n) => {\r\n    if (n.type === 'hidden') n.mask = 1;\r\n  });\r\n  // Clear dropout for inference after training completes.\r\n  net.dropout = 0;\r\n  internalNet._globalEpoch =\r\n    (internalNet._globalEpoch || 0) + performedIterations;\r\n  return {\r\n    /** Final monitored (possibly smoothed) error achieved at termination. */\r\n    error: finalError,\r\n    /** Number of iterations actually executed (could be < requested iterations due to early stop). */\r\n    iterations: performedIterations,\r\n    /** Wall-clock training duration in milliseconds. */\r\n    time: Date.now() - start,\r\n  };\r\n}\r\n", "module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}", "if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n", "// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n'use strict';\r\n\r\n\r\nvar isWindows = process.platform === 'win32';\r\nvar util = require('util');\r\n\r\n\r\n// resolves . and .. elements in a path array with directory names there\r\n// must be no slashes or device names (c:\\) in the array\r\n// (so also no leading and trailing slashes - it does not distinguish\r\n// relative and absolute paths)\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n  var res = [];\r\n  for (var i = 0; i < parts.length; i++) {\r\n    var p = parts[i];\r\n\r\n    // ignore empty parts\r\n    if (!p || p === '.')\r\n      continue;\r\n\r\n    if (p === '..') {\r\n      if (res.length && res[res.length - 1] !== '..') {\r\n        res.pop();\r\n      } else if (allowAboveRoot) {\r\n        res.push('..');\r\n      }\r\n    } else {\r\n      res.push(p);\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// returns an array with empty elements removed from either end of the input\r\n// array or the original array if no elements need to be removed\r\nfunction trimArray(arr) {\r\n  var lastIndex = arr.length - 1;\r\n  var start = 0;\r\n  for (; start <= lastIndex; start++) {\r\n    if (arr[start])\r\n      break;\r\n  }\r\n\r\n  var end = lastIndex;\r\n  for (; end >= 0; end--) {\r\n    if (arr[end])\r\n      break;\r\n  }\r\n\r\n  if (start === 0 && end === lastIndex)\r\n    return arr;\r\n  if (start > end)\r\n    return [];\r\n  return arr.slice(start, end + 1);\r\n}\r\n\r\n// Regex to split a windows path into three parts: [*, device, slash,\r\n// tail] windows-only\r\nvar splitDeviceRe =\r\n    /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\r\n\r\n// Regex to split the tail part of the above into [*, dir, basename, ext]\r\nvar splitTailRe =\r\n    /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\r\n\r\nvar win32 = {};\r\n\r\n// Function to split a filename into [root, dir, basename, ext]\r\nfunction win32SplitPath(filename) {\r\n  // Separate device+slash from tail\r\n  var result = splitDeviceRe.exec(filename),\r\n      device = (result[1] || '') + (result[2] || ''),\r\n      tail = result[3] || '';\r\n  // Split the tail into dir, basename and extension\r\n  var result2 = splitTailRe.exec(tail),\r\n      dir = result2[1],\r\n      basename = result2[2],\r\n      ext = result2[3];\r\n  return [device, dir, basename, ext];\r\n}\r\n\r\nfunction win32StatPath(path) {\r\n  var result = splitDeviceRe.exec(path),\r\n      device = result[1] || '',\r\n      isUnc = !!device && device[1] !== ':';\r\n  return {\r\n    device: device,\r\n    isUnc: isUnc,\r\n    isAbsolute: isUnc || !!result[2], // UNC paths are always absolute\r\n    tail: result[3]\r\n  };\r\n}\r\n\r\nfunction normalizeUNCRoot(device) {\r\n  return '\\\\\\\\' + device.replace(/^[\\\\\\/]+/, '').replace(/[\\\\\\/]+/g, '\\\\');\r\n}\r\n\r\n// path.resolve([from ...], to)\r\nwin32.resolve = function() {\r\n  var resolvedDevice = '',\r\n      resolvedTail = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1; i--) {\r\n    var path;\r\n    if (i >= 0) {\r\n      path = arguments[i];\r\n    } else if (!resolvedDevice) {\r\n      path = process.cwd();\r\n    } else {\r\n      // Windows has the concept of drive-specific current working\r\n      // directories. If we've resolved a drive letter but not yet an\r\n      // absolute path, get cwd for that drive. We're sure the device is not\r\n      // an unc path at this points, because unc paths are always absolute.\r\n      path = process.env['=' + resolvedDevice];\r\n      // Verify that a drive-local cwd was found and that it actually points\r\n      // to our drive. If not, default to the drive's root.\r\n      if (!path || path.substr(0, 3).toLowerCase() !==\r\n          resolvedDevice.toLowerCase() + '\\\\') {\r\n        path = resolvedDevice + '\\\\';\r\n      }\r\n    }\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    var result = win32StatPath(path),\r\n        device = result.device,\r\n        isUnc = result.isUnc,\r\n        isAbsolute = result.isAbsolute,\r\n        tail = result.tail;\r\n\r\n    if (device &&\r\n        resolvedDevice &&\r\n        device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n      // This path points to another device so it is not applicable\r\n      continue;\r\n    }\r\n\r\n    if (!resolvedDevice) {\r\n      resolvedDevice = device;\r\n    }\r\n    if (!resolvedAbsolute) {\r\n      resolvedTail = tail + '\\\\' + resolvedTail;\r\n      resolvedAbsolute = isAbsolute;\r\n    }\r\n\r\n    if (resolvedDevice && resolvedAbsolute) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Convert slashes to backslashes when `resolvedDevice` points to an UNC\r\n  // root. Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    resolvedDevice = normalizeUNCRoot(resolvedDevice);\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path,\r\n  // but handle relative paths to be safe (might happen when process.cwd()\r\n  // fails)\r\n\r\n  // Normalize the tail path\r\n  resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\/]+/),\r\n                                !resolvedAbsolute).join('\\\\');\r\n\r\n  return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\r\n         '.';\r\n};\r\n\r\n\r\nwin32.normalize = function(path) {\r\n  var result = win32StatPath(path),\r\n      device = result.device,\r\n      isUnc = result.isUnc,\r\n      isAbsolute = result.isAbsolute,\r\n      tail = result.tail,\r\n      trailingSlash = /[\\\\\\/]$/.test(tail);\r\n\r\n  // Normalize the tail path\r\n  tail = normalizeArray(tail.split(/[\\\\\\/]+/), !isAbsolute).join('\\\\');\r\n\r\n  if (!tail && !isAbsolute) {\r\n    tail = '.';\r\n  }\r\n  if (tail && trailingSlash) {\r\n    tail += '\\\\';\r\n  }\r\n\r\n  // Convert slashes to backslashes when `device` points to an UNC root.\r\n  // Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    device = normalizeUNCRoot(device);\r\n  }\r\n\r\n  return device + (isAbsolute ? '\\\\' : '') + tail;\r\n};\r\n\r\n\r\nwin32.isAbsolute = function(path) {\r\n  return win32StatPath(path).isAbsolute;\r\n};\r\n\r\nwin32.join = function() {\r\n  var paths = [];\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var arg = arguments[i];\r\n    if (!util.isString(arg)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (arg) {\r\n      paths.push(arg);\r\n    }\r\n  }\r\n\r\n  var joined = paths.join('\\\\');\r\n\r\n  // Make sure that the joined path doesn't start with two slashes, because\r\n  // normalize() will mistake it for an UNC path then.\r\n  //\r\n  // This step is skipped when it is very clear that the user actually\r\n  // intended to point at an UNC path. This is assumed when the first\r\n  // non-empty string arguments starts with exactly two slashes followed by\r\n  // at least one more non-slash character.\r\n  //\r\n  // Note that for normalize() to treat a path as an UNC path it needs to\r\n  // have at least 2 components, so we don't filter for that here.\r\n  // This means that the user can use join to construct UNC paths from\r\n  // a server name and a share name; for example:\r\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\r\n  if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\r\n    joined = joined.replace(/^[\\\\\\/]{2,}/, '\\\\');\r\n  }\r\n\r\n  return win32.normalize(joined);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// it will solve the relative path from 'from' to 'to', for instance:\r\n// from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n// to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\nwin32.relative = function(from, to) {\r\n  from = win32.resolve(from);\r\n  to = win32.resolve(to);\r\n\r\n  // windows is not case sensitive\r\n  var lowerFrom = from.toLowerCase();\r\n  var lowerTo = to.toLowerCase();\r\n\r\n  var toParts = trimArray(to.split('\\\\'));\r\n\r\n  var lowerFromParts = trimArray(lowerFrom.split('\\\\'));\r\n  var lowerToParts = trimArray(lowerTo.split('\\\\'));\r\n\r\n  var length = Math.min(lowerFromParts.length, lowerToParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (lowerFromParts[i] !== lowerToParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (samePartsLength == 0) {\r\n    return to;\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < lowerFromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('\\\\');\r\n};\r\n\r\n\r\nwin32._makeLong = function(path) {\r\n  // Note: this will *probably* throw somewhere.\r\n  if (!util.isString(path))\r\n    return path;\r\n\r\n  if (!path) {\r\n    return '';\r\n  }\r\n\r\n  var resolvedPath = win32.resolve(path);\r\n\r\n  if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\r\n    // path is local filesystem path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\' + resolvedPath;\r\n  } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\r\n    // path is network UNC path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\r\n  }\r\n\r\n  return path;\r\n};\r\n\r\n\r\nwin32.dirname = function(path) {\r\n  var result = win32SplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nwin32.basename = function(path, ext) {\r\n  var f = win32SplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nwin32.extname = function(path) {\r\n  return win32SplitPath(path)[3];\r\n};\r\n\r\n\r\nwin32.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir;\r\n  var base = pathObject.base || '';\r\n  if (!dir) {\r\n    return base;\r\n  }\r\n  if (dir[dir.length - 1] === win32.sep) {\r\n    return dir + base;\r\n  }\r\n  return dir + win32.sep + base;\r\n};\r\n\r\n\r\nwin32.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = win32SplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nwin32.sep = '\\\\';\r\nwin32.delimiter = ';';\r\n\r\n\r\n// Split a filename into [root, dir, basename, ext], unix version\r\n// 'root' is just a slash, or nothing.\r\nvar splitPathRe =\r\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\nvar posix = {};\r\n\r\n\r\nfunction posixSplitPath(filename) {\r\n  return splitPathRe.exec(filename).slice(1);\r\n}\r\n\r\n\r\n// path.resolve([from ...], to)\r\n// posix version\r\nposix.resolve = function() {\r\n  var resolvedPath = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n    var path = (i >= 0) ? arguments[i] : process.cwd();\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    resolvedPath = path + '/' + resolvedPath;\r\n    resolvedAbsolute = path[0] === '/';\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path, but\r\n  // handle relative paths to be safe (might happen when process.cwd() fails)\r\n\r\n  // Normalize the path\r\n  resolvedPath = normalizeArray(resolvedPath.split('/'),\r\n                                !resolvedAbsolute).join('/');\r\n\r\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n};\r\n\r\n// path.normalize(path)\r\n// posix version\r\nposix.normalize = function(path) {\r\n  var isAbsolute = posix.isAbsolute(path),\r\n      trailingSlash = path && path[path.length - 1] === '/';\r\n\r\n  // Normalize the path\r\n  path = normalizeArray(path.split('/'), !isAbsolute).join('/');\r\n\r\n  if (!path && !isAbsolute) {\r\n    path = '.';\r\n  }\r\n  if (path && trailingSlash) {\r\n    path += '/';\r\n  }\r\n\r\n  return (isAbsolute ? '/' : '') + path;\r\n};\r\n\r\n// posix version\r\nposix.isAbsolute = function(path) {\r\n  return path.charAt(0) === '/';\r\n};\r\n\r\n// posix version\r\nposix.join = function() {\r\n  var path = '';\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var segment = arguments[i];\r\n    if (!util.isString(segment)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (segment) {\r\n      if (!path) {\r\n        path += segment;\r\n      } else {\r\n        path += '/' + segment;\r\n      }\r\n    }\r\n  }\r\n  return posix.normalize(path);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// posix version\r\nposix.relative = function(from, to) {\r\n  from = posix.resolve(from).substr(1);\r\n  to = posix.resolve(to).substr(1);\r\n\r\n  var fromParts = trimArray(from.split('/'));\r\n  var toParts = trimArray(to.split('/'));\r\n\r\n  var length = Math.min(fromParts.length, toParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (fromParts[i] !== toParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < fromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('/');\r\n};\r\n\r\n\r\nposix._makeLong = function(path) {\r\n  return path;\r\n};\r\n\r\n\r\nposix.dirname = function(path) {\r\n  var result = posixSplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nposix.basename = function(path, ext) {\r\n  var f = posixSplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nposix.extname = function(path) {\r\n  return posixSplitPath(path)[3];\r\n};\r\n\r\n\r\nposix.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';\r\n  var base = pathObject.base || '';\r\n  return dir + base;\r\n};\r\n\r\n\r\nposix.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = posixSplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  allParts[1] = allParts[1] || '';\r\n  allParts[2] = allParts[2] || '';\r\n  allParts[3] = allParts[3] || '';\r\n\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nposix.sep = '/';\r\nposix.delimiter = ':';\r\n\r\n\r\nif (isWindows)\r\n  module.exports = win32;\r\nelse /* posix */\r\n  module.exports = posix;\r\n\r\nmodule.exports.posix = posix;\r\nmodule.exports.win32 = win32;\r\n", "import { fork, ChildProcess } from 'child_process';\r\nimport path from 'path';\r\n\r\n/**\r\n * TestWorker class for handling network evaluations in a Node.js environment using Worker Threads.\r\n *\r\n * This implementation aligns with the Instinct algorithm's emphasis on efficient evaluation of\r\n * neural networks in parallel environments. The use of Worker Threads allows for offloading\r\n * computationally expensive tasks, such as network evaluation, to separate threads.\r\n *\r\n * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6#4-constraints Instinct Algorithm - Section 4 Constraints}\r\n *\r\n * This class provides methods to evaluate neural networks and manage the worker process.\r\n */\r\nexport class TestWorker {\r\n  private worker: ChildProcess;\r\n\r\n  /**\r\n   * Creates a new TestWorker instance.\r\n   *\r\n   * This initializes a new worker process and sends the dataset and cost function\r\n   * to the worker for further processing.\r\n   *\r\n   * @param {number[]} dataSet - The serialized dataset to be used by the worker.\r\n   * @param {{ name: string }} cost - The cost function to evaluate the network.\r\n   */\r\n  constructor(dataSet: number[], cost: { name: string }) {\r\n    this.worker = fork(path.join(__dirname, '/worker'));\r\n    this.worker.send({ set: dataSet, cost: cost.name });\r\n  }\r\n\r\n  /**\r\n   * Evaluates a neural network using the worker process.\r\n   *\r\n   * The network is serialized and sent to the worker for evaluation. The worker\r\n   * sends back the evaluation result, which is returned as a promise.\r\n   *\r\n   * @param {any} network - The neural network to evaluate. It must implement a `serialize` method.\r\n   * @returns {Promise<number>} A promise that resolves to the evaluation result.\r\n   */\r\n  evaluate(network: any): Promise<number> {\r\n    return new Promise((resolve) => {\r\n      const serialized = network.serialize();\r\n\r\n      const data = {\r\n        activations: serialized[0],\r\n        states: serialized[1],\r\n        conns: serialized[2],\r\n      };\r\n\r\n      const _that = this.worker;\r\n      this.worker.on('message', function callback(e: number) {\r\n        _that.removeListener('message', callback);\r\n        resolve(e);\r\n      });\r\n\r\n      this.worker.send(data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Terminates the worker process.\r\n   *\r\n   * This method ensures that the worker process is properly terminated to free up system resources.\r\n   */\r\n  terminate(): void {\r\n    this.worker.kill();\r\n  }\r\n}\r\n\r\n// Add default export to match the original JavaScript implementation.\r\nexport default TestWorker;\r\n", "import Multi from '../../multi';\r\n\r\n/**\r\n * TestWorker class for handling network evaluations in a browser environment using Web Workers.\r\n *\r\n * This implementation aligns with the Instinct algorithm's emphasis on efficient evaluation of\r\n * neural networks in parallel environments. The use of Web Workers allows for offloading\r\n * computationally expensive tasks, such as network evaluation, to separate threads.\r\n *\r\n * @see Instinct Algorithm - Section 4 Constraints\r\n * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6}\r\n */\r\nexport class TestWorker {\r\n  private worker: Worker;\r\n  private url: string;\r\n\r\n  /**\r\n   * Creates a new TestWorker instance.\r\n   * @param {number[]} dataSet - The serialized dataset to be used by the worker.\r\n   * @param {any} cost - The cost function to evaluate the network.\r\n   */\r\n  constructor(dataSet: number[], cost: { name: string }) {\r\n    const blob = new Blob([TestWorker._createBlobString(cost)]);\r\n    this.url = window.URL.createObjectURL(blob);\r\n    this.worker = new Worker(this.url);\r\n\r\n    const data = { set: new Float64Array(dataSet).buffer };\r\n    this.worker.postMessage(data, [data.set]);\r\n  }\r\n\r\n  /**\r\n   * Evaluates a network using the worker process.\r\n   * @param {any} network - The network to evaluate.\r\n   * @returns {Promise<number>} A promise that resolves to the evaluation result.\r\n   */\r\n  evaluate(network: any): Promise<number> {\r\n    return new Promise((resolve, reject) => {\r\n      const serialized = network.serialize();\r\n\r\n      const data = {\r\n        activations: new Float64Array(serialized[0]).buffer,\r\n        states: new Float64Array(serialized[1]).buffer,\r\n        conns: new Float64Array(serialized[2]).buffer,\r\n      };\r\n\r\n      this.worker.onmessage = function (e: MessageEvent) {\r\n        const error = new Float64Array(e.data.buffer)[0];\r\n        resolve(error);\r\n      };\r\n\r\n      this.worker.postMessage(data, [\r\n        data.activations,\r\n        data.states,\r\n        data.conns,\r\n      ]);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Terminates the worker process and revokes the object URL.\r\n   */\r\n  terminate(): void {\r\n    this.worker.terminate();\r\n    window.URL.revokeObjectURL(this.url);\r\n  }\r\n\r\n  /**\r\n   * Creates a string representation of the worker's blob.\r\n   * @param {any} cost - The cost function to be used by the worker.\r\n   * @returns {string} The blob string.\r\n   */\r\n  private static _createBlobString(cost: any): string {\r\n    return `\r\n      const F = [${Multi.activations.toString()}];\r\n      const cost = ${cost.toString()};\r\n      const multi = {\r\n        deserializeDataSet: ${Multi.deserializeDataSet.toString()},\r\n        testSerializedSet: ${Multi.testSerializedSet.toString()},\r\n        activateSerializedNetwork: ${Multi.activateSerializedNetwork.toString()}\r\n      };\r\n\r\n      let set;\r\n\r\n      this.onmessage = function (e) {\r\n        if (typeof e.data.set === 'undefined') {\r\n          const A = new Float64Array(e.data.activations);\r\n          const S = new Float64Array(e.data.states);\r\n          const data = new Float64Array(e.data.conns);\r\n\r\n          const error = multi.testSerializedSet(set, cost, A, S, data, F);\r\n\r\n          const answer = { buffer: new Float64Array([error]).buffer };\r\n          postMessage(answer, [answer.buffer]);\r\n        } else {\r\n          set = multi.deserializeDataSet(new Float64Array(e.data.set));\r\n        }\r\n      };`;\r\n  }\r\n}\r\n", "/**\r\n * Utility class for managing workers in both Node.js and browser environments.\r\n */\r\nexport class Workers {\r\n  /**\r\n   * Loads the Node.js test worker dynamically.\r\n   * @returns {Promise<any>} A promise that resolves to the Node.js TestWorker class.\r\n   */\r\n  static async getNodeTestWorker(): Promise<any> {\r\n    const module = await import('./node/testworker');\r\n    return module.TestWorker;\r\n  }\r\n\r\n  /**\r\n   * Loads the browser test worker dynamically.\r\n   * @returns {Promise<any>} A promise that resolves to the browser TestWorker class.\r\n   */\r\n  static async getBrowserTestWorker(): Promise<any> {\r\n    const module = await import('./browser/testworker');\r\n    return module.TestWorker;\r\n  }\r\n}\r\n", "import { Workers } from './workers/workers';\r\nimport Network from '../architecture/network';\r\n\r\n/**\r\n * Multi-threading utilities for neural network operations.\r\n *\r\n * This class provides methods for serializing datasets, activating serialized networks,\r\n * and testing serialized datasets. These utilities align with the Instinct algorithm's\r\n * emphasis on efficient evaluation and mutation of neural networks in parallel environments.\r\n *\r\n * @see Instinct Algorithm - Section 4 Constraints\r\n * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6}\r\n */\r\nexport default class Multi {\r\n  /** Workers for multi-threading */\r\n  static workers = Workers;\r\n\r\n  /**\r\n   * A list of compiled activation functions in a specific order.\r\n   */\r\n  static activations: Array<(x: number) => number> = [\r\n    (x) => 1 / (1 + Math.exp(-x)), // Logistic (0)\r\n    (x) => Math.tanh(x), // Tanh (1)\r\n    (x) => x, // Identity (2)\r\n    (x) => (x > 0 ? 1 : 0), // Step (3)\r\n    (x) => (x > 0 ? x : 0), // ReLU (4)\r\n    (x) => x / (1 + Math.abs(x)), // Softsign (5)\r\n    (x) => Math.sin(x), // Sinusoid (6)\r\n    (x) => Math.exp(-Math.pow(x, 2)), // Gaussian (7)\r\n    (x) => (Math.sqrt(Math.pow(x, 2) + 1) - 1) / 2 + x, // Bent Identity (8)\r\n    (x) => (x > 0 ? 1 : -1), // Bipolar (9)\r\n    (x) => 2 / (1 + Math.exp(-x)) - 1, // Bipolar Sigmoid (10)\r\n    (x) => Math.max(-1, Math.min(1, x)), // Hard Tanh (11)\r\n    (x) => Math.abs(x), // Absolute (12)\r\n    (x) => 1 - x, // Inverse (13)\r\n    (x) => {\r\n      // SELU (14)\r\n      const alpha = 1.6732632423543772848170429916717;\r\n      const scale = 1.0507009873554804934193349852946;\r\n      const fx = x > 0 ? x : alpha * Math.exp(x) - alpha;\r\n      return fx * scale;\r\n    },\r\n    (x) => Math.log(1 + Math.exp(x)), // Softplus (15) - Added\r\n  ];\r\n\r\n  /**\r\n   * Serializes a dataset into a flat array.\r\n   * @param {Array<{ input: number[]; output: number[] }>} dataSet - The dataset to serialize.\r\n   * @returns {number[]} The serialized dataset.\r\n   */\r\n  static serializeDataSet(\r\n    dataSet: Array<{ input: number[]; output: number[] }>\r\n  ): number[] {\r\n    const serialized = [dataSet[0].input.length, dataSet[0].output.length];\r\n\r\n    for (let i = 0; i < dataSet.length; i++) {\r\n      for (let j = 0; j < serialized[0]; j++) {\r\n        serialized.push(dataSet[i].input[j]);\r\n      }\r\n      for (let j = 0; j < serialized[1]; j++) {\r\n        serialized.push(dataSet[i].output[j]);\r\n      }\r\n    }\r\n\r\n    return serialized;\r\n  }\r\n\r\n  /**\r\n   * Activates a serialized network.\r\n   * @param {number[]} input - The input values.\r\n   * @param {number[]} A - The activations array.\r\n   * @param {number[]} S - The states array.\r\n   * @param {number[]} data - The serialized network data.\r\n   * @param {Function[]} F - The activation functions.\r\n   * @returns {number[]} The output values.\r\n   */\r\n  static activateSerializedNetwork(\r\n    input: number[],\r\n    A: number[],\r\n    S: number[],\r\n    data: number[],\r\n    F: Function[]\r\n  ): number[] {\r\n    for (let i = 0; i < data[0]; i++) A[i] = input[i];\r\n    for (let i = 2; i < data.length; i++) {\r\n      const index = data[i++];\r\n      const bias = data[i++];\r\n      const squash = data[i++];\r\n      const selfweight = data[i++];\r\n      const selfgater = data[i++];\r\n\r\n      S[index] =\r\n        (selfgater === -1 ? 1 : A[selfgater]) * selfweight * S[index] + bias;\r\n\r\n      while (data[i] !== -2) {\r\n        S[index] +=\r\n          A[data[i++]] * data[i++] * (data[i++] === -1 ? 1 : A[data[i - 1]]);\r\n      }\r\n      A[index] = F[squash](S[index]);\r\n    }\r\n\r\n    const output = [];\r\n    for (let i = A.length - data[1]; i < A.length; i++) output.push(A[i]);\r\n    return output;\r\n  }\r\n\r\n  /**\r\n   * Deserializes a dataset from a flat array.\r\n   * @param {number[]} serializedSet - The serialized dataset.\r\n   * @returns {Array<{ input: number[]; output: number[] }>} The deserialized dataset as an array of input-output pairs.\r\n   */\r\n  static deserializeDataSet(\r\n    serializedSet: number[]\r\n  ): Array<{ input: number[]; output: number[] }> {\r\n    const set: Array<{ input: number[]; output: number[] }> = [];\r\n    const sampleSize = serializedSet[0] + serializedSet[1];\r\n\r\n    for (let i = 0; i < (serializedSet.length - 2) / sampleSize; i++) {\r\n      const input: number[] = [];\r\n      for (\r\n        let j = 2 + i * sampleSize;\r\n        j < 2 + i * sampleSize + serializedSet[0];\r\n        j++\r\n      ) {\r\n        input.push(serializedSet[j]);\r\n      }\r\n      const output: number[] = [];\r\n      for (\r\n        let j = 2 + i * sampleSize + serializedSet[0];\r\n        j < 2 + i * sampleSize + sampleSize;\r\n        j++\r\n      ) {\r\n        output.push(serializedSet[j]);\r\n      }\r\n      set.push({ input, output });\r\n    }\r\n\r\n    return set;\r\n  }\r\n\r\n  /**\r\n   * Logistic activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static logistic(x: number): number {\r\n    return 1 / (1 + Math.exp(-x));\r\n  }\r\n\r\n  /**\r\n   * Hyperbolic tangent activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static tanh(x: number): number {\r\n    return Math.tanh(x);\r\n  }\r\n\r\n  /**\r\n   * Identity activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static identity(x: number): number {\r\n    return x;\r\n  }\r\n\r\n  /**\r\n   * Step activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static step(x: number): number {\r\n    return x > 0 ? 1 : 0;\r\n  }\r\n\r\n  /**\r\n   * Rectified Linear Unit (ReLU) activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static relu(x: number): number {\r\n    return x > 0 ? x : 0;\r\n  }\r\n\r\n  /**\r\n   * Softsign activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static softsign(x: number): number {\r\n    return x / (1 + Math.abs(x));\r\n  }\r\n\r\n  /**\r\n   * Sinusoid activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static sinusoid(x: number): number {\r\n    return Math.sin(x);\r\n  }\r\n\r\n  /**\r\n   * Gaussian activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static gaussian(x: number): number {\r\n    return Math.exp(-Math.pow(x, 2));\r\n  }\r\n\r\n  /**\r\n   * Bent Identity activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static bentIdentity(x: number): number {\r\n    return (Math.sqrt(Math.pow(x, 2) + 1) - 1) / 2 + x;\r\n  }\r\n\r\n  /**\r\n   * Bipolar activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static bipolar(x: number): number {\r\n    return x > 0 ? 1 : -1;\r\n  }\r\n\r\n  /**\r\n   * Bipolar Sigmoid activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static bipolarSigmoid(x: number): number {\r\n    return 2 / (1 + Math.exp(-x)) - 1;\r\n  }\r\n\r\n  /**\r\n   * Hard Tanh activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static hardTanh(x: number): number {\r\n    return Math.max(-1, Math.min(1, x));\r\n  }\r\n\r\n  /**\r\n   * Absolute activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static absolute(x: number): number {\r\n    return Math.abs(x);\r\n  }\r\n\r\n  /**\r\n   * Inverse activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static inverse(x: number): number {\r\n    return 1 - x;\r\n  }\r\n\r\n  /**\r\n   * Scaled Exponential Linear Unit (SELU) activation function.\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static selu(x: number): number {\r\n    const alpha = 1.6732632423543772848170429916717;\r\n    const scale = 1.0507009873554804934193349852946;\r\n    const fx = x > 0 ? x : alpha * Math.exp(x) - alpha; // Corrected definition\r\n    return fx * scale;\r\n  }\r\n\r\n  /**\r\n   * Softplus activation function. - Added\r\n   * @param {number} x - The input value.\r\n   * @returns {number} The activated value.\r\n   */\r\n  static softplus(x: number): number {\r\n    return Math.log(1 + Math.exp(x));\r\n  }\r\n\r\n  /**\r\n   * Tests a serialized dataset using a cost function.\r\n   * @param {Array<{ input: number[]; output: number[] }>} set - The serialized dataset as an array of input-output pairs.\r\n   * @param {Function} cost - The cost function.\r\n   * @param {number[]} A - The activations array.\r\n   * @param {number[]} S - The states array.\r\n   * @param {number[]} data - The serialized network data.\r\n   * @param {Function[]} F - The activation functions.\r\n   * @returns {number} The average error.\r\n   */\r\n  static testSerializedSet(\r\n    set: Array<{ input: number[]; output: number[] }>,\r\n    cost: (expected: number[], actual: number[]) => number,\r\n    A: number[],\r\n    S: number[],\r\n    data: number[],\r\n    F: Function[]\r\n  ): number {\r\n    let error = 0;\r\n\r\n    for (let i = 0; i < set.length; i++) {\r\n      const output = Multi.activateSerializedNetwork(\r\n        set[i].input,\r\n        A,\r\n        S,\r\n        data,\r\n        F\r\n      );\r\n      error += cost(set[i].output, output);\r\n    }\r\n\r\n    return error / set.length;\r\n  }\r\n\r\n  /**\r\n   * Gets the browser test worker.\r\n   * @returns {Promise<any>} The browser test worker.\r\n   */\r\n  static async getBrowserTestWorker() {\r\n    const { TestWorker } = await import('./workers/browser/testworker');\r\n    return TestWorker;\r\n  }\r\n\r\n  /**\r\n   * Gets the node test worker.\r\n   * @returns {Promise<any>} The node test worker.\r\n   */\r\n  static async getNodeTestWorker() {\r\n    const { TestWorker } = await import('./workers/node/testworker'); // Corrected path\r\n    return TestWorker;\r\n  }\r\n}\r\n", "import Network from '../network';\r\nimport * as methods from '../../methods/methods';\r\nimport { config } from '../../config';\r\nimport Multi from '../../multithreading/multi';\r\n\r\n/**\r\n * A single supervised training example used to evaluate fitness.\r\n */\r\ninterface TrainingSample {\r\n  input: number[];\r\n  output: number[];\r\n}\r\n\r\n/**\r\n * Internal evolution configuration summary (for potential logging / debugging)\r\n * capturing normalized option values used by the local evolutionary loop.\r\n */\r\ninterface EvolutionConfig {\r\n  targetError: number;\r\n  growth: number;\r\n  cost: any;\r\n  amount: number;\r\n  log: number;\r\n  schedule: any;\r\n  clear: boolean;\r\n  threads: number;\r\n}\r\n\r\n/**\r\n * Cache for complexity penalty computations keyed by genome (Network) reference.\r\n * We store counts used to derive a simple structural complexity measure so repeated\r\n * invocations during a generation avoid recomputing the same base value.\r\n */\r\nconst _complexityCache: WeakMap<\r\n  Network,\r\n  { nodes: number; conns: number; gates: number; value: number }\r\n> = new WeakMap();\r\n\r\n/**\r\n * Compute a structural complexity penalty scaled by a growth factor.\r\n *\r\n * Complexity heuristic:\r\n *   (hidden nodes) + (connections) + (gates)\r\n * hidden nodes = total nodes - input - output (to avoid penalizing fixed I/O interface size).\r\n *\r\n * Rationale: Encourages minimal / parsimonious networks by subtracting a term from fitness\r\n * proportional to network size, counteracting bloat. Growth hyper\u2011parameter tunes pressure.\r\n *\r\n * Caching strategy: We memoize the base complexity (pre\u2011growth scaling) per genome when its\r\n * structural counts (nodes / connections / gates) are unchanged. This is safe because only\r\n * structural mutations alter these counts, and those invalidate earlier entries naturally\r\n * (since mutated genomes are distinct object references in typical NEAT flows).\r\n *\r\n * @param genome - Candidate network whose complexity to measure.\r\n * @param growth - Positive scalar controlling strength of parsimony pressure.\r\n * @returns Complexity * growth (used directly to subtract from fitness score).\r\n */\r\nfunction computeComplexityPenalty(genome: Network, growth: number): number {\r\n  // Extract structural counts once.\r\n  const n = genome.nodes.length;\r\n  const c = genome.connections.length;\r\n  const g = genome.gates.length;\r\n  // Fast path: counts unchanged -> reuse cached base complexity value.\r\n  const cached = _complexityCache.get(genome);\r\n  if (cached && cached.nodes === n && cached.conns === c && cached.gates === g)\r\n    return cached.value * growth;\r\n  // Base complexity ignoring growth factor.\r\n  const base = n - genome.input - genome.output + c + g;\r\n  _complexityCache.set(genome, { nodes: n, conns: c, gates: g, value: base });\r\n  return base * growth;\r\n}\r\n\r\n/**\r\n * Build a single-threaded fitness evaluation function (classic NEAT style) evaluating a genome\r\n * over the provided dataset and returning a scalar score where higher is better.\r\n *\r\n * Fitness Definition:\r\n *   fitness = -averageError - complexityPenalty\r\n * We accumulate negative error (so lower error => higher fitness) over `amount` independent\r\n * evaluations (amount>1 can smooth stochastic evaluation noise) then subtract complexity penalty.\r\n *\r\n * Error handling: If evaluation throws (numerical instability, internal error) we return -Infinity\r\n * so such genomes are strongly disfavored.\r\n *\r\n * @param set - Dataset of training samples.\r\n * @param cost - Cost function reference (should expose error computation in genome.test).\r\n * @param amount - Number of repeated evaluations to average.\r\n * @param growth - Complexity penalty scalar.\r\n * @returns Function mapping a Network genome to a numeric fitness.\r\n */\r\nfunction buildSingleThreadFitness(\r\n  set: TrainingSample[],\r\n  cost: any,\r\n  amount: number,\r\n  growth: number\r\n) {\r\n  return (genome: Network) => {\r\n    let score = 0; // Accumulate negative errors.\r\n    for (let i = 0; i < amount; i++) {\r\n      try {\r\n        score -= genome.test(set, cost).error; // negative adds fitness.\r\n      } catch (e: any) {\r\n        if (config.warnings)\r\n          console.warn(\r\n            `Genome evaluation failed: ${\r\n              (e && e.message) || e\r\n            }. Penalizing with -Infinity fitness.`\r\n          );\r\n        return -Infinity;\r\n      }\r\n    }\r\n    // Apply structural parsimony pressure.\r\n    score -= computeComplexityPenalty(genome, growth);\r\n    // Guard against NaN pollution.\r\n    score = isNaN(score) ? -Infinity : score;\r\n    // Average over repeats.\r\n    return score / amount;\r\n  };\r\n}\r\n\r\n/**\r\n * Build a multi-threaded (worker-based) population fitness evaluator if worker infrastructure is available.\r\n *\r\n * Strategy:\r\n *  - Attempt to dynamically obtain a Worker constructor (node or browser variant).\r\n *  - If not possible, gracefully fall back to single-thread evaluation.\r\n *  - Spawn N workers (threads) each capable of evaluating genomes by calling worker.evaluate(genome).\r\n *  - Provide a fitness function that takes the whole population and returns a Promise that resolves\r\n *    when all queued genomes have been processed. Each genome's score is written in-place.\r\n *\r\n * Implementation details:\r\n *  - Queue: simple FIFO (array shift) suffices because ordering is not critical.\r\n *  - Robustness: Each worker evaluation is wrapped with error handling to prevent a single failure\r\n *    from stalling the batch; failed evaluations simply proceed to next genome.\r\n *  - Complexity penalty applied after raw result retrieval: genome.score = -result - penalty.\r\n *\r\n * Returned metadata sets options.fitnessPopulation=true so downstream NEAT logic treats the fitness\r\n * function as operating over the entire population at once (rather than per-genome).\r\n *\r\n * @param set - Dataset.\r\n * @param cost - Cost function.\r\n * @param amount - Repetition count (unused directly here; assumed handled inside worker.evaluate result metric if needed).\r\n * @param growth - Complexity penalty scalar.\r\n * @param threads - Desired worker count.\r\n * @param options - Evolution options object (mutated to add cleanup hooks & flags).\r\n * @returns Object with fitnessFunction (population evaluator) and resolved thread count.\r\n */\r\nasync function buildMultiThreadFitness(\r\n  set: TrainingSample[],\r\n  cost: any,\r\n  amount: number,\r\n  growth: number,\r\n  threads: number,\r\n  options: any\r\n) {\r\n  // Serialize dataset once for worker initialization (avoids deep cloning per evaluation call).\r\n  const serializedSet = Multi.serializeDataSet(set);\r\n  /** Collection of worker instances. */\r\n  const workers: any[] = [];\r\n  let WorkerCtor: any = null; // Will hold dynamic Worker class.\r\n  try {\r\n    const isNode =\r\n      typeof process !== 'undefined' && !!(process.versions as any)?.node;\r\n    if (isNode && Multi.workers?.getNodeTestWorker)\r\n      WorkerCtor = await Multi.workers.getNodeTestWorker();\r\n    else if (!isNode && Multi.workers?.getBrowserTestWorker)\r\n      WorkerCtor = await Multi.workers.getBrowserTestWorker();\r\n  } catch (e) {\r\n    if (config.warnings)\r\n      console.warn(\r\n        'Failed to load worker class; falling back to single-thread path:',\r\n        (e as any)?.message || e\r\n      );\r\n  }\r\n  // Fallback path if no worker support.\r\n  if (!WorkerCtor)\r\n    return {\r\n      fitnessFunction: buildSingleThreadFitness(set, cost, amount, growth),\r\n      threads: 1,\r\n    };\r\n  // Spin up requested workers (best-effort; partial successes still useful).\r\n  for (let i = 0; i < threads; i++) {\r\n    try {\r\n      workers.push(\r\n        new WorkerCtor(serializedSet, {\r\n          name: cost.name || cost.toString?.() || 'cost',\r\n        })\r\n      );\r\n    } catch (e) {\r\n      if (config.warnings) console.warn('Worker spawn failed', e);\r\n    }\r\n  }\r\n  // Population-level fitness function: resolves when all genomes processed.\r\n  const fitnessFunction = (population: Network[]) =>\r\n    new Promise<void>((resolve) => {\r\n      if (!workers.length) {\r\n        resolve();\r\n        return;\r\n      }\r\n      const queue = population.slice(); // Shallow copy so we can mutate.\r\n      let active = workers.length; // Number of workers still draining tasks.\r\n      const startNext = (worker: any) => {\r\n        if (!queue.length) {\r\n          if (--active === 0) resolve();\r\n          return;\r\n        }\r\n        const genome = queue.shift();\r\n        worker\r\n          .evaluate(genome)\r\n          .then((result: number) => {\r\n            if (typeof genome !== 'undefined' && typeof result === 'number') {\r\n              genome.score = -result - computeComplexityPenalty(genome, growth);\r\n              genome.score = isNaN(result) ? -Infinity : genome.score;\r\n            }\r\n            startNext(worker); // Tail recursion style loop.\r\n          })\r\n          .catch(() => startNext(worker)); // On error: skip but keep draining.\r\n      };\r\n      workers.forEach((w) => startNext(w));\r\n    });\r\n  options.fitnessPopulation = true; // Signal population-level semantics.\r\n  // Provide cleanup hook (used after evolution loop) to terminate workers.\r\n  (options as any)._workerTerminators = () => {\r\n    workers.forEach((w) => {\r\n      try {\r\n        w.terminate && w.terminate();\r\n      } catch {}\r\n    });\r\n  };\r\n  return { fitnessFunction, threads };\r\n}\r\n\r\n/**\r\n * Evolve (optimize) the current network's topology and weights using a NEAT-like evolutionary loop\r\n * until a stopping criterion (target error or max iterations) is met.\r\n *\r\n * High-level process:\r\n *  1. Validate dataset shape (input/output vector sizes must match network I/O counts).\r\n *  2. Normalize / default option values and construct an internal configuration summary.\r\n *  3. Build appropriate fitness evaluation function (single or multi-thread).\r\n *  4. Initialize a Neat population (optionally with speciation) seeded by this network.\r\n *  5. Iteratively call neat.evolve():\r\n *       - Retrieve fittest genome + its fitness.\r\n *       - Derive an error metric from fitness (inverse relationship considering complexity penalty).\r\n *       - Track best genome overall (elitism) and perform logging/scheduling callbacks.\r\n *       - Break if error criterion satisfied or iterations exceeded.\r\n *  6. Replace this network's internal structural arrays with the best discovered genome's (in-place upgrade).\r\n *  7. Cleanup any worker threads and report final statistics.\r\n *\r\n * Fitness / Error relationship:\r\n *   fitness = -error - complexityPenalty  =>  error = -(fitness - complexityPenalty)\r\n * We recompute error from the stored fitness plus penalty to ensure consistent reporting.\r\n *\r\n * Resilience strategies:\r\n *  - Guard against infinite / NaN errors; after MAX_INF consecutive invalid errors we abort.\r\n *  - Fallback for tiny populations: increase mutation aggressiveness to prevent premature convergence.\r\n *\r\n * @param this - Bound {@link Network} instance being evolved in-place.\r\n * @param set - Supervised dataset (array of {input, output}).\r\n * @param options - Evolution options (see README / docs). Key fields include:\r\n *    - iterations: maximum generations (if omitted must supply error target)\r\n *    - error: target error threshold (if omitted must supply iterations)\r\n *    - growth: complexity penalty scaling\r\n *    - amount: number of score evaluations (averaged) per genome\r\n *    - threads: desired worker count (>=2 enables multi-thread path if available)\r\n *    - popsize / populationSize: population size\r\n *    - schedule: { iterations: number, function: (ctx) => void } periodic callback\r\n *    - log: generation interval for console logging\r\n *    - clear: whether to call network.clear() after adopting best genome\r\n * @returns Summary object { error, iterations, time(ms) }.\r\n * @throws If dataset is empty or dimensionally incompatible, or if neither iterations nor error is specified.\r\n */\r\nexport async function evolveNetwork(\r\n  this: Network,\r\n  set: TrainingSample[],\r\n  options: any\r\n): Promise<{ error: number; iterations: number; time: number }> {\r\n  // 1. Dataset validation (shape + existence).\r\n  if (\r\n    !set ||\r\n    set.length === 0 ||\r\n    set[0].input.length !== this.input ||\r\n    set[0].output.length !== this.output\r\n  ) {\r\n    throw new Error(\r\n      'Dataset is invalid or dimensions do not match network input/output size!'\r\n    );\r\n  }\r\n  // Defensive defaulting.\r\n  options = options || {};\r\n  let targetError: number = options.error ?? 0.05; // Default target error if provided unspecified.\r\n  const growth: number = options.growth ?? 0.0001; // Complexity penalty scaling.\r\n  const cost = options.cost || methods.Cost.mse; // Default cost function.\r\n  const amount: number = options.amount || 1; // Repetition count for averaging.\r\n  const log: number = options.log || 0; // Logging interval (0 disables).\r\n  const schedule = options.schedule; // Optional user schedule callback spec.\r\n  const clear: boolean = options.clear || false; // Whether to clear state after structural adoption.\r\n  let threads: number =\r\n    typeof options.threads === 'undefined' ? 1 : options.threads; // Worker count.\r\n  const start = Date.now(); // Benchmark start time.\r\n  const evoConfig: EvolutionConfig = {\r\n    targetError,\r\n    growth,\r\n    cost,\r\n    amount,\r\n    log,\r\n    schedule,\r\n    clear,\r\n    threads,\r\n  }; // (Currently unused externally; placeholder for future structured logging.)\r\n\r\n  // 2. Stopping condition checks / normalization.\r\n  if (\r\n    typeof options.iterations === 'undefined' &&\r\n    typeof options.error === 'undefined'\r\n  ) {\r\n    throw new Error(\r\n      'At least one stopping condition (`iterations` or `error`) must be specified for evolution.'\r\n    );\r\n  } else if (typeof options.error === 'undefined') targetError = -1;\r\n  // Only iterations constrain.\r\n  else if (typeof options.iterations === 'undefined') options.iterations = 0; // Only error constrains (0 sentinel lets loop run until satisfied).\r\n\r\n  // 3. Build fitness function (single or multi-thread variant).\r\n  let fitnessFunction: any;\r\n  if (threads === 1)\r\n    fitnessFunction = buildSingleThreadFitness(set, cost, amount, growth);\r\n  else {\r\n    const multi = await buildMultiThreadFitness(\r\n      set,\r\n      cost,\r\n      amount,\r\n      growth,\r\n      threads,\r\n      options\r\n    );\r\n    fitnessFunction = multi.fitnessFunction;\r\n    threads = multi.threads;\r\n  }\r\n\r\n  // Provide network reference for NEAT initialization / reproduction methods.\r\n  options.network = this;\r\n  // Alias populationSize -> popsize for backward compat.\r\n  if (options.populationSize != null && options.popsize == null)\r\n    options.popsize = options.populationSize;\r\n  // Speciation default off unless explicitly enabled (simpler baseline behavior).\r\n  if (typeof options.speciation === 'undefined') options.speciation = false;\r\n\r\n  // 4. Lazy import NEAT (avoid heavier modules if evolve isn't used).\r\n  const { default: Neat } = await import('../../neat');\r\n  const neat = new Neat(this.input, this.output, fitnessFunction, options);\r\n\r\n  // Warn if immediate termination conditions could yield empty best genome tracking.\r\n  if (typeof options.iterations === 'number' && options.iterations === 0) {\r\n    if ((neat as any)._warnIfNoBestGenome) {\r\n      try {\r\n        (neat as any)._warnIfNoBestGenome();\r\n      } catch {}\r\n    }\r\n  }\r\n  // Micro-population heuristics: increase mutation intensity to promote exploration.\r\n  if (options.popsize && options.popsize <= 10) {\r\n    neat.options.mutationRate = neat.options.mutationRate ?? 0.5;\r\n    neat.options.mutationAmount = neat.options.mutationAmount ?? 1;\r\n  }\r\n\r\n  // 5. Evolution loop state variables.\r\n  let error = Infinity; // Best error observed this generation (derived from fitness).\r\n  let bestFitness = -Infinity; // Track highest fitness seen.\r\n  let bestGenome: Network | undefined; // Best genome snapshot.\r\n  let infiniteErrorCount = 0; // Consecutive invalid error tallies.\r\n  const MAX_INF = 5; // Abort threshold to prevent endless invalid loops.\r\n  const iterationsSpecified = typeof options.iterations === 'number';\r\n\r\n  // 5a. Main generation loop (terminates on error target or iteration cap).\r\n  while (\r\n    (targetError === -1 || error > targetError) &&\r\n    (!iterationsSpecified || neat.generation < options.iterations)\r\n  ) {\r\n    // Perform one generation: breed + evaluate population, returning fittest genome.\r\n    const fittest = await neat.evolve();\r\n    const fitness = fittest.score ?? -Infinity;\r\n    // Derive error metric from fitness (undo sign & complexity adjustment) with fallback Infinity.\r\n    error = -(fitness - computeComplexityPenalty(fittest, growth)) || Infinity;\r\n    // Update elite if improved.\r\n    if (fitness > bestFitness) {\r\n      bestFitness = fitness;\r\n      bestGenome = fittest;\r\n    }\r\n    // Detect runaway invalid values.\r\n    if (!isFinite(error) || isNaN(error)) {\r\n      if (++infiniteErrorCount >= MAX_INF) break;\r\n    } else infiniteErrorCount = 0;\r\n    // User schedule callback hook.\r\n    if (schedule && neat.generation % schedule.iterations === 0) {\r\n      try {\r\n        schedule.function({\r\n          fitness: bestFitness,\r\n          error,\r\n          iteration: neat.generation,\r\n        });\r\n      } catch {}\r\n    }\r\n  }\r\n\r\n  // 6. Adopt best genome's structure into this network instance (in-place upgrade) if available.\r\n  if (typeof bestGenome !== 'undefined') {\r\n    this.nodes = bestGenome.nodes;\r\n    this.connections = bestGenome.connections;\r\n    this.selfconns = bestGenome.selfconns;\r\n    this.gates = bestGenome.gates;\r\n    if (clear) this.clear();\r\n  } else if ((neat as any)._warnIfNoBestGenome) {\r\n    try {\r\n      (neat as any)._warnIfNoBestGenome();\r\n    } catch {}\r\n  }\r\n\r\n  // 7. Cleanup worker resources if any.\r\n  try {\r\n    (options as any)._workerTerminators &&\r\n      (options as any)._workerTerminators();\r\n  } catch {}\r\n\r\n  return { error, iterations: neat.generation, time: Date.now() - start };\r\n}\r\n", "import Node from './node';\r\nimport Connection from './connection';\r\nimport Multi from '../multithreading/multi';\r\nimport * as methods from '../methods/methods';\r\nimport mutation from '../methods/mutation'; // Import mutation methods\r\nimport { config } from '../config'; // Import configuration settings\r\nimport { activationArrayPool, ActivationArray } from './activationArrayPool';\r\n// ONNX export/import now lives in ./network/network.onnx (re-exported via ./onnx for backwards compat)\r\nimport { exportToONNX } from './onnx';\r\nimport { generateStandalone } from './network/network.standalone';\r\nimport {\r\n  computeTopoOrder as _computeTopoOrder,\r\n  hasPath as _hasPath,\r\n} from './network/network.topology';\r\nimport {\r\n  rebuildConnectionSlab as _rebuildConnectionSlab,\r\n  fastSlabActivate as _fastSlabActivate,\r\n  canUseFastSlab as _canUseFastSlab,\r\n  getConnectionSlab as _getConnectionSlab,\r\n} from './network/network.slab';\r\nimport {\r\n  maybePrune as _maybePrune,\r\n  pruneToSparsity as _pruneToSparsity,\r\n  getCurrentSparsity as _getCurrentSparsity,\r\n} from './network/network.prune';\r\nimport {\r\n  gate as _gate,\r\n  ungate as _ungate,\r\n  removeNode as _removeNode,\r\n} from './network/network.gating';\r\nimport {\r\n  setSeed as _setSeed,\r\n  snapshotRNG as _snapshotRNG,\r\n  restoreRNG as _restoreRNG,\r\n  getRNGState as _getRNGState,\r\n  setRNGState as _setRNGState,\r\n} from './network/network.deterministic';\r\nimport { getRegularizationStats as _getRegularizationStats } from './network/network.stats';\r\nimport { removeNode as _removeNodeStandalone } from './network/network.remove';\r\nimport {\r\n  connect as _connect,\r\n  disconnect as _disconnect,\r\n} from './network/network.connect';\r\nimport {\r\n  serialize as _serialize,\r\n  deserialize as _deserialize,\r\n  toJSONImpl as _toJSONImpl,\r\n  fromJSONImpl as _fromJSONImpl,\r\n} from './network/network.serialize';\r\nimport { crossOver as _crossOver } from './network/network.genetic';\r\n\r\nexport default class Network {\r\n  input: number;\r\n  output: number;\r\n  score?: number;\r\n  nodes: Node[];\r\n  connections: Connection[];\r\n  gates: Connection[];\r\n  selfconns: Connection[];\r\n  dropout: number = 0;\r\n  private _dropConnectProb: number = 0;\r\n  private _lastGradNorm?: number;\r\n  private _optimizerStep: number = 0;\r\n  private _weightNoiseStd: number = 0;\r\n  private _weightNoisePerHidden: number[] = [];\r\n  private _weightNoiseSchedule?: (step: number) => number;\r\n  private _stochasticDepth: number[] = [];\r\n  private _wnOrig?: number[];\r\n  private _trainingStep: number = 0;\r\n  private _rand: () => number = Math.random;\r\n  private _rngState?: number;\r\n  private _lastStats: any = null;\r\n  private _stochasticDepthSchedule?: (\r\n    step: number,\r\n    current: number[]\r\n  ) => number[];\r\n  private _mixedPrecision: { enabled: boolean; lossScale: number } = {\r\n    enabled: false,\r\n    lossScale: 1,\r\n  };\r\n  private _mixedPrecisionState: {\r\n    goodSteps: number;\r\n    badSteps: number;\r\n    minLossScale: number;\r\n    maxLossScale: number;\r\n    overflowCount?: number;\r\n    scaleUpEvents?: number;\r\n    scaleDownEvents?: number;\r\n  } = {\r\n    goodSteps: 0,\r\n    badSteps: 0,\r\n    minLossScale: 1,\r\n    maxLossScale: 65536,\r\n    overflowCount: 0,\r\n    scaleUpEvents: 0,\r\n    scaleDownEvents: 0,\r\n  };\r\n  private _gradAccumMicroBatches: number = 0;\r\n  private _currentGradClip?: {\r\n    mode: 'norm' | 'percentile' | 'layerwiseNorm' | 'layerwisePercentile';\r\n    maxNorm?: number;\r\n    percentile?: number;\r\n  };\r\n  private _lastRawGradNorm: number = 0;\r\n  private _accumulationReduction: 'average' | 'sum' = 'average';\r\n  private _gradClipSeparateBias: boolean = false;\r\n  private _lastGradClipGroupCount: number = 0;\r\n  private _lastOverflowStep: number = -1;\r\n  private _forceNextOverflow: boolean = false;\r\n  private _pruningConfig?: {\r\n    start: number;\r\n    end: number;\r\n    targetSparsity: number;\r\n    regrowFraction: number;\r\n    frequency: number;\r\n    method: 'magnitude' | 'snip';\r\n    lastPruneIter?: number;\r\n  };\r\n  private _initialConnectionCount?: number;\r\n  private _enforceAcyclic: boolean = false;\r\n  private _topoOrder: Node[] | null = null;\r\n  private _topoDirty: boolean = true;\r\n  private _globalEpoch: number = 0;\r\n  layers?: any[];\r\n  private _evoInitialConnCount?: number; // baseline for evolution-time pruning\r\n  private _activationPrecision: 'f64' | 'f32' = 'f64'; // typed array precision for compiled path\r\n  private _reuseActivationArrays: boolean = false; // reuse pooled output arrays\r\n  private _returnTypedActivations: boolean = false; // if true and reuse enabled, return typed array directly\r\n  private _activationPool?: Float32Array | Float64Array; // pooled output array\r\n  // Packed connection slab fields (for memory + cache efficiency when iterating connections)\r\n  private _connWeights?: Float32Array | Float64Array;\r\n  private _connFrom?: Uint32Array;\r\n  private _connTo?: Uint32Array;\r\n  private _slabDirty: boolean = true;\r\n  private _useFloat32Weights: boolean = true;\r\n  // Cached node.index maintenance (avoids repeated this.nodes.indexOf in hot paths like slab rebuild)\r\n  private _nodeIndexDirty: boolean = true; // when true, node.index values must be reassigned sequentially\r\n  // Fast slab forward path structures\r\n  private _outStart?: Uint32Array;\r\n  private _outOrder?: Uint32Array;\r\n  private _adjDirty: boolean = true;\r\n  // Cached typed arrays for fast slab forward pass\r\n  private _fastA?: Float32Array | Float64Array;\r\n  private _fastS?: Float32Array | Float64Array;\r\n  // Internal hint: track a preferred linear chain edge to split on subsequent ADD_NODE mutations\r\n  // to encourage deep path formation even in stochastic modes. Updated each time we split it.\r\n  private _preferredChainEdge?: Connection;\r\n\r\n  // Slab helpers delegated to network.slab.ts\r\n  private _canUseFastSlab(training: boolean) {\r\n    return _canUseFastSlab.call(this, training);\r\n  }\r\n  private _fastSlabActivate(input: number[]) {\r\n    return _fastSlabActivate.call(this, input);\r\n  }\r\n  rebuildConnectionSlab(force = false) {\r\n    return _rebuildConnectionSlab.call(this, force);\r\n  }\r\n  getConnectionSlab() {\r\n    return _getConnectionSlab.call(this);\r\n  }\r\n  constructor(\r\n    input: number,\r\n    output: number,\r\n    options?: {\r\n      minHidden?: number;\r\n      seed?: number;\r\n      enforceAcyclic?: boolean;\r\n      activationPrecision?: 'f32' | 'f64';\r\n      reuseActivationArrays?: boolean;\r\n      returnTypedActivations?: boolean;\r\n    }\r\n  ) {\r\n    // Validate that input and output sizes are provided.\r\n    if (typeof input === 'undefined' || typeof output === 'undefined') {\r\n      throw new Error('No input or output size given');\r\n    }\r\n\r\n    // Initialize network properties\r\n    this.input = input;\r\n    this.output = output;\r\n    this.nodes = [];\r\n    this.connections = [];\r\n    this.gates = [];\r\n    this.selfconns = [];\r\n    this.dropout = 0;\r\n    this._enforceAcyclic = (options as any)?.enforceAcyclic || false;\r\n    if (options?.activationPrecision) {\r\n      this._activationPrecision = options.activationPrecision;\r\n    } else if (config.float32Mode) {\r\n      this._activationPrecision = 'f32';\r\n    }\r\n    if (options?.reuseActivationArrays) this._reuseActivationArrays = true;\r\n    if (options?.returnTypedActivations) this._returnTypedActivations = true;\r\n    // Configure and prewarm the activation pool based on global config\r\n    try {\r\n      if (typeof config.poolMaxPerBucket === 'number')\r\n        activationArrayPool.setMaxPerBucket(config.poolMaxPerBucket);\r\n      const prewarm =\r\n        typeof config.poolPrewarmCount === 'number'\r\n          ? config.poolPrewarmCount\r\n          : 2;\r\n      activationArrayPool.prewarm(this.output, prewarm);\r\n    } catch {}\r\n\r\n    if (options?.seed !== undefined) {\r\n      this.setSeed(options.seed);\r\n    }\r\n\r\n    for (let i = 0; i < this.input + this.output; i++) {\r\n      const type = i < this.input ? 'input' : 'output';\r\n      this.nodes.push(new Node(type, undefined, this._rand));\r\n    }\r\n    for (let i = 0; i < this.input; i++) {\r\n      for (let j = this.input; j < this.input + this.output; j++) {\r\n        const weight = this._rand() * this.input * Math.sqrt(2 / this.input);\r\n        this.connect(this.nodes[i], this.nodes[j], weight);\r\n      }\r\n    }\r\n\r\n    const minHidden = options?.minHidden || 0;\r\n    if (minHidden > 0) {\r\n      while (this.nodes.length < this.input + this.output + minHidden) {\r\n        this.addNodeBetween();\r\n      }\r\n    }\r\n  }\r\n\r\n  // --- Added: structural helper referenced by constructor (split a random connection) ---\r\n  private addNodeBetween(): void {\r\n    if (this.connections.length === 0) return;\r\n    const idx = Math.floor(this._rand() * this.connections.length);\r\n    const conn = this.connections[idx];\r\n    if (!conn) return;\r\n    // Remove original connection\r\n    this.disconnect(conn.from, conn.to);\r\n    // Create new hidden node\r\n    const newNode = new Node('hidden', undefined, this._rand);\r\n    this.nodes.push(newNode);\r\n    // Connect from->newNode and newNode->to\r\n    this.connect(conn.from, newNode, conn.weight); // keep original weight on first leg\r\n    this.connect(newNode, conn.to, 1); // second leg weight initialised randomly or 1\r\n    // Invalidate topo cache\r\n    this._topoDirty = true;\r\n    this._nodeIndexDirty = true; // structure changed\r\n  }\r\n\r\n  // --- DropConnect API (re-added for tests) ---\r\n  enableDropConnect(p: number) {\r\n    if (p < 0 || p >= 1)\r\n      throw new Error('DropConnect probability must be in [0,1)');\r\n    this._dropConnectProb = p;\r\n  }\r\n  disableDropConnect() {\r\n    this._dropConnectProb = 0;\r\n  }\r\n\r\n  // --- Acyclic enforcement toggle (used by tests) ---\r\n  setEnforceAcyclic(flag: boolean) {\r\n    this._enforceAcyclic = !!flag;\r\n  }\r\n  private _computeTopoOrder() {\r\n    return _computeTopoOrder.call(this);\r\n  }\r\n  private _hasPath(from: Node, to: Node) {\r\n    return _hasPath.call(this, from, to);\r\n  }\r\n\r\n  // --- Pruning configuration & helpers ---\r\n  configurePruning(cfg: {\r\n    start: number;\r\n    end: number;\r\n    targetSparsity: number;\r\n    regrowFraction?: number;\r\n    frequency?: number;\r\n    method?: 'magnitude' | 'snip';\r\n  }) {\r\n    const { start, end, targetSparsity } = cfg;\r\n    if (start < 0 || end < start)\r\n      throw new Error('Invalid pruning schedule window');\r\n    if (targetSparsity <= 0 || targetSparsity >= 1)\r\n      throw new Error('targetSparsity must be in (0,1)');\r\n    this._pruningConfig = {\r\n      start,\r\n      end,\r\n      targetSparsity,\r\n      regrowFraction: cfg.regrowFraction ?? 0,\r\n      frequency: cfg.frequency ?? 1,\r\n      method: cfg.method || 'magnitude',\r\n      lastPruneIter: undefined,\r\n    };\r\n    this._initialConnectionCount = this.connections.length;\r\n  }\r\n  getCurrentSparsity(): number {\r\n    return _getCurrentSparsity.call(this);\r\n  }\r\n  private _maybePrune(iteration: number) {\r\n    return _maybePrune.call(this, iteration);\r\n  }\r\n\r\n  /**\r\n   * Immediately prune connections to reach (or approach) a target sparsity fraction.\r\n   * Used by evolutionary pruning (generation-based) independent of training iteration schedule.\r\n   * @param targetSparsity fraction in (0,1). 0.8 means keep 20% of original (if first call sets baseline)\r\n   * @param method 'magnitude' | 'snip'\r\n   */\r\n  pruneToSparsity(\r\n    targetSparsity: number,\r\n    method: 'magnitude' | 'snip' = 'magnitude'\r\n  ) {\r\n    return _pruneToSparsity.call(this, targetSparsity, method);\r\n  }\r\n\r\n  /** Enable weight noise. Provide a single std dev number or { perHiddenLayer: number[] }. */\r\n  enableWeightNoise(stdDev: number | { perHiddenLayer: number[] }) {\r\n    if (typeof stdDev === 'number') {\r\n      if (stdDev < 0) throw new Error('Weight noise stdDev must be >= 0');\r\n      this._weightNoiseStd = stdDev;\r\n      this._weightNoisePerHidden = [];\r\n    } else if (stdDev && Array.isArray(stdDev.perHiddenLayer)) {\r\n      if (!this.layers || this.layers.length < 3)\r\n        throw new Error(\r\n          'Per-hidden-layer weight noise requires a layered network with at least one hidden layer'\r\n        );\r\n      const hiddenLayerCount = this.layers.length - 2;\r\n      if (stdDev.perHiddenLayer.length !== hiddenLayerCount)\r\n        throw new Error(\r\n          `Expected ${hiddenLayerCount} std dev entries (one per hidden layer), got ${stdDev.perHiddenLayer.length}`\r\n        );\r\n      if (stdDev.perHiddenLayer.some((s) => s < 0))\r\n        throw new Error('Weight noise std devs must be >= 0');\r\n      this._weightNoiseStd = 0; // disable global\r\n      this._weightNoisePerHidden = stdDev.perHiddenLayer.slice();\r\n    } else {\r\n      throw new Error('Invalid weight noise configuration');\r\n    }\r\n  }\r\n  disableWeightNoise() {\r\n    this._weightNoiseStd = 0;\r\n    this._weightNoisePerHidden = [];\r\n  }\r\n  setWeightNoiseSchedule(fn: (step: number) => number) {\r\n    this._weightNoiseSchedule = fn;\r\n  }\r\n  clearWeightNoiseSchedule() {\r\n    this._weightNoiseSchedule = undefined;\r\n  }\r\n  setRandom(fn: () => number) {\r\n    this._rand = fn;\r\n  }\r\n  setSeed(seed: number) {\r\n    _setSeed.call(this, seed);\r\n  }\r\n  testForceOverflow() {\r\n    this._forceNextOverflow = true;\r\n  }\r\n  get trainingStep() {\r\n    return this._trainingStep;\r\n  }\r\n  get lastSkippedLayers(): number[] {\r\n    return (this as any)._lastSkippedLayers || [];\r\n  }\r\n  snapshotRNG(): any {\r\n    return _snapshotRNG.call(this);\r\n  }\r\n  restoreRNG(fn: () => number) {\r\n    _restoreRNG.call(this, fn);\r\n  }\r\n  getRNGState(): number | undefined {\r\n    return _getRNGState.call(this);\r\n  }\r\n  setRNGState(state: number) {\r\n    _setRNGState.call(this, state);\r\n  }\r\n  setStochasticDepthSchedule(\r\n    fn: (step: number, current: number[]) => number[]\r\n  ) {\r\n    this._stochasticDepthSchedule = fn;\r\n  }\r\n  clearStochasticDepthSchedule() {\r\n    this._stochasticDepthSchedule = undefined;\r\n  }\r\n  getRegularizationStats() {\r\n    return _getRegularizationStats.call(this);\r\n  }\r\n\r\n  /** Configure stochastic depth with survival probabilities per hidden layer (length must match hidden layer count when using layered network). */\r\n  setStochasticDepth(survival: number[]) {\r\n    if (!Array.isArray(survival)) throw new Error('survival must be an array');\r\n    if (survival.some((p) => p <= 0 || p > 1))\r\n      throw new Error('Stochastic depth survival probs must be in (0,1]');\r\n    if (!this.layers || this.layers.length === 0)\r\n      throw new Error('Stochastic depth requires layer-based network');\r\n    // layers includes input and output; hidden layers are layers[1..length-2]\r\n    const hiddenLayerCount = Math.max(0, this.layers.length - 2);\r\n    if (survival.length !== hiddenLayerCount)\r\n      throw new Error(\r\n        `Expected ${hiddenLayerCount} survival probabilities for hidden layers, got ${survival.length}`\r\n      );\r\n    this._stochasticDepth = survival.slice();\r\n  }\r\n  disableStochasticDepth() {\r\n    this._stochasticDepth = [];\r\n  }\r\n\r\n  /**\r\n   * Creates a deep copy of the network.\r\n   * @returns {Network} A new Network instance that is a clone of the current network.\r\n   */\r\n  clone(): Network {\r\n    return Network.fromJSON(this.toJSON());\r\n  }\r\n\r\n  /**\r\n   * Resets all masks in the network to 1 (no dropout). Applies to both node-level and layer-level dropout.\r\n   * Should be called after training to ensure inference is unaffected by previous dropout.\r\n   */\r\n  resetDropoutMasks(): void {\r\n    if (this.layers && this.layers.length > 0) {\r\n      for (const layer of this.layers) {\r\n        if (typeof layer.nodes !== 'undefined') {\r\n          for (const node of layer.nodes) {\r\n            if (typeof node.mask !== 'undefined') node.mask = 1;\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      for (const node of this.nodes) {\r\n        if (typeof node.mask !== 'undefined') node.mask = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Delegated standalone generator\r\n  standalone(): string {\r\n    return generateStandalone(this as any);\r\n  }\r\n\r\n  /**\r\n   * Activates the network using the given input array.\r\n   * Performs a forward pass through the network, calculating the activation of each node.\r\n   *\r\n   * @param {number[]} input - An array of numerical values corresponding to the network's input nodes.\r\n   * @param {boolean} [training=false] - Flag indicating if the activation is part of a training process.\r\n   * @param {number} [maxActivationDepth=1000] - Maximum allowed activation depth to prevent infinite loops/cycles.\r\n   * @returns {number[]} An array of numerical values representing the activations of the network's output nodes.\r\n   */\r\n  /**\r\n   * Standard activation API returning a plain number[] for backward compatibility.\r\n   * Internally may use pooled typed arrays; if so they are cloned before returning.\r\n   */\r\n  activate(\r\n    input: number[],\r\n    training = false,\r\n    maxActivationDepth = 1000\r\n  ): number[] {\r\n    if (this._enforceAcyclic && this._topoDirty) this._computeTopoOrder();\r\n    if (!Array.isArray(input) || input.length !== this.input) {\r\n      throw new Error(\r\n        `Input size mismatch: expected ${this.input}, got ${\r\n          input ? input.length : 'undefined'\r\n        }`\r\n      );\r\n    }\r\n    // Fast slab path (inference-only, ungated, acyclic, no stochastic features)\r\n    if (this._canUseFastSlab(training)) {\r\n      try {\r\n        return this._fastSlabActivate(input);\r\n      } catch {\r\n        /* fall back */\r\n      }\r\n    }\r\n    // Acquire pooled activation array for outputs\r\n    const outputArr = activationArrayPool.acquire(this.output);\r\n\r\n    // Check for empty or corrupted network structure\r\n    if (!this.nodes || this.nodes.length === 0) {\r\n      throw new Error(\r\n        'Network structure is corrupted or empty. No nodes found.'\r\n      );\r\n    }\r\n\r\n    let output: ActivationArray = outputArr;\r\n    (this as any)._lastSkippedLayers = [];\r\n    const stats = {\r\n      droppedHiddenNodes: 0,\r\n      totalHiddenNodes: 0,\r\n      droppedConnections: 0,\r\n      totalConnections: this.connections.length,\r\n      skippedLayers: [] as number[],\r\n      weightNoise: { count: 0, sumAbs: 0, maxAbs: 0, meanAbs: 0 },\r\n    };\r\n    // Pre-apply weight noise\r\n    let appliedWeightNoise = false;\r\n    let dynamicStd = this._weightNoiseStd;\r\n    if (training) {\r\n      if (this._weightNoiseSchedule)\r\n        dynamicStd = this._weightNoiseSchedule(this._trainingStep);\r\n      if (dynamicStd > 0 || this._weightNoisePerHidden.length > 0) {\r\n        for (const c of this.connections) {\r\n          if ((c as any)._origWeightNoise != null) continue;\r\n          (c as any)._origWeightNoise = c.weight;\r\n          let std = dynamicStd;\r\n          if (this._weightNoisePerHidden.length > 0 && this.layers) {\r\n            let fromLayerIndex = -1;\r\n            for (let li = 0; li < this.layers.length; li++) {\r\n              if (this.layers[li].nodes.includes(c.from)) {\r\n                fromLayerIndex = li;\r\n                break;\r\n              }\r\n            }\r\n            if (fromLayerIndex > 0 && fromLayerIndex < this.layers.length) {\r\n              const hiddenIdx = fromLayerIndex - 1;\r\n              if (\r\n                hiddenIdx >= 0 &&\r\n                hiddenIdx < this._weightNoisePerHidden.length\r\n              )\r\n                std = this._weightNoisePerHidden[hiddenIdx];\r\n            }\r\n          }\r\n          if (std > 0) {\r\n            const noise = std * Network._gaussianRand(this._rand);\r\n            c.weight += noise;\r\n            (c as any)._wnLast = noise;\r\n            appliedWeightNoise = true;\r\n          } else {\r\n            (c as any)._wnLast = 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Optional stochastic depth schedule update\r\n    if (\r\n      training &&\r\n      this._stochasticDepthSchedule &&\r\n      this._stochasticDepth.length > 0\r\n    ) {\r\n      const updated = this._stochasticDepthSchedule(\r\n        this._trainingStep,\r\n        this._stochasticDepth.slice()\r\n      );\r\n      if (\r\n        Array.isArray(updated) &&\r\n        updated.length === this._stochasticDepth.length &&\r\n        !updated.some((p) => p <= 0 || p > 1)\r\n      ) {\r\n        this._stochasticDepth = updated.slice();\r\n      }\r\n    }\r\n    if (\r\n      this.layers &&\r\n      this.layers.length > 0 &&\r\n      this._stochasticDepth.length > 0\r\n    ) {\r\n      // Layered activation with stochastic depth\r\n      let acts: number[] | undefined;\r\n      for (let li = 0; li < this.layers.length; li++) {\r\n        const layer = this.layers[li];\r\n        const isHidden = li > 0 && li < this.layers.length - 1;\r\n        let skip = false;\r\n        if (training && isHidden) {\r\n          const hiddenIndex = li - 1;\r\n          if (hiddenIndex < this._stochasticDepth.length) {\r\n            const surviveProb = this._stochasticDepth[hiddenIndex];\r\n            skip = this._rand() >= surviveProb;\r\n            if (skip) {\r\n              // Only skip if size matches previous outputs\r\n              if (!acts || acts.length !== layer.nodes.length) skip = false;\r\n            }\r\n            if (!skip) {\r\n              // Activate (input layer gets input array)\r\n              const raw =\r\n                li === 0\r\n                  ? layer.activate(input, training)\r\n                  : layer.activate(undefined, training);\r\n              acts =\r\n                surviveProb < 1\r\n                  ? raw.map((a: number) => a * (1 / surviveProb))\r\n                  : raw;\r\n              continue;\r\n            }\r\n          }\r\n        }\r\n        if (skip) {\r\n          (this as any)._lastSkippedLayers.push(li);\r\n          stats.skippedLayers.push(li);\r\n          // identity: acts unchanged\r\n          continue;\r\n        }\r\n        const raw =\r\n          li === 0\r\n            ? layer.activate(input, training)\r\n            : layer.activate(undefined, training);\r\n        acts = raw;\r\n      }\r\n      if (acts) {\r\n        for (let i = 0; i < acts.length && i < this.output; i++)\r\n          output[i] = acts[i];\r\n      }\r\n    } else if (this.layers && this.layers.length > 0) {\r\n      // Layered activation with optional node-level dropout (replicating legacy behavior expected by tests)\r\n      let lastActs: number[] | undefined;\r\n      for (let li = 0; li < this.layers.length; li++) {\r\n        const layer = this.layers[li];\r\n        const isHidden = li > 0 && li < this.layers.length - 1;\r\n        // Always call layer.activate with training=false to avoid its uniform layer-level dropout; we'll handle per-node masks ourselves\r\n        const raw =\r\n          li === 0\r\n            ? layer.activate(input, false)\r\n            : layer.activate(undefined, false);\r\n        // Apply node-level dropout to hidden layers if requested\r\n        if (isHidden && training && this.dropout > 0) {\r\n          let dropped = 0;\r\n          for (const node of layer.nodes) {\r\n            node.mask = this._rand() < this.dropout ? 0 : 1;\r\n            stats.totalHiddenNodes++;\r\n            if (node.mask === 0) stats.droppedHiddenNodes++;\r\n            if (node.mask === 0) {\r\n              node.activation = 0; // zero activation so downstream sees dropout\r\n              dropped++;\r\n            }\r\n          }\r\n          // Safeguard: ensure at least one active node remains\r\n          if (dropped === layer.nodes.length && layer.nodes.length > 0) {\r\n            const idx = Math.floor(this._rand() * layer.nodes.length);\r\n            layer.nodes[idx].mask = 1;\r\n            // Recompute activation for that single node using previous layer outputs\r\n            // Simplified: keep existing raw value captured earlier in raw[idx]\r\n            layer.nodes[idx].activation = raw[idx];\r\n          }\r\n        } else if (isHidden) {\r\n          // Ensure masks are 1 during inference\r\n          for (const node of layer.nodes) node.mask = 1;\r\n        }\r\n        lastActs = raw; // (raw may have been partially zeroed above via node.activation edits; raw array still original but not used after output layer)\r\n      }\r\n      if (lastActs) {\r\n        if (this._reuseActivationArrays) {\r\n          for (let i = 0; i < lastActs.length && i < this.output; i++)\r\n            (output as any)[i] = lastActs[i];\r\n        } else {\r\n          for (let i = 0; i < lastActs.length && i < this.output; i++)\r\n            (output as any)[i] = lastActs[i];\r\n        }\r\n      }\r\n    } else {\r\n      // Node-based activation (legacy, node-level dropout)\r\n      let hiddenNodes = this.nodes.filter((node) => node.type === 'hidden');\r\n      let droppedCount = 0;\r\n      if (training && this.dropout > 0) {\r\n        // Randomly drop hidden nodes\r\n        for (const node of hiddenNodes) {\r\n          node.mask = this._rand() < this.dropout ? 0 : 1;\r\n          stats.totalHiddenNodes++;\r\n          if (node.mask === 0) {\r\n            droppedCount++;\r\n            stats.droppedHiddenNodes++;\r\n          }\r\n        }\r\n        // SAFEGUARD: Ensure at least one hidden node is active\r\n        if (droppedCount === hiddenNodes.length && hiddenNodes.length > 0) {\r\n          // Randomly pick one hidden node to keep active\r\n          const idx = Math.floor(this._rand() * hiddenNodes.length);\r\n          hiddenNodes[idx].mask = 1;\r\n        }\r\n      } else {\r\n        for (const node of hiddenNodes) node.mask = 1;\r\n      }\r\n      // Optional weight noise (apply before node activations to all connection weights, store originals)\r\n      if (training && this._weightNoiseStd > 0) {\r\n        if (!this._wnOrig) this._wnOrig = new Array(this.connections.length);\r\n        for (let ci = 0; ci < this.connections.length; ci++) {\r\n          const c = this.connections[ci];\r\n          if ((c as any)._origWeightNoise != null) continue; // already perturbed in recursive call\r\n          (c as any)._origWeightNoise = c.weight;\r\n          const noise =\r\n            this._weightNoiseStd * Network._gaussianRand(this._rand);\r\n          c.weight += noise;\r\n        }\r\n      }\r\n      let outIndex = 0;\r\n      this.nodes.forEach((node, index) => {\r\n        if (node.type === 'input') {\r\n          node.activate(input[index]);\r\n        } else if (node.type === 'output') {\r\n          const activation = node.activate();\r\n          (output as any)[outIndex++] = activation;\r\n        } else {\r\n          node.activate();\r\n        }\r\n      });\r\n      // Apply DropConnect masking to connections post-activation accumulation\r\n      if (training && this._dropConnectProb > 0) {\r\n        for (const conn of this.connections) {\r\n          const mask = this._rand() < this._dropConnectProb ? 0 : 1;\r\n          if (mask === 0) stats.droppedConnections++;\r\n          (conn as any).dcMask = mask;\r\n          if (mask === 0) {\r\n            if ((conn as any)._origWeight == null)\r\n              (conn as any)._origWeight = conn.weight;\r\n            conn.weight = 0;\r\n          } else if ((conn as any)._origWeight != null) {\r\n            conn.weight = (conn as any)._origWeight;\r\n            delete (conn as any)._origWeight;\r\n          }\r\n        }\r\n      } else {\r\n        // restore any temporarily zeroed weights\r\n        for (const conn of this.connections) {\r\n          if ((conn as any)._origWeight != null) {\r\n            conn.weight = (conn as any)._origWeight;\r\n            delete (conn as any)._origWeight;\r\n          }\r\n          (conn as any).dcMask = 1;\r\n        }\r\n      }\r\n      // Restore weight noise\r\n      if (training && appliedWeightNoise) {\r\n        for (const c of this.connections) {\r\n          if ((c as any)._origWeightNoise != null) {\r\n            c.weight = (c as any)._origWeightNoise;\r\n            delete (c as any)._origWeightNoise;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (training) this._trainingStep++;\r\n    if (stats.weightNoise.count > 0)\r\n      stats.weightNoise.meanAbs =\r\n        stats.weightNoise.sumAbs / stats.weightNoise.count;\r\n    this._lastStats = stats;\r\n    // Clone and release pooled array for backward compatibility\r\n    const result = Array.from(output as any) as number[];\r\n    activationArrayPool.release(output);\r\n    return result;\r\n  }\r\n\r\n  private static _gaussianRand(rng: () => number = Math.random): number {\r\n    let u = 0,\r\n      v = 0;\r\n    while (u === 0) u = rng();\r\n    while (v === 0) v = rng();\r\n    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\r\n  }\r\n\r\n  /**\r\n   * Activates the network without calculating eligibility traces.\r\n   * This is a performance optimization for scenarios where backpropagation is not needed,\r\n   * such as during testing, evaluation, or deployment (inference).\r\n   *\r\n   * @param {number[]} input - An array of numerical values corresponding to the network's input nodes.\r\n   *                           The length must match the network's `input` size.\r\n   * @returns {number[]} An array of numerical values representing the activations of the network's output nodes.\r\n   *\r\n   * @see {@link Node.noTraceActivate}\r\n   */\r\n  // Delegated activation helpers\r\n  noTraceActivate(input: number[]): number[] {\r\n    const { noTraceActivate } = require('./network/network.activate');\r\n    return noTraceActivate.call(this, input);\r\n  }\r\n\r\n  /**\r\n   * Raw activation that can return a typed array when pooling is enabled (zero-copy).\r\n   * If reuseActivationArrays=false falls back to standard activate().\r\n   */\r\n  activateRaw(\r\n    input: number[],\r\n    training = false,\r\n    maxActivationDepth = 1000\r\n  ): any {\r\n    const { activateRaw } = require('./network/network.activate');\r\n    return activateRaw.call(this, input, training, maxActivationDepth);\r\n  }\r\n\r\n  /**\r\n   * Activate the network over a batch of input vectors (micro-batching).\r\n   *\r\n   * Currently iterates sample-by-sample while reusing the network's internal\r\n   * fast-path allocations. Outputs are cloned number[] arrays for API\r\n   * compatibility. Future optimizations can vectorize this path.\r\n   *\r\n   * @param inputs Array of input vectors, each length must equal this.input\r\n   * @param training Whether to run with training-time stochastic features\r\n   * @returns Array of output vectors, each length equals this.output\r\n   */\r\n  activateBatch(inputs: number[][], training = false): number[][] {\r\n    const { activateBatch } = require('./network/network.activate');\r\n    return activateBatch.call(this, inputs, training);\r\n  }\r\n\r\n  /**\r\n   * Propagates the error backward through the network (backpropagation).\r\n   * Calculates the error gradient for each node and connection.\r\n   * If `update` is true, it adjusts the weights and biases based on the calculated gradients,\r\n   * learning rate, momentum, and optional L2 regularization.\r\n   *\r\n   * The process starts from the output nodes and moves backward layer by layer (or topologically for recurrent nets).\r\n   *\r\n   * @param {number} rate - The learning rate (controls the step size of weight adjustments).\r\n   * @param {number} momentum - The momentum factor (helps overcome local minima and speeds up convergence). Typically between 0 and 1.\r\n   * @param {boolean} update - If true, apply the calculated weight and bias updates. If false, only calculate gradients (e.g., for batch accumulation).\r\n   * @param {number[]} target - An array of target values corresponding to the network's output nodes.\r\n   *                            The length must match the network's `output` size.\r\n   * @param {number} [regularization=0] - The L2 regularization factor (lambda). Helps prevent overfitting by penalizing large weights.\r\n   * @param {(target: number, output: number) => number} [costDerivative] - Optional derivative of the cost function for output nodes.\r\n   * @throws {Error} If the `target` array length does not match the network's `output` size.\r\n   *\r\n   * @see {@link Node.propagate} for the node-level backpropagation logic.\r\n   */\r\n  propagate(\r\n    rate: number,\r\n    momentum: number,\r\n    update: boolean,\r\n    target: number[],\r\n    regularization: number = 0, // L2 regularization factor (lambda)\r\n    costDerivative?: (target: number, output: number) => number\r\n  ): void {\r\n    // Validate that the target array matches the network's output size.\r\n    if (!target || target.length !== this.output) {\r\n      throw new Error(\r\n        'Output target length should match network output length'\r\n      );\r\n    }\r\n\r\n    let targetIndex = target.length; // Initialize index for accessing target values in reverse order.\r\n\r\n    // Propagate error starting from the output nodes (last nodes in the `nodes` array).\r\n    // Iterate backward from the last node to the first output node.\r\n    for (\r\n      let i = this.nodes.length - 1;\r\n      i >= this.nodes.length - this.output;\r\n      i--\r\n    ) {\r\n      if (costDerivative) {\r\n        (this.nodes[i] as any).propagate(\r\n          rate,\r\n          momentum,\r\n          update,\r\n          regularization,\r\n          target[--targetIndex],\r\n          costDerivative\r\n        );\r\n      } else {\r\n        this.nodes[i].propagate(\r\n          rate,\r\n          momentum,\r\n          update,\r\n          regularization,\r\n          target[--targetIndex]\r\n        );\r\n      }\r\n    }\r\n\r\n    // Propagate error backward through the hidden nodes.\r\n    // Iterate backward from the last hidden node to the first hidden node.\r\n    for (let i = this.nodes.length - this.output - 1; i >= this.input; i--) {\r\n      this.nodes[i].propagate(rate, momentum, update, regularization); // Pass regularization factor\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears the internal state of all nodes in the network.\r\n   * Resets node activation, state, eligibility traces, and extended traces to their initial values (usually 0).\r\n   * This is typically done before processing a new input sequence in recurrent networks or between training epochs if desired.\r\n   *\r\n   * @see {@link Node.clear}\r\n   */\r\n  clear(): void {\r\n    // Iterate through all nodes and call their clear method.\r\n    this.nodes.forEach((node) => node.clear());\r\n  }\r\n\r\n  /**\r\n   * Mutates the network's structure or parameters according to the specified method.\r\n   * This is a core operation for neuro-evolutionary algorithms (like NEAT).\r\n   * The method argument should be one of the mutation types defined in `methods.mutation`.\r\n   *\r\n   * @param {any} method - The mutation method to apply (e.g., `mutation.ADD_NODE`, `mutation.MOD_WEIGHT`).\r\n   *                       Some methods might have associated parameters (e.g., `MOD_WEIGHT` uses `min`, `max`).\r\n   * @throws {Error} If no valid mutation `method` is provided.\r\n   *\r\n   * @see {@link methods.mutation} for available mutation types.\r\n   */\r\n  mutate(method: any): void {\r\n    const { mutateImpl } = require('./network/network.mutate');\r\n    return mutateImpl.call(this, method);\r\n  }\r\n\r\n  /**\r\n   * Creates a connection between two nodes in the network.\r\n   * Handles both regular connections and self-connections.\r\n   * Adds the new connection object(s) to the appropriate network list (`connections` or `selfconns`).\r\n   *\r\n   * @param {Node} from - The source node of the connection.\r\n   * @param {Node} to - The target node of the connection.\r\n   * @param {number} [weight] - Optional weight for the connection. If not provided, a random weight is usually assigned by the underlying `Node.connect` method.\r\n   * @returns {Connection[]} An array containing the newly created connection object(s). Typically contains one connection, but might be empty or contain more in specialized node types.\r\n   *\r\n   * @see {@link Node.connect}\r\n   */\r\n  connect(from: Node, to: Node, weight?: number): Connection[] {\r\n    return _connect.call(this, from, to, weight);\r\n  }\r\n\r\n  /**\r\n   * Gates a connection with a specified node.\r\n   * The activation of the `node` (gater) will modulate the weight of the `connection`.\r\n   * Adds the connection to the network's `gates` list.\r\n   *\r\n   * @param {Node} node - The node that will act as the gater. Must be part of this network.\r\n   * @param {Connection} connection - The connection to be gated.\r\n   * @throws {Error} If the provided `node` is not part of this network.\r\n   * @throws {Error} If the `connection` is already gated (though currently handled with a warning).\r\n   *\r\n   * @see {@link Node.gate}\r\n   */\r\n  gate(node: Node, connection: Connection) {\r\n    return _gate.call(this, node, connection);\r\n  }\r\n\r\n  /**\r\n   * Removes a node from the network.\r\n   * This involves:\r\n   * 1. Disconnecting all incoming and outgoing connections associated with the node.\r\n   * 2. Removing any self-connections.\r\n   * 3. Removing the node from the `nodes` array.\r\n   * 4. Attempting to reconnect the node's direct predecessors to its direct successors\r\n   *    to maintain network flow, if possible and configured.\r\n   * 5. Handling gates involving the removed node (ungating connections gated *by* this node,\r\n   *    and potentially re-gating connections that were gated *by other nodes* onto the removed node's connections).\r\n   *\r\n   * @param {Node} node - The node instance to remove. Must exist within the network's `nodes` list.\r\n   * @throws {Error} If the specified `node` is not found in the network's `nodes` list.\r\n   */\r\n  remove(node: Node) {\r\n    return _removeNodeStandalone.call(this, node);\r\n  }\r\n\r\n  /**\r\n   * Disconnects two nodes, removing the connection between them.\r\n   * Handles both regular connections and self-connections.\r\n   * If the connection being removed was gated, it is also ungated.\r\n   *\r\n   * @param {Node} from - The source node of the connection to remove.\r\n   * @param {Node} to - The target node of the connection to remove.\r\n   *\r\n   * @see {@link Node.disconnect}\r\n   */\r\n  disconnect(from: Node, to: Node): void {\r\n    return _disconnect.call(this, from, to);\r\n  }\r\n\r\n  // slab rebuild + accessor moved to network.slab.ts\r\n\r\n  /**\r\n   * Removes the gate from a specified connection.\r\n   * The connection will no longer be modulated by its gater node.\r\n   * Removes the connection from the network's `gates` list.\r\n   *\r\n   * @param {Connection} connection - The connection object to ungate.\r\n   * @throws {Error} If the provided `connection` is not found in the network's `gates` list (i.e., it wasn't gated).\r\n   *\r\n   * @see {@link Node.ungate}\r\n   */\r\n  ungate(connection: Connection) {\r\n    return _ungate.call(this, connection);\r\n  }\r\n\r\n  /**\r\n   * Trains the network on a given dataset subset for one pass (epoch or batch).\r\n   * Performs activation and backpropagation for each item in the set.\r\n   * Updates weights based on batch size configuration.\r\n   *\r\n   * @param {{ input: number[]; output: number[] }[]} set - The training dataset subset (e.g., a batch or the full set for one epoch).\r\n   * @param {number} batchSize - The number of samples to process before updating weights.\r\n   * @param {number} currentRate - The learning rate to use for this training pass.\r\n   * @param {number} momentum - The momentum factor to use.\r\n   * @param {any} regularization - The regularization configuration (L1, L2, or custom function).\r\n   * @param {(target: number[], output: number[]) => number} costFunction - The function used to calculate the error between target and output.\r\n   * @returns {number} The average error calculated over the provided dataset subset.\r\n   * @private Internal method used by `train`.\r\n   */\r\n  // Removed legacy _trainSet; delegated to network.training.ts\r\n\r\n  // Gradient clipping implemented in network.training.ts (applyGradientClippingImpl). Kept here only for backward compat if reflection used.\r\n  private _applyGradientClipping(cfg: {\r\n    mode: 'norm' | 'percentile' | 'layerwiseNorm' | 'layerwisePercentile';\r\n    maxNorm?: number;\r\n    percentile?: number;\r\n  }) {\r\n    const { applyGradientClippingImpl } = require('./network/network.training');\r\n    applyGradientClippingImpl(this as any, cfg);\r\n  }\r\n\r\n  // Training is implemented in network.training.ts; this wrapper keeps public API stable.\r\n  train(\r\n    set: { input: number[]; output: number[] }[],\r\n    options: any\r\n  ): { error: number; iterations: number; time: number } {\r\n    const { trainImpl } = require('./network/network.training');\r\n    return trainImpl(this as any, set, options);\r\n  }\r\n\r\n  /** Returns last recorded raw (pre-update) gradient L2 norm. */\r\n  getRawGradientNorm(): number {\r\n    return this._lastRawGradNorm;\r\n  }\r\n  /** Returns current mixed precision loss scale (1 if disabled). */\r\n  getLossScale(): number {\r\n    return this._mixedPrecision.lossScale;\r\n  }\r\n  /** Returns last gradient clipping group count (0 if no clipping yet). */\r\n  getLastGradClipGroupCount(): number {\r\n    return this._lastGradClipGroupCount;\r\n  }\r\n  /** Consolidated training stats snapshot. */\r\n  getTrainingStats() {\r\n    return {\r\n      gradNorm: this._lastGradNorm ?? 0,\r\n      gradNormRaw: this._lastRawGradNorm,\r\n      lossScale: this._mixedPrecision.lossScale,\r\n      optimizerStep: this._optimizerStep,\r\n      mp: {\r\n        good: this._mixedPrecisionState.goodSteps,\r\n        bad: this._mixedPrecisionState.badSteps,\r\n        overflowCount: this._mixedPrecisionState.overflowCount || 0,\r\n        scaleUps: this._mixedPrecisionState.scaleUpEvents || 0,\r\n        scaleDowns: this._mixedPrecisionState.scaleDownEvents || 0,\r\n        lastOverflowStep: this._lastOverflowStep,\r\n      },\r\n    };\r\n  }\r\n  /** Utility: adjust rate for accumulation mode (use result when switching to 'sum' to mimic 'average'). */\r\n  static adjustRateForAccumulation(\r\n    rate: number,\r\n    accumulationSteps: number,\r\n    reduction: 'average' | 'sum'\r\n  ) {\r\n    if (reduction === 'sum' && accumulationSteps > 1)\r\n      return rate / accumulationSteps;\r\n    return rate;\r\n  }\r\n\r\n  // Evolution wrapper delegates to network/network.evolve.ts implementation.\r\n  async evolve(\r\n    set: { input: number[]; output: number[] }[],\r\n    options: any\r\n  ): Promise<{ error: number; iterations: number; time: number }> {\r\n    const { evolveNetwork } = await import('./network/network.evolve');\r\n    return evolveNetwork.call(this, set, options);\r\n  }\r\n\r\n  /**\r\n   * Tests the network's performance on a given dataset.\r\n   * Calculates the average error over the dataset using a specified cost function.\r\n   * Uses `noTraceActivate` for efficiency as gradients are not needed.\r\n   * Handles dropout scaling if dropout was used during training.\r\n   *\r\n   * @param {{ input: number[]; output: number[] }[]} set - The test dataset, an array of objects with `input` and `output` arrays.\r\n   * @param {function} [cost=methods.Cost.MSE] - The cost function to evaluate the error. Defaults to Mean Squared Error.\r\n   * @returns {{ error: number; time: number }} An object containing the calculated average error over the dataset and the time taken for the test in milliseconds.\r\n   */\r\n  test(\r\n    set: { input: number[]; output: number[] }[],\r\n    cost?: any\r\n  ): { error: number; time: number } {\r\n    // Dataset dimension validation\r\n    if (!Array.isArray(set) || set.length === 0) {\r\n      throw new Error('Test set is empty or not an array.');\r\n    }\r\n    for (const sample of set) {\r\n      if (!Array.isArray(sample.input) || sample.input.length !== this.input) {\r\n        throw new Error(\r\n          `Test sample input size mismatch: expected ${this.input}, got ${\r\n            sample.input ? sample.input.length : 'undefined'\r\n          }`\r\n        );\r\n      }\r\n      if (\r\n        !Array.isArray(sample.output) ||\r\n        sample.output.length !== this.output\r\n      ) {\r\n        throw new Error(\r\n          `Test sample output size mismatch: expected ${this.output}, got ${\r\n            sample.output ? sample.output.length : 'undefined'\r\n          }`\r\n        );\r\n      }\r\n    }\r\n\r\n    let error = 0; // Accumulator for the total error.\r\n    const costFn = cost || methods.Cost.mse; // Use provided cost function or default to MSE.\r\n    const start = Date.now(); // Start time measurement.\r\n\r\n    // --- Dropout/inference transition: Explicitly reset all hidden node masks to 1 for robust inference ---\r\n    this.nodes.forEach((node) => {\r\n      if (node.type === 'hidden') node.mask = 1;\r\n    });\r\n\r\n    const previousDropout = this.dropout; // Store current dropout rate\r\n    if (this.dropout > 0) {\r\n      // Temporarily disable dropout effect for testing.\r\n      this.dropout = 0;\r\n    }\r\n\r\n    // Iterate through each sample in the test set.\r\n    set.forEach((data) => {\r\n      // Activate the network without calculating traces.\r\n      const output = this.noTraceActivate(data.input);\r\n      // Calculate the error for this sample and add it to the sum.\r\n      error += costFn(data.output, output);\r\n    });\r\n\r\n    // Restore the previous dropout rate if it was changed.\r\n    this.dropout = previousDropout;\r\n\r\n    // Return the average error and the time taken.\r\n    return { error: error / set.length, time: Date.now() - start };\r\n  }\r\n\r\n  /** Lightweight tuple serializer delegating to network.serialize.ts */\r\n  serialize(): any[] {\r\n    return _serialize.call(this);\r\n  }\r\n\r\n  /**\r\n   * Creates a Network instance from serialized data produced by `serialize()`.\r\n   * Reconstructs the network structure and state based on the provided arrays.\r\n   *\r\n   * @param {any[]} data - The serialized network data array, typically obtained from `network.serialize()`.\r\n   *                       Expected format: `[activations, states, squashNames, connectionData, inputSize, outputSize]`.\r\n   * @param {number} [inputSize] - Optional input size override.\r\n   * @param {number} [outputSize] - Optional output size override.\r\n   * @returns {Network} A new Network instance reconstructed from the serialized data.\r\n   * @static\r\n   */\r\n  /** Static lightweight tuple deserializer delegate */\r\n  static deserialize(\r\n    data: any[],\r\n    inputSize?: number,\r\n    outputSize?: number\r\n  ): Network {\r\n    return _deserialize(data, inputSize, outputSize);\r\n  }\r\n\r\n  /**\r\n   * Converts the network into a JSON object representation (latest standard).\r\n   * Includes formatVersion, and only serializes properties needed for full reconstruction.\r\n   * All references are by index. Excludes runtime-only properties (activation, state, traces).\r\n   *\r\n   * @returns {object} A JSON-compatible object representing the network.\r\n   */\r\n  /** Verbose JSON serializer delegate */\r\n  toJSON(): object {\r\n    return _toJSONImpl.call(this);\r\n  }\r\n\r\n  /**\r\n   * Reconstructs a network from a JSON object (latest standard).\r\n   * Handles formatVersion, robust error handling, and index-based references.\r\n   * @param {object} json - The JSON object representing the network.\r\n   * @returns {Network} The reconstructed network.\r\n   */\r\n  /** Verbose JSON static deserializer */\r\n  static fromJSON(json: any): Network {\r\n    return _fromJSONImpl(json);\r\n  }\r\n\r\n  /**\r\n   * Creates a new offspring network by performing crossover between two parent networks.\r\n   * This method implements the crossover mechanism inspired by the NEAT algorithm and described\r\n   * in the Instinct paper, combining genes (nodes and connections) from both parents.\r\n   * Fitness scores can influence the inheritance process. Matching genes are inherited randomly,\r\n   * while disjoint/excess genes are typically inherited from the fitter parent (or randomly if fitness is equal or `equal` flag is set).\r\n   *\r\n   * @param {Network} network1 - The first parent network.\r\n   * @param {Network} network2 - The second parent network.\r\n   * @param {boolean} [equal=false] - If true, disjoint and excess genes are inherited randomly regardless of fitness.\r\n   *                                  If false (default), they are inherited from the fitter parent.\r\n   * @returns {Network} A new Network instance representing the offspring.\r\n   * @throws {Error} If the input or output sizes of the parent networks do not match.\r\n   *\r\n   * @see Instinct Algorithm - Section 2 Crossover\r\n   * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6}\r\n   * @static\r\n   */\r\n  /** NEAT-style crossover delegate. */\r\n  static crossOver(\r\n    network1: Network,\r\n    network2: Network,\r\n    equal: boolean = false\r\n  ): Network {\r\n    return _crossOver(network1, network2, equal);\r\n  }\r\n\r\n  /**\r\n   * Sets specified properties (e.g., bias, squash function) for all nodes in the network.\r\n   * Useful for initializing or resetting node properties uniformly.\r\n   *\r\n   * @param {object} values - An object containing the properties and values to set.\r\n   * @param {number} [values.bias] - If provided, sets the bias for all nodes.\r\n   * @param {function} [values.squash] - If provided, sets the squash (activation) function for all nodes.\r\n   *                                     Should be a valid activation function (e.g., from `methods.Activation`).\r\n   */\r\n  set(values: { bias?: number; squash?: any }): void {\r\n    // Iterate through all nodes in the network.\r\n    this.nodes.forEach((node) => {\r\n      // Update bias if provided in the values object.\r\n      if (typeof values.bias !== 'undefined') {\r\n        node.bias = values.bias;\r\n      }\r\n      // Update squash function if provided.\r\n      if (typeof values.squash !== 'undefined') {\r\n        node.squash = values.squash;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Exports the network to ONNX format (JSON object, minimal MLP support).\r\n   * Only standard feedforward architectures and standard activations are supported.\r\n   * Gating, custom activations, and evolutionary features are ignored or replaced with Identity.\r\n   *\r\n   * @returns {import('./onnx').OnnxModel} ONNX model as a JSON object.\r\n   */\r\n  toONNX() {\r\n    return exportToONNX(this);\r\n  }\r\n\r\n  /**\r\n   * Creates a fully connected, strictly layered MLP network.\r\n   * @param {number} inputCount - Number of input nodes\r\n   * @param {number[]} hiddenCounts - Array of hidden layer sizes (e.g. [2,3] for two hidden layers)\r\n   * @param {number} outputCount - Number of output nodes\r\n   * @returns {Network} A new, fully connected, layered MLP\r\n   */\r\n  static createMLP(\r\n    inputCount: number,\r\n    hiddenCounts: number[],\r\n    outputCount: number\r\n  ): Network {\r\n    // Create all nodes\r\n    const inputNodes = Array.from(\r\n      { length: inputCount },\r\n      () => new Node('input')\r\n    );\r\n    const hiddenLayers: Node[][] = hiddenCounts.map((count) =>\r\n      Array.from({ length: count }, () => new Node('hidden'))\r\n    );\r\n    const outputNodes = Array.from(\r\n      { length: outputCount },\r\n      () => new Node('output')\r\n    );\r\n    // Flatten all nodes in topological order\r\n    const allNodes = [...inputNodes, ...hiddenLayers.flat(), ...outputNodes];\r\n    // Create network instance\r\n    const net = new Network(inputCount, outputCount);\r\n    net.nodes = allNodes;\r\n    // Connect layers\r\n    let prevLayer = inputNodes;\r\n    for (const layer of hiddenLayers) {\r\n      for (const to of layer) {\r\n        for (const from of prevLayer) {\r\n          from.connect(to);\r\n        }\r\n      }\r\n      prevLayer = layer;\r\n    }\r\n    // Connect last hidden (or input if no hidden) to output\r\n    for (const to of outputNodes) {\r\n      for (const from of prevLayer) {\r\n        from.connect(to);\r\n      }\r\n    }\r\n    // Rebuild net.connections from all per-node connections\r\n    net.connections = net.nodes.flatMap((n) => n.connections.out);\r\n    net._topoDirty = true;\r\n    return net;\r\n  }\r\n\r\n  /**\r\n   * Rebuilds the network's connections array from all per-node connections.\r\n   * This ensures that the network.connections array is consistent with the actual\r\n   * outgoing connections of all nodes. Useful after manual wiring or node manipulation.\r\n   *\r\n   * @param {Network} net - The network instance to rebuild connections for.\r\n   * @returns {void}\r\n   *\r\n   * Example usage:\r\n   *   Network.rebuildConnections(net);\r\n   */\r\n  static rebuildConnections(net: Network): void {\r\n    const allConnections = new Set<Connection>();\r\n    net.nodes.forEach((node) => {\r\n      node.connections.out.forEach((conn) => {\r\n        allConnections.add(conn);\r\n      });\r\n    });\r\n    net.connections = Array.from(allConnections) as Connection[];\r\n  }\r\n}\r\n", "import Network from './architecture/network';\r\nimport * as methods from './methods/methods';\r\nimport NodeType from './architecture/node'; // Import the Node type with a different name to avoid conflicts\r\n\r\n/**\r\n * Comprehensive configuration surface for Neat evolutionary runs.\r\n * Options are grouped conceptually; all fields are optional unless noted.\r\n * See docs/API.md for structured tables. New adaptive / telemetry features carry a trailing comment with @since marker.\r\n */\r\ntype Options = {\r\n  equal?: boolean;\r\n  clear?: boolean;\r\n  popsize?: number;\r\n  elitism?: number;\r\n  provenance?: number;\r\n  mutationRate?: number;\r\n  mutationAmount?: number;\r\n  fitnessPopulation?: boolean;\r\n  selection?: any;\r\n  crossover?: any[];\r\n  mutation?: any;\r\n  network?: Network;\r\n  maxNodes?: number;\r\n  maxConns?: number;\r\n  maxGates?: number;\r\n  mutationSelection?: (genome: any) => any;\r\n  allowRecurrent?: boolean; // Add allowRecurrent option\r\n  hiddenLayerMultiplier?: number; // Add hiddenLayerMultiplier option\r\n  minHidden?: number; // Add minHidden option for minimum hidden nodes in evolved networks\r\n  seed?: number; // Optional seed for deterministic evolution\r\n  // --- Speciation settings ---\r\n  speciation?: boolean;\r\n  compatibilityThreshold?: number;\r\n  excessCoeff?: number;\r\n  disjointCoeff?: number;\r\n  weightDiffCoeff?: number;\r\n  minSpeciesSize?: number;\r\n  stagnationGenerations?: number;\r\n  survivalThreshold?: number; // fraction of each species allowed to reproduce\r\n  reenableProb?: number; // probability a disabled connection gene is re-enabled during crossover\r\n  sharingSigma?: number; // radius for kernel fitness sharing (if provided >0 uses kernel, else simple species averaging)\r\n  globalStagnationGenerations?: number; // generations without global improvement before injecting fresh genomes\r\n  crossSpeciesMatingProb?: number; // probability a mating selects second parent from another species\r\n  speciesAgeProtection?: { grace?: number; oldPenalty?: number }; // grace prevents early cull; penalty scales fitness for very old species\r\n  adaptiveSharing?: {\r\n    enabled?: boolean;\r\n    targetFragmentation?: number;\r\n    adjustStep?: number;\r\n    minSigma?: number;\r\n    maxSigma?: number;\r\n  };\r\n  minimalCriterion?: (net: Network) => boolean; // if provided, genomes failing it get score=0 before speciation/sharing\r\n  operatorAdaptation?: {\r\n    enabled?: boolean;\r\n    window?: number;\r\n    boost?: number;\r\n    decay?: number;\r\n  };\r\n  phasedComplexity?: {\r\n    enabled?: boolean;\r\n    phaseLength?: number;\r\n    simplifyFraction?: number;\r\n  }; // alternate phases\r\n  complexityBudget?: {\r\n    enabled?: boolean;\r\n    maxNodesStart?: number;\r\n    maxNodesEnd?: number;\r\n    horizon?: number;\r\n    mode?: 'linear' | 'adaptive';\r\n    improvementWindow?: number;\r\n    increaseFactor?: number;\r\n    stagnationFactor?: number;\r\n    minNodes?: number;\r\n    maxConnsStart?: number;\r\n    maxConnsEnd?: number;\r\n  }; // adaptive schedule\r\n  minimalCriterionThreshold?: number; // simple numeric threshold on raw fitness\r\n  minimalCriterionAdaptive?: {\r\n    enabled?: boolean;\r\n    initialThreshold?: number;\r\n    targetAcceptance?: number;\r\n    adjustRate?: number;\r\n    metric?: 'score' | 'novelty';\r\n  };\r\n  multiObjective?: {\r\n    enabled?: boolean;\r\n    complexityMetric?: 'connections' | 'nodes'; // metric minimized\r\n    dominanceEpsilon?: number; // treat fitness difference below epsilon as equal for dominance\r\n    autoEntropy?: boolean; // if true, adds a structural entropy maximization objective automatically\r\n    // Dynamic scheduling: optionally delay adding complexity / entropy objectives and temporarily drop entropy on stagnation\r\n    dynamic?: {\r\n      enabled?: boolean;\r\n      addComplexityAt?: number;\r\n      addEntropyAt?: number;\r\n      dropEntropyOnStagnation?: number;\r\n      readdEntropyAfter?: number;\r\n    };\r\n    adaptiveEpsilon?: {\r\n      enabled?: boolean;\r\n      targetFront?: number;\r\n      adjust?: number;\r\n      min?: number;\r\n      max?: number;\r\n      cooldown?: number;\r\n    }; // adapt epsilon to maintain front size\r\n    refPoint?: number[] | 'auto'; // reference point for hypervolume (auto => dynamic)\r\n    objectives?: {\r\n      key: string;\r\n      direction: 'min' | 'max';\r\n      accessor: (g: Network) => number;\r\n    }[]; // extensible objective list\r\n    pruneInactive?: {\r\n      enabled?: boolean;\r\n      window?: number;\r\n      rangeEps?: number;\r\n      protect?: string[];\r\n    }; // auto-remove stagnant objectives\r\n  };\r\n  lineageTracking?: boolean; // track parent genome ids for each offspring (default true)\r\n  speciesAllocation?: { minOffspring?: number; extendedHistory?: boolean };\r\n  diversityPressure?: {\r\n    enabled?: boolean;\r\n    motifSample?: number;\r\n    penaltyStrength?: number;\r\n    window?: number;\r\n  };\r\n  diversityMetrics?: {\r\n    enabled?: boolean;\r\n    pairSample?: number;\r\n    graphletSample?: number;\r\n  };\r\n  fastMode?: boolean; // if true, auto-tunes sampling down for speed unless explicitly set\r\n  autoCompatTuning?: {\r\n    enabled?: boolean;\r\n    target?: number;\r\n    adjustRate?: number;\r\n    minCoeff?: number;\r\n    maxCoeff?: number;\r\n  };\r\n  operatorBandit?: { enabled?: boolean; c?: number; minAttempts?: number };\r\n  telemetry?: {\r\n    enabled?: boolean;\r\n    logEvery?: number;\r\n    performance?: boolean;\r\n    complexity?: boolean;\r\n    hypervolume?: boolean;\r\n  };\r\n  // Optional whitelist of telemetry blocks to retain (besides core gen/best/species). Example: telemetrySelect:['complexity','lineage']\r\n  telemetrySelect?: string[];\r\n  // When true and seed provided, embed current 32-bit RNG state into each telemetry entry for reproducibility checkpoints\r\n  // (appears as entry.rng). Only included if using internal deterministic PRNG (seed set)\r\n  // Example: telemetry: { enabled:true, rngState:true }\r\n  // NOTE: Restoring via neat.restoreRNGState({ state: entry.rng }) before reproducing evolution path enables audit.\r\n  // This does not capture network structures; combine with exportTelemetryCSV for full trace context.\r\n  // Add field here to maintain backward compatibility (optional usage).\r\n  // (Placed adjacent to telemetry config for cohesion.)\r\n  // @since dynamic scheduling + RNG telemetry enhancement\r\n  // Added via feature request: embed RNG snapshot in telemetry.\r\n  // The boolean lives alongside existing telemetry flags to avoid another top-level option cluster.\r\n  // If not provided or false, no rng field emitted.\r\n  rngState?: boolean;\r\n  telemetryStream?: {\r\n    enabled?: boolean;\r\n    onEntry?: (entry: any) => void;\r\n    bufferSize?: number;\r\n  };\r\n  // Self-adaptive per-genome mutation parameters\r\n  adaptiveMutation?: {\r\n    enabled?: boolean;\r\n    initialRate?: number;\r\n    sigma?: number;\r\n    minRate?: number;\r\n    maxRate?: number;\r\n    adaptAmount?: boolean;\r\n    amountSigma?: number;\r\n    minAmount?: number;\r\n    maxAmount?: number;\r\n    adaptEvery?: number; // generations between global adaptation passes (default 1)\r\n    strategy?: 'exploreLow' | 'twoTier' | 'anneal'; // exploreLow: boost low performers, damp high; twoTier: top decrease, bottom increase; anneal: global decay\r\n  };\r\n  // Novelty search scaffold\r\n  novelty?: {\r\n    enabled?: boolean;\r\n    descriptor?: (net: Network) => number[];\r\n    archiveAddThreshold?: number; // threshold for inserting into archive\r\n    k?: number; // number of neighbors\r\n    blendFactor?: number; // 0..1 weight on novelty\r\n    maxArchive?: number;\r\n    pruneStrategy?: 'fifo' | 'sparse';\r\n    dynamicThreshold?: {\r\n      enabled?: boolean;\r\n      targetRate?: number;\r\n      adjust?: number;\r\n      min?: number;\r\n      max?: number;\r\n    };\r\n    clustering?: { enabled?: boolean; kMeansIters?: number };\r\n  };\r\n  // Species age allocation bonus/penalty\r\n  speciesAgeBonus?: {\r\n    youngThreshold?: number;\r\n    youngMultiplier?: number;\r\n    oldThreshold?: number;\r\n    oldMultiplier?: number;\r\n  };\r\n  evolutionPruning?: {\r\n    startGeneration: number; // first generation to start pruning\r\n    interval?: number; // apply every N generations (default 1 once started)\r\n    targetSparsity: number; // final sparsity to reach\r\n    rampGenerations?: number; // number of generations over which to ramp from 0 -> targetSparsity\r\n    method?: 'magnitude' | 'snip';\r\n  };\r\n  // Dynamic compatibility threshold steering\r\n  targetSpecies?: number; // desired species count (if set enables controller)\r\n  compatAdjust?: {\r\n    kp?: number; // proportional gain (default 0.3)\r\n    ki?: number; // integral gain (default 0.02)\r\n    smoothingWindow?: number; // EMA window for observed species count (default 5)\r\n    minThreshold?: number; // clamp lower bound (default 0.5)\r\n    maxThreshold?: number; // clamp upper bound (default 10)\r\n    decay?: number; // integral decay (default 0.95)\r\n  };\r\n  // Lineage-based selection pressure (optional)\r\n  lineagePressure?: {\r\n    enabled?: boolean;\r\n    mode?: 'penalizeDeep' | 'rewardShallow' | 'spread' | 'antiInbreeding';\r\n    targetMeanDepth?: number;\r\n    strength?: number;\r\n    ancestorWindow?: number;\r\n    inbreedingPenalty?: number;\r\n    diversityBonus?: number;\r\n  };\r\n  // Entropy-guided automatic sharingSigma tuning (works with kernel sharing) adjusts sigma based on entropy variance\r\n  entropySharingTuning?: {\r\n    enabled?: boolean;\r\n    targetEntropyVar?: number;\r\n    adjustRate?: number;\r\n    minSigma?: number;\r\n    maxSigma?: number;\r\n  };\r\n  // Ancestor uniqueness based objective re-weighting (adjust dominance epsilon or inject temporary depth pressure)\r\n  ancestorUniqAdaptive?: {\r\n    enabled?: boolean;\r\n    lowThreshold?: number;\r\n    highThreshold?: number;\r\n    adjust?: number;\r\n    mode?: 'epsilon' | 'lineagePressure';\r\n    cooldown?: number;\r\n  };\r\n  // Entropy-guided compatibility threshold tuning (species count via structural diversity)\r\n  entropyCompatTuning?: {\r\n    enabled?: boolean;\r\n    targetEntropy?: number;\r\n    adjustRate?: number;\r\n    minThreshold?: number;\r\n    maxThreshold?: number;\r\n    deadband?: number;\r\n  };\r\n  // Adaptive target species count mapping structural entropy to a species target\r\n  adaptiveTargetSpecies?: {\r\n    enabled?: boolean;\r\n    entropyRange?: [number, number];\r\n    speciesRange?: [number, number];\r\n    smooth?: number;\r\n  };\r\n  // Dynamic distance coefficient tuning using entropy & stagnation (refines excess/disjoint weights)\r\n  autoDistanceCoeffTuning?: {\r\n    enabled?: boolean;\r\n    targetEntropy?: number;\r\n    adjustRate?: number;\r\n    minCoeff?: number;\r\n    maxCoeff?: number;\r\n  };\r\n  // Adaptive pruning schedule separate from evolutionPruning absolute ramp\r\n  adaptivePruning?: {\r\n    enabled?: boolean;\r\n    targetSparsity?: number;\r\n    adjustRate?: number;\r\n    metric?: 'nodes' | 'connections';\r\n    tolerance?: number;\r\n  };\r\n};\r\n// Public re-export for library consumers\r\nexport type NeatOptions = Options;\r\n\r\nexport default class Neat {\r\n  input: number;\r\n  output: number;\r\n  fitness: (network: Network) => number;\r\n  options: Options;\r\n  population: Network[] = [];\r\n  generation: number = 0;\r\n  // Deterministic RNG state (lazy init)\r\n  private _rngState?: number;\r\n  private _rng?: () => number;\r\n  // --- Speciation state ---\r\n  private _species: {\r\n    id: number;\r\n    members: Network[];\r\n    representative: Network;\r\n    lastImproved: number;\r\n    bestScore: number;\r\n  }[] = [];\r\n  private _speciesCreated: Map<number, number> = new Map();\r\n  private _speciesHistory: {\r\n    generation: number;\r\n    stats: { id: number; size: number; best: number; lastImproved: number }[];\r\n  }[] = [];\r\n  private _nextSpeciesId: number = 1;\r\n  private _compatIntegral: number = 0;\r\n  private _compatSpeciesEMA?: number;\r\n  // Innovation reuse registries\r\n  private _nodeSplitInnovations: Map<\r\n    string,\r\n    { newNodeGeneId: number; inInnov: number; outInnov: number }\r\n  > = new Map();\r\n  private _connInnovations: Map<string, number> = new Map(); // fromGene->toGene stable innovation ids for added connections\r\n  private _nextGlobalInnovation: number = 1;\r\n  // Global stagnation tracking\r\n  private _bestGlobalScore: number = -Infinity;\r\n  private _lastGlobalImproveGeneration: number = 0;\r\n  // Novelty archive (descriptor vectors only)\r\n  private _noveltyArchive: { d: number[] }[] = [];\r\n  private _operatorStats: Map<\r\n    string,\r\n    { success: number; attempts: number }\r\n  > = new Map();\r\n  private _phase?: 'complexify' | 'simplify';\r\n  private _diversityStats: any = null;\r\n  private _phaseStartGeneration: number = 0;\r\n  private _telemetry: any[] = [];\r\n  private _objectivesList?: {\r\n    key: string;\r\n    direction: 'min' | 'max';\r\n    accessor: (g: Network) => number;\r\n  }[];\r\n  private _entropyTempDropped?: boolean; // dynamic scheduling: entropy temporarily disabled\r\n  private _entropyDropGen?: number; // generation when entropy objective was dropped\r\n  // Genome identity & lineage tracking\r\n  private _nextGenomeId: number = 1;\r\n  private _prevSpeciesMembers: Map<number, Set<number>> = new Map();\r\n  private _speciesLastStats: Map<\r\n    number,\r\n    { meanNodes: number; meanConns: number; best: number }\r\n  > = new Map();\r\n  private _paretoArchive: {\r\n    gen: number;\r\n    size: number;\r\n    genomes: {\r\n      id: number;\r\n      score: number;\r\n      nodes: number;\r\n      connections: number;\r\n    }[];\r\n  }[] = [];\r\n  private _paretoObjectivesArchive: {\r\n    gen: number;\r\n    vectors: { id: number; values: number[] }[];\r\n  }[] = []; // objective vectors snapshot\r\n  private _lastEpsilonAdjustGen: number = -1;\r\n  private _lastEvalDuration?: number;\r\n  private _lastEvolveDuration?: number;\r\n  private _lastMeanNodes?: number;\r\n  private _lastMeanConns?: number; // for complexity growth telemetry\r\n  private _lineageEnabled: boolean = true; // runtime flag for lineage tracking\r\n  private _lastInbreedingCount: number = 0; // count of identical-parent matings in last reproduction phase\r\n  private _prevInbreedingCount: number = 0; // snapshot used for telemetry (previous generation's reproduction)\r\n  private _lastMeanDepth: number = 0; // mean lineage depth of current population\r\n  private _objectiveStale: Map<string, number> = new Map(); // counts consecutive gens with near-zero range\r\n  private _fastModeTuned?: boolean;\r\n  private _lastAncestorUniqAdjustGen: number = -1; // cooldown tracker\r\n  // Objective lifetime tracking (consecutive generations active)\r\n  private _objectiveAges: Map<string, number> = new Map();\r\n  // Last offspring allocation per species (captured during reproduction)\r\n  private _lastOffspringAlloc: { id: number; alloc: number }[] | null = null;\r\n  // Objective add/remove event log\r\n  private _objectiveEvents: {\r\n    gen: number;\r\n    type: 'add' | 'remove';\r\n    key: string;\r\n  }[] = [];\r\n  private _pendingObjectiveAdds: string[] = [];\r\n  private _pendingObjectiveRemoves: string[] = [];\r\n  private _adaptivePruneLevel?: number;\r\n  private _warnings: string[] = [];\r\n  private _telemetrySelect?: Set<string>;\r\n\r\n  /**\r\n   * Initializes a new instance of the Neat class.\r\n   * @param input - Number of input nodes in the network.\r\n   * @param output - Number of output nodes in the network.\r\n   * @param fitness - Fitness function to evaluate the performance of networks.\r\n   * @param options - Configuration options for the evolutionary process.\r\n   * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6 Instinct: neuro-evolution on steroids by Thomas Wagenaar}\r\n   */\r\n  constructor(\r\n    input: number,\r\n    output: number,\r\n    fitness: (network: Network) => number,\r\n    options: Options = {}\r\n  ) {\r\n    this.input = input;\r\n    this.output = output;\r\n    this.fitness = fitness;\r\n    this.options = options;\r\n    if (Array.isArray(this.options.telemetrySelect))\r\n      this._telemetrySelect = new Set(this.options.telemetrySelect);\r\n\r\n    this.options.equal = this.options.equal || false;\r\n    this.options.clear = this.options.clear || false;\r\n    this.options.popsize = this.options.popsize || 50;\r\n    this.options.elitism = this.options.elitism || 0;\r\n    this.options.provenance = this.options.provenance || 0;\r\n    this.options.mutationRate = this.options.mutationRate || 0.7;\r\n    this.options.mutationAmount = this.options.mutationAmount || 1;\r\n    this.options.fitnessPopulation = this.options.fitnessPopulation || false;\r\n    this.options.selection = this.options.selection || methods.selection.POWER;\r\n    this.options.crossover = this.options.crossover || [\r\n      methods.crossover.SINGLE_POINT,\r\n      methods.crossover.TWO_POINT,\r\n      methods.crossover.UNIFORM,\r\n    ];\r\n    this.options.mutation = this.options.mutation || methods.mutation.ALL;\r\n    // Sanitize user-provided mutation pool (remove falsy / duplicates) for robustness\r\n    try {\r\n      if (Array.isArray(this.options.mutation)) {\r\n        // Preserve canonical references for tests expecting identity: [methods.mutation.FFW] or methods.mutation.FFW\r\n        const isCanonicalFFWWrapper =\r\n          this.options.mutation.length === 1 &&\r\n          this.options.mutation[0] === methods.mutation.FFW;\r\n        const isCanonicalFFW =\r\n          this.options.mutation === (methods.mutation.FFW as any);\r\n        if (!isCanonicalFFWWrapper && !isCanonicalFFW) {\r\n          const original = this.options.mutation.slice();\r\n          const filtered = original.filter(\r\n            (m) => !!m && typeof m.name === 'string'\r\n          );\r\n          const dedup: any[] = [];\r\n          const seen = new Set<string>();\r\n          for (const m of filtered) {\r\n            if (!seen.has(m.name)) {\r\n              seen.add(m.name);\r\n              dedup.push(m);\r\n            }\r\n          }\r\n          const removed = original.length - dedup.length;\r\n          if (removed > 0)\r\n            this._warnings.push(\r\n              `[options.mutation] sanitized ${removed} invalid/duplicate entries (kept ${dedup.length}).`\r\n            );\r\n          this.options.mutation = dedup;\r\n        }\r\n      }\r\n    } catch (e) {\r\n      this._warnings.push(\r\n        `[options.mutation] sanitation error: ${(e as Error).message}`\r\n      );\r\n    }\r\n    // --- Advanced intelligent defaults (favor adaptive behavior when user has not overridden) ---\r\n    this.options.speciation = this.options.speciation ?? true;\r\n    this.options.compatibilityThreshold =\r\n      this.options.compatibilityThreshold ?? 3.0;\r\n    this.options.excessCoeff = this.options.excessCoeff ?? 1.0;\r\n    this.options.disjointCoeff = this.options.disjointCoeff ?? 1.0;\r\n    this.options.weightDiffCoeff = this.options.weightDiffCoeff ?? 0.4;\r\n    this.options.minSpeciesSize = this.options.minSpeciesSize ?? 2;\r\n    this.options.stagnationGenerations =\r\n      this.options.stagnationGenerations ?? 15;\r\n    this.options.survivalThreshold = this.options.survivalThreshold ?? 0.5;\r\n    this.options.reenableProb = this.options.reenableProb ?? 0.25;\r\n    // Enable kernel sharing by default for better niche pressure\r\n    this.options.sharingSigma = this.options.sharingSigma ?? 3.0;\r\n    this.options.globalStagnationGenerations =\r\n      this.options.globalStagnationGenerations ?? 40;\r\n    this.options.crossSpeciesMatingProb =\r\n      this.options.crossSpeciesMatingProb ?? 0.1;\r\n    // Set mutation methods based on allowRecurrent, if not explicitly provided in options\r\n    if (this.options.mutation === undefined) {\r\n      if (this.options.allowRecurrent) {\r\n        this.options.mutation = methods.mutation.ALL; // Use all mutations if recurrent is allowed\r\n      } else {\r\n        this.options.mutation = methods.mutation.FFW; // Default to FFW for non-recurrent\r\n      }\r\n    }\r\n\r\n    this.options.maxNodes = this.options.maxNodes || Infinity;\r\n    this.options.maxConns = this.options.maxConns || Infinity;\r\n    this.options.maxGates = this.options.maxGates || Infinity;\r\n    // Advanced defaults for remaining adaptive systems (do not override if user provided)\r\n    if (!this.options.telemetry)\r\n      this.options.telemetry = { enabled: true, logEvery: 1 };\r\n    if (!this.options.adaptiveMutation)\r\n      this.options.adaptiveMutation = {\r\n        enabled: true,\r\n        initialRate: 0.6,\r\n        sigma: 0.08,\r\n        minRate: 0.05,\r\n        maxRate: 0.95,\r\n        adaptAmount: true,\r\n        amountSigma: 0.6,\r\n        minAmount: 1,\r\n        maxAmount: 6,\r\n        strategy: 'twoTier',\r\n        adaptEvery: 1,\r\n      };\r\n    if (!this.options.novelty) this.options.novelty = { enabled: false }; // keep domain opt-in\r\n    if (!this.options.speciesAgeBonus)\r\n      this.options.speciesAgeBonus = {\r\n        youngThreshold: 5,\r\n        youngMultiplier: 1.25,\r\n        oldThreshold: 35,\r\n        oldMultiplier: 0.75,\r\n      } as any;\r\n    if (!this.options.operatorAdaptation)\r\n      this.options.operatorAdaptation = {\r\n        enabled: true,\r\n        window: 50,\r\n        boost: 2,\r\n        decay: 0.9,\r\n      };\r\n    if (!this.options.operatorBandit)\r\n      this.options.operatorBandit = { enabled: true, c: 1.2, minAttempts: 5 };\r\n    if (!this.options.telemetry)\r\n      this.options.telemetry = { enabled: true, logEvery: 1 };\r\n    if (!this.options.telemetryStream)\r\n      this.options.telemetryStream = { enabled: false } as any;\r\n    if (!this.options.phasedComplexity)\r\n      this.options.phasedComplexity = {\r\n        enabled: true,\r\n        phaseLength: 8,\r\n        simplifyFraction: 0.15,\r\n      };\r\n    if (!this.options.complexityBudget)\r\n      this.options.complexityBudget = {\r\n        enabled: true,\r\n        mode: 'adaptive',\r\n        maxNodesStart: this.input + this.output + 2,\r\n        maxNodesEnd: (this.input + this.output + 2) * 6,\r\n        improvementWindow: 8,\r\n        increaseFactor: 1.15,\r\n        stagnationFactor: 0.93,\r\n        minNodes: this.input + this.output + 2,\r\n      };\r\n    if (!this.options.multiObjective)\r\n      this.options.multiObjective = {\r\n        enabled: true,\r\n        complexityMetric: 'nodes',\r\n      };\r\n    // lineage tracking default ON unless explicitly disabled\r\n    this._lineageEnabled = this.options.lineageTracking !== false;\r\n    // Users can supply options.multiObjective.objectives = [{ key:'fitness', direction:'max', accessor:(g)=>g.score||0 }, ...]\r\n    // If provided, that list replaces the default (fitness + complexity). Each accessor should be fast & side-effect free.\r\n    if (!this.options.speciesAllocation)\r\n      this.options.speciesAllocation = {\r\n        minOffspring: 1,\r\n        extendedHistory: true,\r\n      };\r\n    if (!this.options.diversityPressure)\r\n      this.options.diversityPressure = {\r\n        enabled: true,\r\n        motifSample: 25,\r\n        penaltyStrength: 0.05,\r\n      };\r\n    if (!this.options.diversityMetrics)\r\n      this.options.diversityMetrics = {\r\n        enabled: true,\r\n        pairSample: 40,\r\n        graphletSample: 60,\r\n      };\r\n    if (!this.options.autoCompatTuning)\r\n      this.options.autoCompatTuning = {\r\n        enabled: true,\r\n        target: this.options.targetSpecies ?? 8,\r\n        adjustRate: 0.02,\r\n        minCoeff: 0.2,\r\n        maxCoeff: 3,\r\n      };\r\n    // Dynamic threshold controller on by default aiming for moderate species count\r\n    this.options.targetSpecies = this.options.targetSpecies ?? 8;\r\n    this.options.compatAdjust = this.options.compatAdjust || {};\r\n    if (this.options.compatAdjust.kp === undefined)\r\n      this.options.compatAdjust.kp = 0.3;\r\n    if (this.options.compatAdjust.ki === undefined)\r\n      this.options.compatAdjust.ki = 0.02;\r\n    if (this.options.compatAdjust.smoothingWindow === undefined)\r\n      this.options.compatAdjust.smoothingWindow = 5;\r\n    if (this.options.compatAdjust.minThreshold === undefined)\r\n      this.options.compatAdjust.minThreshold = 0.5;\r\n    if (this.options.compatAdjust.maxThreshold === undefined)\r\n      this.options.compatAdjust.maxThreshold = 10;\r\n    if (this.options.compatAdjust.decay === undefined)\r\n      this.options.compatAdjust.decay = 0.95;\r\n\r\n    this.createPool(this.options.network || null);\r\n  }\r\n\r\n  // Apply telemetry selection whitelist if provided\r\n  private _applyTelemetrySelect(entry: any): any {\r\n    if (!this._telemetrySelect || !this._telemetrySelect.size) return entry;\r\n    const keep = this._telemetrySelect;\r\n    const core = { gen: entry.gen, best: entry.best, species: entry.species };\r\n    for (const k of Object.keys(entry)) {\r\n      if (k in core) continue;\r\n      if (!keep.has(k)) delete entry[k];\r\n    }\r\n    return Object.assign(entry, core);\r\n  }\r\n\r\n  /** Retrieve non-fatal configuration warnings (e.g., mutation pool sanitation). */\r\n  getWarnings(): string[] {\r\n    return this._warnings.slice();\r\n  }\r\n\r\n  /**\r\n   * Returns an array of objects describing how many consecutive generations each non-protected\r\n   * objective has been detected as \"stale\" (range below pruneInactive.rangeEps). Useful for\r\n   * monitoring which objectives are nearing automatic removal.\r\n   */\r\n  getInactiveObjectiveStats(): { key: string; stale: number }[] {\r\n    const objs = this._getObjectives();\r\n    return objs.map((o) => ({\r\n      key: o.key,\r\n      stale: this._objectiveStale.get(o.key) || 0,\r\n    }));\r\n  }\r\n\r\n  // Build or return cached objectives list\r\n  private _getObjectives(): {\r\n    key: string;\r\n    direction: 'min' | 'max';\r\n    accessor: (g: Network) => number;\r\n  }[] {\r\n    if (this._objectivesList) return this._objectivesList;\r\n    const prevKeys = new Set<string>(\r\n      Array.from(this._objectiveAges.keys()).filter(\r\n        (k) => (this._objectiveAges.get(k) || 0) > 0\r\n      )\r\n    );\r\n    const mo = this.options.multiObjective;\r\n    if (!mo?.enabled) {\r\n      this._objectivesList = [];\r\n      return this._objectivesList;\r\n    }\r\n    if (mo.objectives && mo.objectives.length) {\r\n      this._objectivesList = mo.objectives;\r\n      return this._objectivesList;\r\n    }\r\n    // Default: maximize fitness (score), minimize complexity (nodes or connections)\r\n    const complexityMetric = mo.complexityMetric || 'nodes';\r\n    this._objectivesList = [\r\n      {\r\n        key: 'fitness',\r\n        direction: 'max',\r\n        accessor: (g: any) => g.score ?? -Infinity,\r\n      },\r\n    ];\r\n    // Dynamic scheduling: optionally delay complexity objective introduction\r\n    const dyn = mo.dynamic;\r\n    const addComplexAt = dyn?.addComplexityAt ?? 0;\r\n    // Appear one generation AFTER configured threshold (allows pure fitness for full initial window)\r\n    if (!dyn?.enabled || this.generation >= addComplexAt) {\r\n      this._objectivesList.push({\r\n        key: 'complexity',\r\n        direction: 'min',\r\n        accessor: (g: any) =>\r\n          complexityMetric === 'nodes' ? g.nodes.length : g.connections.length,\r\n      });\r\n    }\r\n    // Entropy objective: support delayed add and temporary drop on stagnation\r\n    let wantEntropy = !!mo.autoEntropy;\r\n    if (wantEntropy && dyn?.enabled) {\r\n      if (dyn.addEntropyAt != null && this.generation < dyn.addEntropyAt)\r\n        wantEntropy = false;\r\n      // Drop on stagnation if configured\r\n      if (\r\n        dyn.dropEntropyOnStagnation != null &&\r\n        dyn.dropEntropyOnStagnation > 0\r\n      ) {\r\n        const stagnGens = this.generation - this._lastGlobalImproveGeneration;\r\n        if (\r\n          !this._entropyTempDropped &&\r\n          stagnGens >= dyn.dropEntropyOnStagnation\r\n        ) {\r\n          // Trigger drop this generation\r\n          this._entropyTempDropped = true;\r\n          this._entropyDropGen = this.generation;\r\n          wantEntropy = false;\r\n        } else if (this._entropyTempDropped) {\r\n          // Re-add after cooldown\r\n          if (\r\n            dyn.readdEntropyAfter != null &&\r\n            this._entropyDropGen != null &&\r\n            this.generation - this._entropyDropGen >= dyn.readdEntropyAfter\r\n          ) {\r\n            this._entropyTempDropped = false;\r\n            this._entropyDropGen = undefined; // allow re-add\r\n          } else {\r\n            wantEntropy = false; // keep suppressed\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (wantEntropy)\r\n      this._objectivesList.push({\r\n        key: 'entropy',\r\n        direction: 'max',\r\n        accessor: (g: any) => this._structuralEntropy(g),\r\n      });\r\n    // Defensive: ensure complexity removed if dynamic delay still in effect (in case earlier code added it)\r\n    if (dyn?.enabled && this.generation < addComplexAt) {\r\n      this._objectivesList = this._objectivesList.filter(\r\n        (o) => o.key !== 'complexity'\r\n      );\r\n    }\r\n    // Update objective ages map: increment active, reset removed\r\n    const activeKeys = new Set(this._objectivesList.map((o) => o.key));\r\n    // Record additions / removals (deferred event emission to telemetry build)\r\n    for (const k of activeKeys)\r\n      if (!prevKeys.has(k)) this._pendingObjectiveAdds.push(k);\r\n    for (const k of prevKeys)\r\n      if (!activeKeys.has(k)) this._pendingObjectiveRemoves.push(k);\r\n    // Increment ages for active objectives\r\n    for (const k of activeKeys)\r\n      this._objectiveAges.set(k, (this._objectiveAges.get(k) || 0) + 1);\r\n    // Reset ages for any objectives previously tracked but now absent\r\n    for (const k of Array.from(this._objectiveAges.keys()))\r\n      if (!activeKeys.has(k)) this._objectiveAges.set(k, 0);\r\n    return this._objectivesList;\r\n  }\r\n\r\n  /** Return current objective keys (rebuilds list if cache invalidated) */\r\n  getObjectiveKeys(): string[] {\r\n    this._objectivesList = undefined as any;\r\n    return this._getObjectives().map((o) => o.key);\r\n  }\r\n\r\n  // Fast non-dominated sort (basic Deb implementation) producing fronts of indices\r\n  private _fastNonDominated(pop: Network[]): number[][] {\r\n    const objs = this._getObjectives();\r\n    if (objs.length === 0) return [];\r\n    const N = pop.length;\r\n    const dominates: number[][] = Array.from({ length: N }, () => []);\r\n    const dominationCount = new Array(N).fill(0);\r\n    const fronts: number[][] = [[]];\r\n    const epsilon = this.options.multiObjective?.dominanceEpsilon ?? 0;\r\n    const values = pop.map((g) => objs.map((o) => o.accessor(g)));\r\n    function better(\r\n      a: number,\r\n      b: number,\r\n      dir: 'min' | 'max',\r\n      eps: number\r\n    ): number {\r\n      // -1 worse, 0 equal-ish, 1 better\r\n      if (dir === 'max') {\r\n        if (a > b + eps) return 1;\r\n        if (b > a + eps) return -1;\r\n        return 0;\r\n      } else {\r\n        if (a < b - eps) return 1;\r\n        if (b < a - eps) return -1;\r\n        return 0;\r\n      }\r\n    }\r\n    for (let p = 0; p < N; p++) {\r\n      for (let q = p + 1; q < N; q++) {\r\n        let pBetter = false,\r\n          qBetter = false;\r\n        for (let k = 0; k < objs.length; k++) {\r\n          const cmp = better(\r\n            values[p][k],\r\n            values[q][k],\r\n            objs[k].direction,\r\n            epsilon\r\n          );\r\n          if (cmp === 1) pBetter = true;\r\n          else if (cmp === -1) qBetter = true;\r\n          if (pBetter && qBetter) break;\r\n        }\r\n        if (pBetter && !qBetter) {\r\n          dominates[p].push(q);\r\n          dominationCount[q]++;\r\n        } else if (qBetter && !pBetter) {\r\n          dominates[q].push(p);\r\n          dominationCount[p]++;\r\n        }\r\n      }\r\n    }\r\n    for (let i = 0; i < N; i++)\r\n      if (dominationCount[i] === 0) {\r\n        (pop[i] as any)._moRank = 0;\r\n        fronts[0].push(i);\r\n      }\r\n    let f = 0;\r\n    while (fronts[f] && fronts[f].length) {\r\n      const next: number[] = [];\r\n      for (const p of fronts[f]) {\r\n        for (const q of dominates[p]) {\r\n          dominationCount[q]--;\r\n          if (dominationCount[q] === 0) {\r\n            (pop[q] as any)._moRank = f + 1;\r\n            next.push(q);\r\n          }\r\n        }\r\n      }\r\n      if (next.length) fronts.push(next);\r\n      else break;\r\n      f++;\r\n    }\r\n    return fronts;\r\n  }\r\n\r\n  // Lightweight structural entropy proxy (degree distribution entropy) for potential objective use\r\n  private _structuralEntropy(g: Network): number {\r\n    // Cache per genome per generation to avoid repeated O(E) scans in objectives, diversity metrics, and telemetry\r\n    const anyG = g as any;\r\n    if (\r\n      anyG._entropyGen === this.generation &&\r\n      typeof anyG._entropyVal === 'number'\r\n    )\r\n      return anyG._entropyVal;\r\n    const deg: Record<number, number> = {};\r\n    for (const n of g.nodes) deg[(n as any).geneId] = 0;\r\n    for (const c of g.connections)\r\n      if (c.enabled) {\r\n        const from = (c.from as any).geneId;\r\n        const to = (c.to as any).geneId;\r\n        if (deg[from] !== undefined) deg[from]++;\r\n        if (deg[to] !== undefined) deg[to]++;\r\n      }\r\n    const hist: Record<number, number> = {};\r\n    const N = g.nodes.length || 1;\r\n    for (const nodeId in deg) {\r\n      const d = deg[nodeId as any];\r\n      hist[d] = (hist[d] || 0) + 1;\r\n    }\r\n    let H = 0;\r\n    for (const k in hist) {\r\n      const p = hist[k as any] / N;\r\n      if (p > 0) H -= p * Math.log(p + 1e-9);\r\n    }\r\n    anyG._entropyGen = this.generation;\r\n    anyG._entropyVal = H;\r\n    return H;\r\n  }\r\n\r\n  private _computeDiversityStats() {\r\n    if (!this.options.diversityMetrics?.enabled) return;\r\n    // Auto tune sampling once if fastMode enabled\r\n    if (this.options.fastMode && !this._fastModeTuned) {\r\n      const dm = this.options.diversityMetrics;\r\n      if (dm) {\r\n        if (dm.pairSample == null) dm.pairSample = 20; // reduce from default 40\r\n        if (dm.graphletSample == null) dm.graphletSample = 30; // reduce from default 60\r\n      }\r\n      // novelty k adjust (smaller) if novelty active and not user-set\r\n      if (this.options.novelty?.enabled && this.options.novelty.k == null)\r\n        this.options.novelty.k = 5;\r\n      this._fastModeTuned = true;\r\n    }\r\n    const pairSample = this.options.diversityMetrics.pairSample ?? 40;\r\n    const graphletSample = this.options.diversityMetrics.graphletSample ?? 60;\r\n    const pop = this.population;\r\n    const n = pop.length;\r\n    let compSum = 0,\r\n      compSq = 0,\r\n      compCount = 0;\r\n    for (let t = 0; t < pairSample; t++) {\r\n      if (n < 2) break;\r\n      const i = Math.floor(this._getRNG()() * n);\r\n      let j = Math.floor(this._getRNG()() * n);\r\n      if (j === i) j = (j + 1) % n;\r\n      const d = this._compatibilityDistance(pop[i], pop[j]);\r\n      compSum += d;\r\n      compSq += d * d;\r\n      compCount++;\r\n    }\r\n    const meanCompat = compCount ? compSum / compCount : 0;\r\n    const varCompat = compCount\r\n      ? Math.max(0, compSq / compCount - meanCompat * meanCompat)\r\n      : 0;\r\n    const entropies = pop.map((g) => this._structuralEntropy(g));\r\n    const meanEntropy =\r\n      entropies.reduce((a, b) => a + b, 0) / (entropies.length || 1);\r\n    const varEntropy = entropies.length\r\n      ? entropies.reduce(\r\n          (a, b) => a + (b - meanEntropy) * (b - meanEntropy),\r\n          0\r\n        ) / entropies.length\r\n      : 0;\r\n    const motifCounts = [0, 0, 0, 0];\r\n    for (let t = 0; t < graphletSample; t++) {\r\n      const g = pop[Math.floor(this._getRNG()() * n)];\r\n      if (!g) break;\r\n      if (g.nodes.length < 3) continue;\r\n      const idxs = new Set<number>();\r\n      while (idxs.size < 3)\r\n        idxs.add(Math.floor(this._getRNG()() * g.nodes.length));\r\n      const arr = Array.from(idxs).map((i) => g.nodes[i]);\r\n      let edges = 0;\r\n      for (const c of g.connections)\r\n        if (c.enabled) {\r\n          if (arr.includes(c.from) && arr.includes(c.to)) edges++;\r\n        }\r\n      if (edges > 3) edges = 3;\r\n      motifCounts[edges]++;\r\n    }\r\n    const totalMotifs = motifCounts.reduce((a, b) => a + b, 0) || 1;\r\n    let graphletEntropy = 0;\r\n    for (let k = 0; k < motifCounts.length; k++) {\r\n      const p = motifCounts[k] / totalMotifs;\r\n      if (p > 0) graphletEntropy -= p * Math.log(p);\r\n    }\r\n    // Lineage depth diversity (if lineage tracking enabled): mean depth & mean absolute depth diff of sampled pairs\r\n    let lineageMeanDepth = 0;\r\n    let lineageMeanPairDist = 0;\r\n    if (this._lineageEnabled && n > 0) {\r\n      const depths = pop.map((g) => (g as any)._depth ?? 0);\r\n      lineageMeanDepth = depths.reduce((a, b) => a + b, 0) / n;\r\n      let pairSum = 0,\r\n        pairN = 0;\r\n      for (let t = 0; t < Math.min(pairSample, (n * (n - 1)) / 2); t++) {\r\n        if (n < 2) break;\r\n        const i = Math.floor(this._getRNG()() * n);\r\n        let j = Math.floor(this._getRNG()() * n);\r\n        if (j === i) j = (j + 1) % n;\r\n        pairSum += Math.abs(depths[i] - depths[j]);\r\n        pairN++;\r\n      }\r\n      lineageMeanPairDist = pairN ? pairSum / pairN : 0;\r\n    }\r\n    this._diversityStats = {\r\n      meanCompat,\r\n      varCompat,\r\n      meanEntropy,\r\n      varEntropy,\r\n      graphletEntropy,\r\n      lineageMeanDepth,\r\n      lineageMeanPairDist,\r\n    };\r\n  }\r\n\r\n  // Invalidate per-genome cached analytics after structural mutation phases\r\n  private _invalidateGenomeCaches(genome: Network) {\r\n    const anyG = genome as any;\r\n    if (anyG._compatCache) anyG._compatCache = undefined;\r\n    if (anyG._entropyGen !== undefined) {\r\n      anyG._entropyGen = -1;\r\n      anyG._entropyVal = undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the minimum hidden layer size for a network based on input/output sizes.\r\n   * Uses the formula: max(input, output) x multiplier (default random 2-5)\r\n   * Allows deterministic override for testing.\r\n   * @param multiplierOverride Optional fixed multiplier for deterministic tests\r\n   * @returns The minimum number of hidden nodes required in each hidden layer\r\n   */\r\n  getMinimumHiddenSize(multiplierOverride?: number): number {\r\n    let hiddenLayerMultiplier: number;\r\n    if (typeof multiplierOverride === 'number') {\r\n      hiddenLayerMultiplier = multiplierOverride;\r\n    } else if (typeof this.options.hiddenLayerMultiplier === 'number') {\r\n      hiddenLayerMultiplier = this.options.hiddenLayerMultiplier;\r\n    } else {\r\n      const rng = this._getRNG();\r\n      hiddenLayerMultiplier = Math.floor(rng() * (4 - 2 + 1)) + 2; // 2 to 4\r\n    }\r\n    return Math.max(this.input, this.output) * hiddenLayerMultiplier;\r\n  }\r\n\r\n  private _getRNG(): () => number {\r\n    if (this._rng) return this._rng;\r\n    if (typeof this.options.seed === 'number') {\r\n      this._rngState = this.options.seed >>> 0;\r\n      this._rng = () => {\r\n        this._rngState = (this._rngState! + 0x6d2b79f5) >>> 0;\r\n        let r = Math.imul(\r\n          this._rngState! ^ (this._rngState! >>> 15),\r\n          1 | this._rngState!\r\n        );\r\n        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);\r\n        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;\r\n      };\r\n      return this._rng;\r\n    }\r\n    this._rng = Math.random;\r\n    return this._rng;\r\n  }\r\n\r\n  /**\r\n   * Snapshot current RNG state (if seeded) for reproducibility checkpoints.\r\n   * Returns null if using global Math.random without internal state.\r\n   */\r\n  snapshotRNGState(): { state: number } | null {\r\n    if (this._rngState === undefined) return null;\r\n    return { state: this._rngState };\r\n  }\r\n\r\n  /** Restore RNG state previously captured via snapshotRNGState. */\r\n  restoreRNGState(s: { state: number } | null | undefined): void {\r\n    if (!s) return;\r\n    this._rngState = s.state >>> 0;\r\n    // Reinstall deterministic PRNG based on current internal state\r\n    this._rng = () => {\r\n      this._rngState = (this._rngState! + 0x6d2b79f5) >>> 0;\r\n      let r = Math.imul(\r\n        this._rngState! ^ (this._rngState! >>> 15),\r\n        1 | this._rngState!\r\n      );\r\n      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);\r\n      return ((r ^ (r >>> 14)) >>> 0) / 4294967296;\r\n    };\r\n  }\r\n\r\n  /** Export RNG state as JSON string for persistence */\r\n  exportRNGState(): string {\r\n    const snap = this.snapshotRNGState();\r\n    return JSON.stringify(snap);\r\n  }\r\n\r\n  /** Import RNG state from JSON produced by exportRNGState */\r\n  importRNGState(json: string): void {\r\n    try {\r\n      const obj = JSON.parse(json);\r\n      this.restoreRNGState(obj);\r\n    } catch {\r\n      /* ignore */\r\n    }\r\n  }\r\n\r\n  /** Sample raw RNG outputs (advances state) for testing or reproducibility checks */\r\n  sampleRandom(count: number): number[] {\r\n    const rng = this._getRNG();\r\n    const out: number[] = [];\r\n    for (let i = 0; i < count; i++) out.push(rng());\r\n    return out;\r\n  }\r\n\r\n  /**\r\n   * Checks if a network meets the minimum hidden node requirements.\r\n   * Returns information about hidden layer sizes without modifying the network.\r\n   * @param network The network to check\r\n   * @param multiplierOverride Optional fixed multiplier for deterministic tests\r\n   * @returns Object containing information about hidden layer compliance\r\n   */\r\n  checkHiddenSizes(\r\n    network: Network,\r\n    multiplierOverride?: number\r\n  ): {\r\n    compliant: boolean;\r\n    minRequired: number;\r\n    hiddenLayerSizes: number[];\r\n  } {\r\n    const minHidden = this.getMinimumHiddenSize(multiplierOverride);\r\n    const result = {\r\n      compliant: true,\r\n      minRequired: minHidden,\r\n      hiddenLayerSizes: [] as number[],\r\n    };\r\n\r\n    // Check networks with explicit layers\r\n    if (network.layers && network.layers.length >= 3) {\r\n      // Go through hidden layers (skip input layer [0] and output layer [length-1])\r\n      for (let i = 1; i < network.layers.length - 1; i++) {\r\n        const layer = network.layers[i];\r\n        if (!layer || !Array.isArray(layer.nodes)) {\r\n          result.hiddenLayerSizes.push(0);\r\n          result.compliant = false;\r\n          continue;\r\n        }\r\n\r\n        const layerSize = layer.nodes.length;\r\n        result.hiddenLayerSizes.push(layerSize);\r\n\r\n        if (layerSize < minHidden) {\r\n          result.compliant = false;\r\n        }\r\n      }\r\n    } else {\r\n      // Flat/legacy network: check total hidden node count\r\n      const hiddenCount = network.nodes.filter((n) => n.type === 'hidden')\r\n        .length;\r\n      result.hiddenLayerSizes.push(hiddenCount);\r\n\r\n      if (hiddenCount < minHidden) {\r\n        result.compliant = false;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Ensures that the network has at least min(input, output) + 1 hidden nodes in each hidden layer.\r\n   * This prevents bottlenecks in networks where hidden layers might be too small.\r\n   * For layered networks: Ensures each hidden layer has at least the minimum size.\r\n   * For non-layered networks: Reorganizes into proper layers with the minimum size.\r\n   * @param network The network to check and modify\r\n   * @param multiplierOverride Optional fixed multiplier for deterministic tests\r\n   */\r\n  private ensureMinHiddenNodes(network: Network, multiplierOverride?: number) {\r\n    const maxNodes = this.options.maxNodes || Infinity;\r\n    const minHidden = Math.min(\r\n      this.getMinimumHiddenSize(multiplierOverride),\r\n      maxNodes - network.nodes.filter((n) => n.type !== 'hidden').length\r\n    );\r\n\r\n    const inputNodes = network.nodes.filter((n) => n.type === 'input');\r\n    const outputNodes = network.nodes.filter((n) => n.type === 'output');\r\n    let hiddenNodes = network.nodes.filter((n) => n.type === 'hidden');\r\n\r\n    if (inputNodes.length === 0 || outputNodes.length === 0) {\r\n      console.warn(\r\n        'Network is missing input or output nodes. Cannot ensure minimum hidden nodes.'\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Only add hidden nodes if needed, do not disconnect/reconnect existing ones\r\n    const existingCount = hiddenNodes.length;\r\n    for (\r\n      let i = existingCount;\r\n      i < minHidden && network.nodes.length < maxNodes;\r\n      i++\r\n    ) {\r\n      const NodeClass = require('./architecture/node').default;\r\n      const newNode = new NodeClass('hidden');\r\n      network.nodes.push(newNode);\r\n      hiddenNodes.push(newNode);\r\n    }\r\n\r\n    // Ensure each hidden node has at least one input and one output connection\r\n    for (const hiddenNode of hiddenNodes) {\r\n      // At least one input connection (from input or another hidden)\r\n      if (hiddenNode.connections.in.length === 0) {\r\n        const candidates = inputNodes.concat(\r\n          hiddenNodes.filter((n) => n !== hiddenNode)\r\n        );\r\n        if (candidates.length > 0) {\r\n          const rng = this._getRNG();\r\n          const source = candidates[Math.floor(rng() * candidates.length)];\r\n          try {\r\n            network.connect(source, hiddenNode);\r\n          } catch {}\r\n        }\r\n      }\r\n      // At least one output connection (to output or another hidden)\r\n      if (hiddenNode.connections.out.length === 0) {\r\n        const candidates = outputNodes.concat(\r\n          hiddenNodes.filter((n) => n !== hiddenNode)\r\n        );\r\n        if (candidates.length > 0) {\r\n          const rng = this._getRNG();\r\n          const target = candidates[Math.floor(rng() * candidates.length)];\r\n          try {\r\n            network.connect(hiddenNode, target);\r\n          } catch {}\r\n        }\r\n      }\r\n    }\r\n\r\n    // Ensure network.connections is consistent with per-node connections after all changes\r\n    Network.rebuildConnections(network);\r\n  }\r\n\r\n  // Helper method to check if a connection exists between two nodes\r\n  private hasConnectionBetween(\r\n    network: Network,\r\n    from: NodeType,\r\n    to: NodeType\r\n  ): boolean {\r\n    return network.connections.some(\r\n      (conn) => conn.from === from && conn.to === to\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Ensures that all input nodes have at least one outgoing connection,\r\n   * all output nodes have at least one incoming connection,\r\n   * and all hidden nodes have at least one incoming and one outgoing connection.\r\n   * This prevents dead ends and blind I/O neurons.\r\n   * @param network The network to check and fix\r\n   */\r\n  private ensureNoDeadEnds(network: Network) {\r\n    const inputNodes = network.nodes.filter((n) => n.type === 'input');\r\n    const outputNodes = network.nodes.filter((n) => n.type === 'output');\r\n    const hiddenNodes = network.nodes.filter((n) => n.type === 'hidden');\r\n\r\n    // Helper to check if a node has a connection in a direction\r\n    const hasOutgoing = (node: any) =>\r\n      node.connections &&\r\n      node.connections.out &&\r\n      node.connections.out.length > 0;\r\n    const hasIncoming = (node: any) =>\r\n      node.connections && node.connections.in && node.connections.in.length > 0;\r\n\r\n    // 1. Ensure all input nodes have at least one outgoing connection\r\n    for (const inputNode of inputNodes) {\r\n      if (!hasOutgoing(inputNode)) {\r\n        // Try to connect to a random hidden or output node\r\n        const candidates = hiddenNodes.length > 0 ? hiddenNodes : outputNodes;\r\n        if (candidates.length > 0) {\r\n          const rng = this._getRNG();\r\n          const target = candidates[Math.floor(rng() * candidates.length)];\r\n          try {\r\n            network.connect(inputNode, target);\r\n          } catch (e: any) {\r\n            // Ignore duplicate connection errors\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // 2. Ensure all output nodes have at least one incoming connection\r\n    for (const outputNode of outputNodes) {\r\n      if (!hasIncoming(outputNode)) {\r\n        // Try to connect from a random hidden or input node\r\n        const candidates = hiddenNodes.length > 0 ? hiddenNodes : inputNodes;\r\n        if (candidates.length > 0) {\r\n          const rng = this._getRNG();\r\n          const source = candidates[Math.floor(rng() * candidates.length)];\r\n          try {\r\n            network.connect(source, outputNode);\r\n          } catch (e: any) {\r\n            // Ignore duplicate connection errors\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // 3. Ensure all hidden nodes have at least one incoming and one outgoing connection\r\n    for (const hiddenNode of hiddenNodes) {\r\n      if (!hasIncoming(hiddenNode)) {\r\n        // Try to connect from input or another hidden node\r\n        const candidates = inputNodes.concat(\r\n          hiddenNodes.filter((n) => n !== hiddenNode)\r\n        );\r\n        if (candidates.length > 0) {\r\n          const rng = this._getRNG();\r\n          const source = candidates[Math.floor(rng() * candidates.length)];\r\n          try {\r\n            network.connect(source, hiddenNode);\r\n          } catch (e: any) {\r\n            // Ignore duplicate connection errors\r\n          }\r\n        }\r\n      }\r\n      if (!hasOutgoing(hiddenNode)) {\r\n        // Try to connect to output or another hidden node\r\n        const candidates = outputNodes.concat(\r\n          hiddenNodes.filter((n) => n !== hiddenNode)\r\n        );\r\n        if (candidates.length > 0) {\r\n          const rng = this._getRNG();\r\n          const target = candidates[Math.floor(rng() * candidates.length)];\r\n          try {\r\n            network.connect(hiddenNode, target);\r\n          } catch (e: any) {\r\n            // Ignore duplicate connection errors\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evaluates the fitness of the current population.\r\n   * If `fitnessPopulation` is true, evaluates the entire population at once.\r\n   * Otherwise, evaluates each genome individually.\r\n   * @returns A promise that resolves when evaluation is complete.\r\n   */\r\n  async evaluate(): Promise<void> {\r\n    const _t0 =\r\n      typeof performance !== 'undefined' && (performance as any).now\r\n        ? (performance as any).now()\r\n        : Date.now();\r\n    if (this.options.fitnessPopulation) {\r\n      if (this.options.clear)\r\n        this.population.forEach((genome) => genome.clear());\r\n      await this.fitness(this.population as any);\r\n    } else {\r\n      for (const genome of this.population) {\r\n        if (this.options.clear) genome.clear();\r\n        genome.score = await this.fitness(genome);\r\n      }\r\n    }\r\n    // Minimal criterion filtering (function)\r\n    if (this.options.minimalCriterion) {\r\n      for (const g of this.population)\r\n        if (!this.options.minimalCriterion(g)) g.score = 0;\r\n    }\r\n    // Static threshold criterion\r\n    if (typeof this.options.minimalCriterionThreshold === 'number') {\r\n      const thr = this.options.minimalCriterionThreshold;\r\n      for (const g of this.population) if ((g.score || 0) < thr) g.score = 0;\r\n    }\r\n    // Adaptive minimal criterion updates AFTER evaluation (don\u2019t zero until next gen to gather acceptance rate)\r\n    if (this.options.minimalCriterionAdaptive?.enabled) {\r\n      const mc = this.options.minimalCriterionAdaptive;\r\n      if ((this as any)._mcThreshold === undefined)\r\n        (this as any)._mcThreshold = mc.initialThreshold ?? 0;\r\n      const metric = mc.metric || 'score';\r\n      // Compute acceptance based on previous threshold\r\n      const thr = (this as any)._mcThreshold;\r\n      let accepted = 0;\r\n      for (const g of this.population) {\r\n        const val =\r\n          metric === 'novelty' ? (g as any)._novelty || 0 : g.score || 0;\r\n        if (val >= thr) accepted++;\r\n      }\r\n      const acceptance = accepted / (this.population.length || 1);\r\n      const target = mc.targetAcceptance ?? 0.5;\r\n      const rate = mc.adjustRate ?? 0.1;\r\n      // Adjust threshold so acceptance moves toward target\r\n      (this as any)._mcThreshold +=\r\n        rate *\r\n        (target - acceptance) *\r\n        (Math.abs((this as any)._mcThreshold) + 1);\r\n      // Now zero those below new threshold (enforces for rest of pipeline)\r\n      const newThr = (this as any)._mcThreshold;\r\n      for (const g of this.population) {\r\n        const val =\r\n          metric === 'novelty' ? (g as any)._novelty || 0 : g.score || 0;\r\n        if (val < newThr) g.score = 0;\r\n      }\r\n    }\r\n    if (this.options.speciation) {\r\n      this._speciate();\r\n      this._applyFitnessSharing();\r\n    }\r\n    // Optional lineage pressure: includes depth-based modes and anti-inbreeding bias\r\n    if (\r\n      this._lineageEnabled &&\r\n      (this.options as any).lineagePressure?.enabled\r\n    ) {\r\n      const lp = (this.options as any).lineagePressure;\r\n      const mode = lp.mode || 'penalizeDeep';\r\n      const targetMean = lp.targetMeanDepth ?? 4;\r\n      const k = lp.strength ?? 0.02; // generic scaling\r\n      const depths = this.population.map((g) => (g as any)._depth ?? 0);\r\n      const meanDepth =\r\n        depths.reduce((a, b) => a + b, 0) / (depths.length || 1);\r\n      if (mode !== 'antiInbreeding') {\r\n        for (let i = 0; i < this.population.length; i++) {\r\n          const g = this.population[i];\r\n          const d = depths[i];\r\n          let adj = 0;\r\n          if (mode === 'penalizeDeep') {\r\n            if (d > targetMean) adj = -k * (d - targetMean);\r\n          } else if (mode === 'rewardShallow') {\r\n            if (d <= targetMean) adj = k * (targetMean - d);\r\n          } else if (mode === 'spread') {\r\n            adj = k * (d - meanDepth);\r\n            if (d > targetMean * 2) adj -= k * (d - targetMean * 2); // cap runaway depth\r\n          }\r\n          if (adj !== 0 && typeof g.score === 'number')\r\n            g.score += adj * Math.max(1, Math.abs(g.score));\r\n        }\r\n      } else {\r\n        // Anti-inbreeding: penalize offspring with highly overlapping ancestor sets, reward diversity\r\n        // Build recent ancestor window sets per genome lazily (cache on genome for this generation)\r\n        const window = lp.ancestorWindow ?? 4; // depth window to consider\r\n        const penalty = lp.inbreedingPenalty ?? k * 2;\r\n        const bonus = lp.diversityBonus ?? k;\r\n        // Precompute ancestor line (IDs) up to window for each genome via BFS over parents\r\n        const ancestorMap: Map<number, Set<number>> = new Map();\r\n        const getAncestors = (g: any): Set<number> => {\r\n          const id = g._id;\r\n          if (ancestorMap.has(id)) return ancestorMap.get(id)!;\r\n          const s = new Set<number>();\r\n          const queue: { id: number; depth: number; g: any }[] = [];\r\n          if (Array.isArray(g._parents)) {\r\n            for (const pid of g._parents)\r\n              queue.push({\r\n                id: pid,\r\n                depth: 1,\r\n                g: this.population.find((x) => (x as any)._id === pid),\r\n              });\r\n          }\r\n          while (queue.length) {\r\n            const cur = queue.shift()!;\r\n            if (cur.depth > window) continue;\r\n            if (cur.id != null) s.add(cur.id);\r\n            if (cur.g && Array.isArray(cur.g._parents)) {\r\n              for (const pid of cur.g._parents)\r\n                queue.push({\r\n                  id: pid,\r\n                  depth: cur.depth + 1,\r\n                  g: this.population.find((x) => (x as any)._id === pid),\r\n                });\r\n            }\r\n          }\r\n          ancestorMap.set(id, s);\r\n          return s;\r\n        };\r\n        // For each genome measure ancestor overlap of its parents; if identical or highly overlapping penalize\r\n        for (const g of this.population) {\r\n          if (\r\n            !Array.isArray((g as any)._parents) ||\r\n            (g as any)._parents.length < 2\r\n          )\r\n            continue;\r\n          const pids = (g as any)._parents;\r\n          const pA = this.population.find((x) => (x as any)._id === pids[0]);\r\n          const pB = this.population.find((x) => (x as any)._id === pids[1]);\r\n          if (!pA || !pB) continue;\r\n          const aA = getAncestors(pA as any);\r\n          aA.add((pA as any)._id);\r\n          const aB = getAncestors(pB as any);\r\n          aB.add((pB as any)._id);\r\n          // Jaccard similarity\r\n          let inter = 0;\r\n          for (const id of aA) if (aB.has(id)) inter++;\r\n          const union = aA.size + aB.size - inter || 1;\r\n          const jaccard = inter / union; // 0 distinct, 1 identical\r\n          // Apply penalty/bonus scaled by similarity extremes\r\n          if (jaccard > 0.75) {\r\n            // highly overlapping -> penalize\r\n            (g as any).score +=\r\n              -penalty *\r\n              (jaccard - 0.75) *\r\n              Math.max(1, Math.abs((g as any).score || 1));\r\n          } else if (jaccard < 0.25) {\r\n            // very distinct -> reward\r\n            (g as any).score +=\r\n              bonus *\r\n              (0.25 - jaccard) *\r\n              Math.max(1, Math.abs((g as any).score || 1));\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Adaptive sharing sigma control based on fragmentation (#species / popsize)\r\n    if (\r\n      this.options.adaptiveSharing?.enabled &&\r\n      (this.options.sharingSigma || 0) > 0 &&\r\n      this.options.speciation\r\n    ) {\r\n      const frag = this._species.length / (this.population.length || 1);\r\n      const target = this.options.adaptiveSharing.targetFragmentation ?? 0.15;\r\n      const step = this.options.adaptiveSharing.adjustStep ?? 0.1;\r\n      const minS = this.options.adaptiveSharing.minSigma ?? 0.5;\r\n      const maxS = this.options.adaptiveSharing.maxSigma ?? 5;\r\n      if (frag > target * 1.2)\r\n        this.options.sharingSigma = Math.min(\r\n          maxS,\r\n          (this.options.sharingSigma || 0) + step\r\n        );\r\n      // too fragmented -> widen kernel (higher sigma) reduces penalization overlap? (here treat as smoothing)\r\n      else if (frag < target * 0.8)\r\n        this.options.sharingSigma = Math.max(\r\n          minS,\r\n          (this.options.sharingSigma || 0) - step\r\n        ); // too few species -> tighten sigma\r\n    }\r\n    // Entropy-guided sharing sigma tuning: adjust sigma to push entropy variance toward target\r\n    if (\r\n      this.options.entropySharingTuning?.enabled &&\r\n      (this.options.sharingSigma || 0) > 0 &&\r\n      this._diversityStats\r\n    ) {\r\n      const cfg = this.options.entropySharingTuning;\r\n      const targetVar = cfg.targetEntropyVar ?? 0.15;\r\n      const rate = cfg.adjustRate ?? 0.05;\r\n      const minS = cfg.minSigma ?? 0.3;\r\n      const maxS = cfg.maxSigma ?? 6;\r\n      const varEntropy = this._diversityStats.varEntropy || 0;\r\n      // If variance low -> shrink sigma (stronger local pressure), if variance high -> expand sigma (more sharing)\r\n      if (varEntropy < targetVar * 0.8)\r\n        this.options.sharingSigma = Math.max(\r\n          minS,\r\n          (this.options.sharingSigma || 0) * (1 - rate)\r\n        );\r\n      else if (varEntropy > targetVar * 1.2)\r\n        this.options.sharingSigma = Math.min(\r\n          maxS,\r\n          (this.options.sharingSigma || 0) * (1 + rate)\r\n        );\r\n    }\r\n    // Entropy-guided compatibility threshold tuning (adjust NEAT speciation threshold to pursue target structural entropy)\r\n    if (this.options.entropyCompatTuning?.enabled && this._diversityStats) {\r\n      const cfg = this.options.entropyCompatTuning;\r\n      const target =\r\n        cfg.targetEntropy ?? (this._diversityStats.meanEntropy || 0); // fallback to current if not provided\r\n      const adjust = cfg.adjustRate ?? 0.05;\r\n      const dead = cfg.deadband ?? 0.05; // relative deadband\r\n      const meanE = this._diversityStats.meanEntropy || 0;\r\n      let thr = this.options.compatibilityThreshold ?? 3.0;\r\n      if (target > 0) {\r\n        if (meanE < target * (1 - dead)) {\r\n          // low entropy -> increase fragmentation -> lower threshold\r\n          thr -= adjust;\r\n        } else if (meanE > target * (1 + dead)) {\r\n          // high entropy -> consolidate -> raise threshold\r\n          thr += adjust;\r\n        }\r\n        const minT = cfg.minThreshold ?? 0.5;\r\n        const maxT = cfg.maxThreshold ?? 10;\r\n        if (thr < minT) thr = minT;\r\n        if (thr > maxT) thr = maxT;\r\n        this.options.compatibilityThreshold = thr;\r\n      }\r\n    }\r\n    // Adaptive target species (maps structural entropy to target species count, influencing compat controller indirectly)\r\n    if (this.options.adaptiveTargetSpecies?.enabled && this._diversityStats) {\r\n      const cfg = this.options.adaptiveTargetSpecies;\r\n      const [eMin, eMax] = cfg.entropyRange || [0, 1];\r\n      const [sMin, sMax] = cfg.speciesRange || [4, 16];\r\n      const meanE = this._diversityStats.meanEntropy || 0;\r\n      const t = Math.max(0, Math.min(1, (meanE - eMin) / (eMax - eMin || 1)));\r\n      const smooth = cfg.smooth ?? 0.8; // EMA smoothing\r\n      const rawTarget = Math.round(sMin + (sMax - sMin) * t);\r\n      if (typeof this.options.targetSpecies === 'number') {\r\n        this.options.targetSpecies = Math.round(\r\n          smooth * this.options.targetSpecies + (1 - smooth) * rawTarget\r\n        );\r\n      } else {\r\n        this.options.targetSpecies = rawTarget;\r\n      }\r\n    }\r\n    // Auto distance coefficient tuning (excess/disjoint) based on entropy deviation\r\n    if (this.options.autoDistanceCoeffTuning?.enabled && this._diversityStats) {\r\n      const cfg = this.options.autoDistanceCoeffTuning;\r\n      const targetE =\r\n        cfg.targetEntropy ?? (this._diversityStats.meanEntropy || 0);\r\n      const meanE = this._diversityStats.meanEntropy || 0;\r\n      const err = meanE - targetE; // positive => too diverse (maybe relax distances)\r\n      const rate = cfg.adjustRate ?? 0.01;\r\n      const minC = cfg.minCoeff ?? 0.1;\r\n      const maxC = cfg.maxCoeff ?? 5;\r\n      if (Math.abs(err) > targetE * 0.05 + 1e-6) {\r\n        const factor = 1 + rate * (err > 0 ? -1 : 1); // if entropy high reduce coeffs (create more merges), else increase\r\n        this.options.excessCoeff = Math.min(\r\n          maxC,\r\n          Math.max(minC, (this.options.excessCoeff || 1) * factor)\r\n        );\r\n        this.options.disjointCoeff = Math.min(\r\n          maxC,\r\n          Math.max(minC, (this.options.disjointCoeff || 1) * factor)\r\n        );\r\n      }\r\n    }\r\n    // Novelty search blending (after fitness sharing so base fitness is adjusted first)\r\n    if (this.options.novelty?.enabled && this.options.novelty.descriptor) {\r\n      const descFn = this.options.novelty.descriptor;\r\n      const k = this.options.novelty.k ?? 10;\r\n      const alpha = this.options.novelty.blendFactor ?? 0.5;\r\n      const threshold = this.options.novelty.archiveAddThreshold ?? 0.5;\r\n      const maxArchive = this.options.novelty.maxArchive ?? 1000;\r\n      const dist = (a: number[], b: number[]) => {\r\n        const n = Math.min(a.length, b.length);\r\n        let s = 0;\r\n        for (let i = 0; i < n; i++) {\r\n          const dx = a[i] - b[i];\r\n          s += dx * dx;\r\n        }\r\n        return Math.sqrt(s);\r\n      };\r\n      const popDescs = this.population.map((g) => ({ g, d: descFn(g) }));\r\n      // Compute novelty (mean distance to k nearest among population + archive)\r\n      let insertedThisGen = 0;\r\n      for (const item of popDescs) {\r\n        const dists: number[] = [];\r\n        for (const other of popDescs)\r\n          if (other !== item) dists.push(dist(item.d, other.d));\r\n        for (const arch of this._noveltyArchive)\r\n          dists.push(dist(item.d, arch.d));\r\n        dists.sort((a, b) => a - b);\r\n        const kEff = Math.min(k, dists.length);\r\n        const meanK =\r\n          kEff > 0 ? dists.slice(0, kEff).reduce((s, v) => s + v, 0) / kEff : 0;\r\n        (item.g as any)._novelty = meanK;\r\n        if (meanK >= threshold) {\r\n          this._noveltyArchive.push({ d: item.d });\r\n          insertedThisGen++;\r\n        }\r\n      }\r\n      // Adaptive threshold aiming for target insertion rate\r\n      if (this.options.novelty.dynamicThreshold?.enabled) {\r\n        const target = this.options.novelty.dynamicThreshold.targetRate ?? 0.1; // fraction of population\r\n        const adjust = this.options.novelty.dynamicThreshold.adjust ?? 0.05;\r\n        const minT = this.options.novelty.dynamicThreshold.min ?? 0.01;\r\n        const maxT = this.options.novelty.dynamicThreshold.max ?? 10;\r\n        const actual = this.population.length\r\n          ? insertedThisGen / this.population.length\r\n          : 0;\r\n        let thr = this.options.novelty.archiveAddThreshold ?? threshold;\r\n        if (actual > target * 1.2) thr *= 1 + adjust;\r\n        else if (actual < target * 0.8) thr *= 1 - adjust;\r\n        if (thr < minT) thr = minT;\r\n        if (thr > maxT) thr = maxT;\r\n        this.options.novelty.archiveAddThreshold = thr;\r\n      }\r\n      if (this._noveltyArchive.length > maxArchive)\r\n        this._noveltyArchive.splice(\r\n          0,\r\n          this._noveltyArchive.length - maxArchive\r\n        );\r\n      // Optional sparse pruning: keep diverse representatives by removing closest pair iteratively until under limit\r\n      if (\r\n        this.options.novelty.pruneStrategy === 'sparse' &&\r\n        this._noveltyArchive.length > maxArchive\r\n      ) {\r\n        const dist = (a: number[], b: number[]) => {\r\n          const n = Math.min(a.length, b.length);\r\n          let s = 0;\r\n          for (let i = 0; i < n; i++) {\r\n            const d = a[i] - b[i];\r\n            s += d * d;\r\n          }\r\n          return Math.sqrt(s);\r\n        };\r\n        while (this._noveltyArchive.length > maxArchive) {\r\n          let bestI = -1,\r\n            bestJ = -1,\r\n            bestD = Infinity;\r\n          for (let i = 0; i < this._noveltyArchive.length; i++)\r\n            for (let j = i + 1; j < this._noveltyArchive.length; j++) {\r\n              const d = dist(\r\n                this._noveltyArchive[i].d,\r\n                this._noveltyArchive[j].d\r\n              );\r\n              if (d < bestD) {\r\n                bestD = d;\r\n                bestI = i;\r\n                bestJ = j;\r\n              }\r\n            }\r\n          if (bestI >= 0) this._noveltyArchive.splice(bestI, 1);\r\n          else break;\r\n        }\r\n      }\r\n      // Blend scores\r\n      if (alpha > 0) {\r\n        for (const item of popDescs) {\r\n          if (typeof item.g.score === 'number') {\r\n            item.g.score =\r\n              (1 - alpha) * item.g.score +\r\n              alpha * ((item.g as any)._novelty || 0);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Diversity pressure (motif frequency penalty) simple heuristic\r\n    if (this.options.diversityPressure?.enabled) {\r\n      const sample = this.options.diversityPressure.motifSample ?? 25;\r\n      // Build motif signatures as sorted small tuples of enabled connection endpoints (limited sample)\r\n      const freq: Map<string, number> = new Map();\r\n      for (const g of this.population) {\r\n        const conns = (g as any).connections || (g as any).connections || [];\r\n        const motifs: string[] = [];\r\n        for (let i = 0; i < conns.length && i < sample; i++) {\r\n          const c = conns[i];\r\n          if (!c.enabled) continue;\r\n          motifs.push(`${c.from.index}->${c.to.index}`);\r\n        }\r\n        motifs.sort();\r\n        const sig = motifs.slice(0, Math.min(5, motifs.length)).join('|');\r\n        const prev = freq.get(sig) || 0;\r\n        freq.set(sig, prev + 1);\r\n        (g as any)._motifSig = sig;\r\n      }\r\n      const penaltyStrength =\r\n        this.options.diversityPressure.penaltyStrength ?? 0.1;\r\n      const popSize = this.population.length || 1;\r\n      for (const g of this.population) {\r\n        const sig = (g as any)._motifSig;\r\n        if (sig && typeof g.score === 'number') {\r\n          const f = freq.get(sig) || 1; // frequency of this motif signature\r\n          const rarity = 1 - f / popSize; // rare -> near 1, common -> near 0\r\n          // Apply small bonus relative to rarity (negative penalty for common motifs)\r\n          g.score = g.score * (1 + penaltyStrength * (rarity - 0.5));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evolves the population by selecting, mutating, and breeding genomes.\r\n   * Implements elitism, provenance, and crossover to create the next generation.\r\n   * @returns The fittest network from the current generation.\r\n   * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6 Instinct: neuro-evolution on steroids by Thomas Wagenaar}\r\n   */\r\n  async evolve(): Promise<Network> {\r\n    const __e0 =\r\n      typeof performance !== 'undefined' && (performance as any).now\r\n        ? (performance as any).now()\r\n        : Date.now();\r\n    if (this.population[this.population.length - 1].score === undefined) {\r\n      await this.evaluate();\r\n    }\r\n    // Invalidate objectives list so dynamic scheduling can introduce/remove objectives based on generation / stagnation\r\n    this._objectivesList = undefined as any;\r\n    // Complexity budget schedule\r\n    if (this.options.complexityBudget?.enabled) {\r\n      const cb = this.options.complexityBudget;\r\n      if (cb.mode === 'adaptive') {\r\n        if (!(this as any)._cbHistory) (this as any)._cbHistory = [];\r\n        (this as any)._cbHistory.push(this.population[0]?.score || 0);\r\n        const window = cb.improvementWindow ?? 10;\r\n        if ((this as any)._cbHistory.length > window)\r\n          (this as any)._cbHistory.shift();\r\n        const hist: number[] = (this as any)._cbHistory;\r\n        const improvement =\r\n          hist.length > 1 ? hist[hist.length - 1] - hist[0] : 0;\r\n        // Linear regression slope (approx) over window for directionality\r\n        let slope = 0;\r\n        if (hist.length > 2) {\r\n          const n = hist.length;\r\n          let sumX = 0,\r\n            sumY = 0,\r\n            sumXY = 0,\r\n            sumXX = 0;\r\n          for (let i = 0; i < n; i++) {\r\n            sumX += i;\r\n            sumY += hist[i];\r\n            sumXY += i * hist[i];\r\n            sumXX += i * i;\r\n          }\r\n          const denom = n * sumXX - sumX * sumX || 1;\r\n          slope = (n * sumXY - sumX * sumY) / denom;\r\n        }\r\n        if ((this as any)._cbMaxNodes === undefined)\r\n          (this as any)._cbMaxNodes =\r\n            cb.maxNodesStart ?? this.input + this.output + 2;\r\n        const baseInc = cb.increaseFactor ?? 1.1;\r\n        const baseStag = cb.stagnationFactor ?? 0.95;\r\n        // Modulate factors by slope magnitude (positive slope -> stronger increase, negative -> stronger contraction)\r\n        const slopeMag = Math.min(\r\n          2,\r\n          Math.max(-2, slope / (Math.abs(hist[0]) + 1e-9))\r\n        );\r\n        const incF = baseInc + 0.05 * Math.max(0, slopeMag);\r\n        const stagF = baseStag - 0.03 * Math.max(0, -slopeMag);\r\n        // Diversity modulation: if novelty archive stagnant reduce growth\r\n        const noveltyFactor = this._noveltyArchive.length > 5 ? 1 : 0.9;\r\n        if (improvement > 0 || slope > 0)\r\n          (this as any)._cbMaxNodes = Math.min(\r\n            cb.maxNodesEnd ?? (this as any)._cbMaxNodes * 4,\r\n            Math.floor((this as any)._cbMaxNodes * incF * noveltyFactor)\r\n          );\r\n        else if (hist.length === window)\r\n          (this as any)._cbMaxNodes = Math.max(\r\n            cb.minNodes ?? this.input + this.output + 2,\r\n            Math.floor((this as any)._cbMaxNodes * stagF)\r\n          );\r\n        this.options.maxNodes = (this as any)._cbMaxNodes;\r\n        if (cb.maxConnsStart) {\r\n          if ((this as any)._cbMaxConns === undefined)\r\n            (this as any)._cbMaxConns = cb.maxConnsStart;\r\n          if (improvement > 0 || slope > 0)\r\n            (this as any)._cbMaxConns = Math.min(\r\n              cb.maxConnsEnd ?? (this as any)._cbMaxConns * 4,\r\n              Math.floor((this as any)._cbMaxConns * incF * noveltyFactor)\r\n            );\r\n          else if (hist.length === window)\r\n            (this as any)._cbMaxConns = Math.max(\r\n              cb.maxConnsStart,\r\n              Math.floor((this as any)._cbMaxConns * stagF)\r\n            );\r\n          this.options.maxConns = (this as any)._cbMaxConns;\r\n        }\r\n      } else {\r\n        // linear schedule\r\n        const maxStart = cb.maxNodesStart ?? this.input + this.output + 2;\r\n        const maxEnd = cb.maxNodesEnd ?? maxStart * 4;\r\n        const horizon = cb.horizon ?? 100;\r\n        const t = Math.min(1, this.generation / horizon);\r\n        this.options.maxNodes = Math.floor(maxStart + (maxEnd - maxStart) * t);\r\n      }\r\n    }\r\n    // Phase switching\r\n    if (this.options.phasedComplexity?.enabled) {\r\n      const len = this.options.phasedComplexity.phaseLength ?? 10;\r\n      if (!this._phase) {\r\n        this._phase = 'complexify';\r\n        this._phaseStartGeneration = this.generation;\r\n      }\r\n      if (this.generation - this._phaseStartGeneration >= len) {\r\n        this._phase = this._phase === 'complexify' ? 'simplify' : 'complexify';\r\n        this._phaseStartGeneration = this.generation;\r\n      }\r\n    }\r\n    this.sort();\r\n    // Multi-objective extensible dominance sorting\r\n    if (this.options.multiObjective?.enabled) {\r\n      const pop = this.population;\r\n      const fronts = this._fastNonDominated(pop);\r\n      // Compute crowding distance per front across dynamic objectives\r\n      const objs = this._getObjectives();\r\n      const crowd: number[] = new Array(pop.length).fill(0);\r\n      // Precompute objective values matrix [objective][genomeIndex] to avoid repeated accessor calls\r\n      const objVals = objs.map((o) => pop.map((g) => o.accessor(g)));\r\n      for (const front of fronts) {\r\n        if (front.length < 3) {\r\n          front.forEach((i) => (crowd[i] = Infinity));\r\n          continue;\r\n        }\r\n        for (let oi = 0; oi < objs.length; oi++) {\r\n          const sorted = [...front].sort(\r\n            (a, b) => objVals[oi][a] - objVals[oi][b]\r\n          );\r\n          crowd[sorted[0]] = Infinity;\r\n          crowd[sorted[sorted.length - 1]] = Infinity;\r\n          const minV = objVals[oi][sorted[0]];\r\n          const maxV = objVals[oi][sorted[sorted.length - 1]];\r\n          for (let k = 1; k < sorted.length - 1; k++) {\r\n            const prev = objVals[oi][sorted[k - 1]];\r\n            const next = objVals[oi][sorted[k + 1]];\r\n            const denom = maxV - minV || 1;\r\n            crowd[sorted[k]] += (next - prev) / denom;\r\n          }\r\n        }\r\n      }\r\n      // Stable sort using stored ranks and crowding\r\n      const idxMap = new Map<Network, number>();\r\n      for (let i = 0; i < pop.length; i++) idxMap.set(pop[i], i);\r\n      this.population.sort((a, b) => {\r\n        const ra = (a as any)._moRank ?? 0;\r\n        const rb = (b as any)._moRank ?? 0;\r\n        if (ra !== rb) return ra - rb;\r\n        const ia = idxMap.get(a)!;\r\n        const ib = idxMap.get(b)!;\r\n        return crowd[ib] - crowd[ia];\r\n      });\r\n      for (let i = 0; i < pop.length; i++) (pop[i] as any)._moCrowd = crowd[i];\r\n      // Persist first-front archive snapshot\r\n      if (fronts.length) {\r\n        const first = fronts[0];\r\n        const snapshot = first.map((i) => ({\r\n          id: (pop[i] as any)._id ?? -1,\r\n          score: pop[i].score || 0,\r\n          nodes: pop[i].nodes.length,\r\n          connections: pop[i].connections.length,\r\n        }));\r\n        this._paretoArchive.push({\r\n          gen: this.generation,\r\n          size: first.length,\r\n          genomes: snapshot,\r\n        });\r\n        if (this._paretoArchive.length > 200) this._paretoArchive.shift();\r\n        // store objective vectors if requested\r\n        if (objs.length) {\r\n          const vectors = first.map((i) => ({\r\n            id: (pop[i] as any)._id ?? -1,\r\n            values: objs.map((o) => o.accessor(pop[i])),\r\n          }));\r\n          this._paretoObjectivesArchive.push({ gen: this.generation, vectors });\r\n          if (this._paretoObjectivesArchive.length > 200)\r\n            this._paretoObjectivesArchive.shift();\r\n        }\r\n      }\r\n      // Adaptive dominance epsilon tuning\r\n      if (\r\n        this.options.multiObjective?.adaptiveEpsilon?.enabled &&\r\n        fronts.length\r\n      ) {\r\n        const cfg = this.options.multiObjective.adaptiveEpsilon;\r\n        const target =\r\n          cfg.targetFront ??\r\n          Math.max(3, Math.floor(Math.sqrt(this.population.length)));\r\n        const adjust = cfg.adjust ?? 0.002;\r\n        const minE = cfg.min ?? 0;\r\n        const maxE = cfg.max ?? 0.5;\r\n        const cooldown = cfg.cooldown ?? 2;\r\n        if (this.generation - this._lastEpsilonAdjustGen >= cooldown) {\r\n          const currentSize = fronts[0].length;\r\n          let eps = this.options.multiObjective!.dominanceEpsilon || 0;\r\n          if (currentSize > target * 1.2) eps = Math.min(maxE, eps + adjust);\r\n          else if (currentSize < target * 0.8)\r\n            eps = Math.max(minE, eps - adjust);\r\n          this.options.multiObjective!.dominanceEpsilon = eps;\r\n          this._lastEpsilonAdjustGen = this.generation;\r\n        }\r\n      }\r\n      // Inactive objective pruning (range collapse) after adaptive epsilon\r\n      if (this.options.multiObjective?.pruneInactive?.enabled) {\r\n        const cfg = this.options.multiObjective.pruneInactive;\r\n        const window = cfg.window ?? 5;\r\n        const rangeEps = cfg.rangeEps ?? 1e-6;\r\n        const protect = new Set([\r\n          'fitness',\r\n          'complexity',\r\n          ...(cfg.protect || []),\r\n        ]);\r\n        const objsList = this._getObjectives();\r\n        // Compute per-objective min/max\r\n        const ranges: Record<string, { min: number; max: number }> = {};\r\n        for (const o of objsList) {\r\n          let min = Infinity,\r\n            max = -Infinity;\r\n          for (const g of this.population) {\r\n            const v = o.accessor(g);\r\n            if (v < min) min = v;\r\n            if (v > max) max = v;\r\n          }\r\n          ranges[o.key] = { min, max };\r\n        }\r\n        const toRemove: string[] = [];\r\n        for (const o of objsList) {\r\n          if (protect.has(o.key)) continue;\r\n          const r = ranges[o.key];\r\n          const span = r.max - r.min;\r\n          if (span < rangeEps) {\r\n            const c = (this._objectiveStale.get(o.key) || 0) + 1;\r\n            this._objectiveStale.set(o.key, c);\r\n            if (c >= window) toRemove.push(o.key);\r\n          } else {\r\n            this._objectiveStale.set(o.key, 0);\r\n          }\r\n        }\r\n        if (toRemove.length && this.options.multiObjective?.objectives) {\r\n          this.options.multiObjective.objectives = this.options.multiObjective.objectives.filter(\r\n            (o) => !toRemove.includes(o.key)\r\n          );\r\n          // Clear cached list so _getObjectives rebuilds without removed objectives\r\n          this._objectivesList = undefined as any;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Ancestor uniqueness adaptive response (after objectives & pruning so we have latest telemetry-related diversity)\r\n    if (this.options.ancestorUniqAdaptive?.enabled && this._diversityStats) {\r\n      const cfg = this.options.ancestorUniqAdaptive;\r\n      const cooldown = cfg.cooldown ?? 5;\r\n      if (this.generation - this._lastAncestorUniqAdjustGen >= cooldown) {\r\n        const lineageBlock = this._telemetry[this._telemetry.length - 1]\r\n          ?.lineage; // last entry pre-reproduction\r\n        const ancUniq = lineageBlock ? lineageBlock.ancestorUniq : undefined;\r\n        if (typeof ancUniq === 'number') {\r\n          const lowT = cfg.lowThreshold ?? 0.25;\r\n          const highT = cfg.highThreshold ?? 0.55;\r\n          const adj = cfg.adjust ?? 0.01;\r\n          if (\r\n            cfg.mode === 'epsilon' &&\r\n            this.options.multiObjective?.adaptiveEpsilon?.enabled\r\n          ) {\r\n            if (ancUniq < lowT) {\r\n              // low uniqueness -> encourage diversity by increasing epsilon (looser dominance)\r\n              this.options.multiObjective.dominanceEpsilon =\r\n                (this.options.multiObjective.dominanceEpsilon || 0) + adj;\r\n              this._lastAncestorUniqAdjustGen = this.generation;\r\n            } else if (ancUniq > highT) {\r\n              // high uniqueness -> tighten epsilon\r\n              this.options.multiObjective.dominanceEpsilon = Math.max(\r\n                0,\r\n                (this.options.multiObjective.dominanceEpsilon || 0) - adj\r\n              );\r\n              this._lastAncestorUniqAdjustGen = this.generation;\r\n            }\r\n          } else if (cfg.mode === 'lineagePressure') {\r\n            // Adjust lineagePressure strength toward spreading or penalizing deep depending on uniqueness\r\n            if (!this.options.lineagePressure)\r\n              this.options.lineagePressure = {\r\n                enabled: true,\r\n                mode: 'spread',\r\n                strength: 0.01,\r\n              } as any;\r\n            const lpRef = this.options.lineagePressure!;\r\n            if (ancUniq < lowT) {\r\n              lpRef.strength = (lpRef.strength || 0.01) * 1.15;\r\n              lpRef.mode = 'spread';\r\n              this._lastAncestorUniqAdjustGen = this.generation;\r\n            } else if (ancUniq > highT) {\r\n              lpRef.strength = (lpRef.strength || 0.01) * 0.9;\r\n              this._lastAncestorUniqAdjustGen = this.generation;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const fittest = Network.fromJSON(this.population[0].toJSON());\r\n    fittest.score = this.population[0].score;\r\n    // Update diversity stats for telemetry\r\n    this._computeDiversityStats();\r\n    // Objective importance snapshot (range & variance proxy) for telemetry\r\n    let objImportance: any = null;\r\n    try {\r\n      const objsList = this._getObjectives();\r\n      if (objsList.length) {\r\n        objImportance = {};\r\n        const pop = this.population;\r\n        for (const o of objsList) {\r\n          const vals = pop.map((g) => o.accessor(g));\r\n          const min = Math.min(...vals);\r\n          const max = Math.max(...vals);\r\n          const mean = vals.reduce((a, b) => a + b, 0) / vals.length;\r\n          const varV =\r\n            vals.reduce((a, b) => a + (b - mean) * (b - mean), 0) /\r\n            (vals.length || 1);\r\n          objImportance[o.key] = { range: max - min, var: varV };\r\n        }\r\n      }\r\n    } catch {}\r\n    // Telemetry snapshot (pre reproduction) capturing Pareto and diversity proxies\r\n    if (this.options.telemetry?.enabled) {\r\n      const gen = this.generation;\r\n      // Hypervolume proxy: sum over first front (if multi-objective) of (scoreNormalized * (1/complexity))\r\n      let hyper = 0;\r\n      if (this.options.multiObjective?.enabled) {\r\n        const metric =\r\n          this.options.multiObjective.complexityMetric || 'connections';\r\n        const scores = this.population.map((g) => g.score || 0);\r\n        const sMin = Math.min(...scores);\r\n        const sMax = Math.max(...scores);\r\n        const frontSizes: number[] = [];\r\n        for (let r = 0; r < 5; r++) {\r\n          const size = this.population.filter(\r\n            (g) => ((g as any)._moRank ?? 0) === r\r\n          ).length;\r\n          if (!size) break;\r\n          frontSizes.push(size);\r\n        }\r\n        for (const g of this.population) {\r\n          const rank = (g as any)._moRank ?? 0;\r\n          if (rank !== 0) continue;\r\n          const sNorm =\r\n            sMax > sMin ? ((g.score || 0) - sMin) / (sMax - sMin) : 0;\r\n          const comp =\r\n            metric === 'nodes' ? g.nodes.length : g.connections.length;\r\n          hyper += sNorm * (1 / (comp + 1));\r\n        }\r\n        const opStats = Array.from(\r\n          this._operatorStats.entries()\r\n        ).map(([k, s]) => ({ op: k, succ: s.success, att: s.attempts }));\r\n        const entry: any = {\r\n          gen,\r\n          best: fittest.score,\r\n          species: this._species.length,\r\n          hyper,\r\n          fronts: frontSizes,\r\n          diversity: this._diversityStats,\r\n          ops: opStats,\r\n        };\r\n        if (objImportance) entry.objImportance = objImportance;\r\n        if (this._objectiveAges.size)\r\n          entry.objAges = Array.from(this._objectiveAges.entries()).reduce(\r\n            (a, [k, v]) => {\r\n              a[k] = v;\r\n              return a;\r\n            },\r\n            {} as any\r\n          );\r\n        if (\r\n          this._pendingObjectiveAdds.length ||\r\n          this._pendingObjectiveRemoves.length\r\n        ) {\r\n          entry.objEvents = [] as any[];\r\n          for (const k of this._pendingObjectiveAdds)\r\n            entry.objEvents.push({ type: 'add', key: k });\r\n          for (const k of this._pendingObjectiveRemoves)\r\n            entry.objEvents.push({ type: 'remove', key: k });\r\n          this._objectiveEvents.push(\r\n            ...entry.objEvents.map((e: any) => ({\r\n              gen,\r\n              type: e.type,\r\n              key: e.key,\r\n            }))\r\n          );\r\n          this._pendingObjectiveAdds = [];\r\n          this._pendingObjectiveRemoves = [];\r\n        }\r\n        if (this._lastOffspringAlloc)\r\n          entry.speciesAlloc = this._lastOffspringAlloc.slice();\r\n        // Record active objective keys for auditability\r\n        try {\r\n          entry.objectives = this._getObjectives().map((o) => o.key);\r\n        } catch {}\r\n        if ((this.options as any).rngState && this._rngState !== undefined)\r\n          entry.rng = this._rngState;\r\n        if (this._lineageEnabled) {\r\n          const b = this.population[0] as any;\r\n          const depths = this.population.map((g) => (g as any)._depth ?? 0);\r\n          this._lastMeanDepth =\r\n            depths.reduce((a, b) => a + b, 0) / (depths.length || 1);\r\n          // Ancestor uniqueness: measure average Jaccard distance between ancestor sets of sampled genome pairs\r\n          const ancWindow = 4;\r\n          const buildAnc = (g: any): Set<number> => {\r\n            const set = new Set<number>();\r\n            if (!Array.isArray(g._parents)) return set;\r\n            const q: { id: number; depth: number; g: any }[] = [];\r\n            for (const pid of g._parents)\r\n              q.push({\r\n                id: pid,\r\n                depth: 1,\r\n                g: this.population.find((x) => (x as any)._id === pid),\r\n              });\r\n            while (q.length) {\r\n              const cur = q.shift()!;\r\n              if (cur.depth > ancWindow) continue;\r\n              if (cur.id != null) set.add(cur.id);\r\n              if (cur.g && Array.isArray(cur.g._parents))\r\n                for (const pid of cur.g._parents)\r\n                  q.push({\r\n                    id: pid,\r\n                    depth: cur.depth + 1,\r\n                    g: this.population.find((x) => (x as any)._id === pid),\r\n                  });\r\n            }\r\n            return set;\r\n          };\r\n          let pairSamples = 0;\r\n          let jaccSum = 0;\r\n          const samplePairs = Math.min(\r\n            30,\r\n            (this.population.length * (this.population.length - 1)) / 2\r\n          );\r\n          for (let t = 0; t < samplePairs; t++) {\r\n            if (this.population.length < 2) break;\r\n            const i = Math.floor(this._getRNG()() * this.population.length);\r\n            let j = Math.floor(this._getRNG()() * this.population.length);\r\n            if (j === i) j = (j + 1) % this.population.length;\r\n            const A = buildAnc(this.population[i] as any);\r\n            const B = buildAnc(this.population[j] as any);\r\n            if (A.size === 0 && B.size === 0) continue;\r\n            let inter = 0;\r\n            for (const id of A) if (B.has(id)) inter++;\r\n            const union = A.size + B.size - inter || 1;\r\n            const jacc = 1 - inter / union; // convert similarity to distance\r\n            jaccSum += jacc;\r\n            pairSamples++;\r\n          }\r\n          const ancestorUniqueness = pairSamples\r\n            ? +(jaccSum / pairSamples).toFixed(3)\r\n            : 0;\r\n          entry.lineage = {\r\n            parents: Array.isArray(b._parents) ? b._parents.slice() : [],\r\n            depthBest: b._depth ?? 0,\r\n            meanDepth: +this._lastMeanDepth.toFixed(2),\r\n            inbreeding: this._prevInbreedingCount,\r\n            ancestorUniq: ancestorUniqueness,\r\n          };\r\n        }\r\n        if (\r\n          this.options.telemetry?.hypervolume &&\r\n          this.options.multiObjective?.enabled\r\n        )\r\n          entry.hv = +hyper.toFixed(4);\r\n        if (this.options.telemetry?.complexity) {\r\n          const nodesArr = this.population.map((g) => g.nodes.length);\r\n          const connsArr = this.population.map((g) => g.connections.length);\r\n          const meanNodes =\r\n            nodesArr.reduce((a, b) => a + b, 0) / (nodesArr.length || 1);\r\n          const meanConns =\r\n            connsArr.reduce((a, b) => a + b, 0) / (connsArr.length || 1);\r\n          const maxNodes = nodesArr.length ? Math.max(...nodesArr) : 0;\r\n          const maxConns = connsArr.length ? Math.max(...connsArr) : 0;\r\n          const enabledRatios = this.population.map((g) => {\r\n            let en = 0,\r\n              dis = 0;\r\n            for (const c of g.connections) {\r\n              if ((c as any).enabled === false) dis++;\r\n              else en++;\r\n            }\r\n            return en + dis ? en / (en + dis) : 0;\r\n          });\r\n          const meanEnabledRatio =\r\n            enabledRatios.reduce((a, b) => a + b, 0) /\r\n            (enabledRatios.length || 1);\r\n          const growthNodes =\r\n            this._lastMeanNodes !== undefined\r\n              ? meanNodes - this._lastMeanNodes\r\n              : 0;\r\n          const growthConns =\r\n            this._lastMeanConns !== undefined\r\n              ? meanConns - this._lastMeanConns\r\n              : 0;\r\n          this._lastMeanNodes = meanNodes;\r\n          this._lastMeanConns = meanConns;\r\n          entry.complexity = {\r\n            meanNodes: +meanNodes.toFixed(2),\r\n            meanConns: +meanConns.toFixed(2),\r\n            maxNodes,\r\n            maxConns,\r\n            meanEnabledRatio: +meanEnabledRatio.toFixed(3),\r\n            growthNodes: +growthNodes.toFixed(2),\r\n            growthConns: +growthConns.toFixed(2),\r\n            budgetMaxNodes: this.options.maxNodes,\r\n            budgetMaxConns: this.options.maxConns,\r\n          };\r\n        }\r\n        if (this.options.telemetry?.performance)\r\n          entry.perf = {\r\n            evalMs: this._lastEvalDuration,\r\n            evolveMs: this._lastEvolveDuration,\r\n          };\r\n        this._applyTelemetrySelect(entry);\r\n        this._telemetry.push(entry);\r\n        if (\r\n          this.options.telemetryStream?.enabled &&\r\n          this.options.telemetryStream.onEntry\r\n        )\r\n          this.options.telemetryStream.onEntry(entry);\r\n      } else {\r\n        const opStats2 = Array.from(\r\n          this._operatorStats.entries()\r\n        ).map(([k, s]) => ({ op: k, succ: s.success, att: s.attempts }));\r\n        const entry: any = {\r\n          gen,\r\n          best: fittest.score,\r\n          species: this._species.length,\r\n          hyper,\r\n          diversity: this._diversityStats,\r\n          ops: opStats2,\r\n        };\r\n        if (objImportance) entry.objImportance = objImportance;\r\n        if (this._objectiveAges.size)\r\n          entry.objAges = Array.from(this._objectiveAges.entries()).reduce(\r\n            (a, [k, v]) => {\r\n              a[k] = v;\r\n              return a;\r\n            },\r\n            {} as any\r\n          );\r\n        if (\r\n          this._pendingObjectiveAdds.length ||\r\n          this._pendingObjectiveRemoves.length\r\n        ) {\r\n          entry.objEvents = [] as any[];\r\n          for (const k of this._pendingObjectiveAdds)\r\n            entry.objEvents.push({ type: 'add', key: k });\r\n          for (const k of this._pendingObjectiveRemoves)\r\n            entry.objEvents.push({ type: 'remove', key: k });\r\n          this._objectiveEvents.push(\r\n            ...entry.objEvents.map((e: any) => ({\r\n              gen,\r\n              type: e.type,\r\n              key: e.key,\r\n            }))\r\n          );\r\n          this._pendingObjectiveAdds = [];\r\n          this._pendingObjectiveRemoves = [];\r\n        }\r\n        if (this._lastOffspringAlloc)\r\n          entry.speciesAlloc = this._lastOffspringAlloc.slice();\r\n        try {\r\n          entry.objectives = this._getObjectives().map((o) => o.key);\r\n        } catch {}\r\n        if ((this.options as any).rngState && this._rngState !== undefined)\r\n          entry.rng = this._rngState;\r\n        if (this._lineageEnabled) {\r\n          const b = this.population[0] as any;\r\n          const depths = this.population.map((g) => (g as any)._depth ?? 0);\r\n          this._lastMeanDepth =\r\n            depths.reduce((a, b) => a + b, 0) / (depths.length || 1);\r\n          const ancWindow = 4;\r\n          const buildAnc = (g: any): Set<number> => {\r\n            const set = new Set<number>();\r\n            if (!Array.isArray(g._parents)) return set;\r\n            const q: { id: number; depth: number; g: any }[] = [];\r\n            for (const pid of g._parents)\r\n              q.push({\r\n                id: pid,\r\n                depth: 1,\r\n                g: this.population.find((x) => (x as any)._id === pid),\r\n              });\r\n            while (q.length) {\r\n              const cur = q.shift()!;\r\n              if (cur.depth > ancWindow) continue;\r\n              if (cur.id != null) set.add(cur.id);\r\n              if (cur.g && Array.isArray(cur.g._parents))\r\n                for (const pid of cur.g._parents)\r\n                  q.push({\r\n                    id: pid,\r\n                    depth: cur.depth + 1,\r\n                    g: this.population.find((x) => (x as any)._id === pid),\r\n                  });\r\n            }\r\n            return set;\r\n          };\r\n          let pairSamples = 0;\r\n          let jaccSum = 0;\r\n          const samplePairs = Math.min(\r\n            30,\r\n            (this.population.length * (this.population.length - 1)) / 2\r\n          );\r\n          for (let t = 0; t < samplePairs; t++) {\r\n            if (this.population.length < 2) break;\r\n            const i = Math.floor(this._getRNG()() * this.population.length);\r\n            let j = Math.floor(this._getRNG()() * this.population.length);\r\n            if (j === i) j = (j + 1) % this.population.length;\r\n            const A = buildAnc(this.population[i] as any);\r\n            const B = buildAnc(this.population[j] as any);\r\n            if (A.size === 0 && B.size === 0) continue;\r\n            let inter = 0;\r\n            for (const id of A) if (B.has(id)) inter++;\r\n            const union = A.size + B.size - inter || 1;\r\n            const jacc = 1 - inter / union;\r\n            jaccSum += jacc;\r\n            pairSamples++;\r\n          }\r\n          const ancestorUniqueness = pairSamples\r\n            ? +(jaccSum / pairSamples).toFixed(3)\r\n            : 0;\r\n          entry.lineage = {\r\n            parents: Array.isArray(b._parents) ? b._parents.slice() : [],\r\n            depthBest: b._depth ?? 0,\r\n            meanDepth: +this._lastMeanDepth.toFixed(2),\r\n            inbreeding: this._prevInbreedingCount,\r\n            ancestorUniq: ancestorUniqueness,\r\n          };\r\n        }\r\n        if (\r\n          this.options.telemetry?.hypervolume &&\r\n          this.options.multiObjective?.enabled\r\n        )\r\n          entry.hv = +hyper.toFixed(4);\r\n        if (this.options.telemetry?.complexity) {\r\n          const nodesArr = this.population.map((g) => g.nodes.length);\r\n          const connsArr = this.population.map((g) => g.connections.length);\r\n          const meanNodes =\r\n            nodesArr.reduce((a, b) => a + b, 0) / (nodesArr.length || 1);\r\n          const meanConns =\r\n            connsArr.reduce((a, b) => a + b, 0) / (connsArr.length || 1);\r\n          const maxNodes = nodesArr.length ? Math.max(...nodesArr) : 0;\r\n          const maxConns = connsArr.length ? Math.max(...connsArr) : 0;\r\n          const enabledRatios = this.population.map((g) => {\r\n            let en = 0,\r\n              dis = 0;\r\n            for (const c of g.connections) {\r\n              if ((c as any).enabled === false) dis++;\r\n              else en++;\r\n            }\r\n            return en + dis ? en / (en + dis) : 0;\r\n          });\r\n          const meanEnabledRatio =\r\n            enabledRatios.reduce((a, b) => a + b, 0) /\r\n            (enabledRatios.length || 1);\r\n          const growthNodes =\r\n            this._lastMeanNodes !== undefined\r\n              ? meanNodes - this._lastMeanNodes\r\n              : 0;\r\n          const growthConns =\r\n            this._lastMeanConns !== undefined\r\n              ? meanConns - this._lastMeanConns\r\n              : 0;\r\n          this._lastMeanNodes = meanNodes;\r\n          this._lastMeanConns = meanConns;\r\n          entry.complexity = {\r\n            meanNodes: +meanNodes.toFixed(2),\r\n            meanConns: +meanConns.toFixed(2),\r\n            maxNodes,\r\n            maxConns,\r\n            meanEnabledRatio: +meanEnabledRatio.toFixed(3),\r\n            growthNodes: +growthNodes.toFixed(2),\r\n            growthConns: +growthConns.toFixed(2),\r\n            budgetMaxNodes: this.options.maxNodes,\r\n            budgetMaxConns: this.options.maxConns,\r\n          };\r\n        }\r\n        if (this.options.telemetry?.performance)\r\n          entry.perf = {\r\n            evalMs: this._lastEvalDuration,\r\n            evolveMs: this._lastEvolveDuration,\r\n          };\r\n        this._applyTelemetrySelect(entry);\r\n        this._telemetry.push(entry);\r\n        if (\r\n          this.options.telemetryStream?.enabled &&\r\n          this.options.telemetryStream.onEntry\r\n        )\r\n          this.options.telemetryStream.onEntry(entry);\r\n      }\r\n      if (this._telemetry.length > 500) this._telemetry.shift();\r\n    }\r\n    // Track global improvement\r\n    if ((fittest.score ?? -Infinity) > this._bestGlobalScore) {\r\n      this._bestGlobalScore = fittest.score ?? -Infinity;\r\n      this._lastGlobalImproveGeneration = this.generation;\r\n    }\r\n\r\n    const newPopulation: Network[] = [];\r\n\r\n    // Elitism (clamped to available population)\r\n    const elitismCount = Math.max(\r\n      0,\r\n      Math.min(this.options.elitism || 0, this.population.length)\r\n    );\r\n    for (let i = 0; i < elitismCount; i++) {\r\n      const elite = this.population[i];\r\n      if (elite) newPopulation.push(elite);\r\n    }\r\n\r\n    // Provenance (clamp so total does not exceed desired popsize)\r\n    const desiredPop = Math.max(0, this.options.popsize || 0);\r\n    const remainingSlotsAfterElites = Math.max(\r\n      0,\r\n      desiredPop - newPopulation.length\r\n    );\r\n    const provenanceCount = Math.max(\r\n      0,\r\n      Math.min(this.options.provenance || 0, remainingSlotsAfterElites)\r\n    );\r\n    for (let i = 0; i < provenanceCount; i++) {\r\n      if (this.options.network) {\r\n        newPopulation.push(Network.fromJSON(this.options.network.toJSON()));\r\n      } else {\r\n        newPopulation.push(\r\n          new Network(this.input, this.output, {\r\n            minHidden: this.options.minHidden,\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    // Breed the next individuals (fill up to desired popsize)\r\n    if (this.options.speciation && this._species.length > 0) {\r\n      const remaining = desiredPop - newPopulation.length;\r\n      if (remaining > 0) {\r\n        // Allocate offspring per species with age bonuses/penalties\r\n        const ageCfg = this.options.speciesAgeBonus || {};\r\n        const youngT = ageCfg.youngThreshold ?? 5;\r\n        const youngM = ageCfg.youngMultiplier ?? 1.3;\r\n        const oldT = ageCfg.oldThreshold ?? 30;\r\n        const oldM = ageCfg.oldMultiplier ?? 0.7;\r\n        const speciesAdjusted = this._species.map((sp) => {\r\n          const base = sp.members.reduce((a, m) => a + (m.score || 0), 0);\r\n          const age = this.generation - sp.lastImproved;\r\n          if (age <= youngT) return base * youngM;\r\n          if (age >= oldT) return base * oldM;\r\n          return base;\r\n        });\r\n        const totalAdj = speciesAdjusted.reduce((a, b) => a + b, 0) || 1;\r\n        const minOff = this.options.speciesAllocation?.minOffspring ?? 1;\r\n        const rawShares = this._species.map(\r\n          (_, idx) => (speciesAdjusted[idx] / totalAdj) * remaining\r\n        );\r\n        const offspringAlloc: number[] = rawShares.map((s) => Math.floor(s));\r\n        // Enforce minimum for species that have any members surviving\r\n        for (let i = 0; i < offspringAlloc.length; i++)\r\n          if (\r\n            offspringAlloc[i] < minOff &&\r\n            remaining >= this._species.length * minOff\r\n          )\r\n            offspringAlloc[i] = minOff;\r\n        let allocated = offspringAlloc.reduce((a, b) => a + b, 0);\r\n        let slotsLeft = remaining - allocated;\r\n        // Distribute leftovers by largest fractional remainder\r\n        const remainders = rawShares.map((s, i) => ({\r\n          i,\r\n          frac: s - Math.floor(s),\r\n        }));\r\n        remainders.sort((a, b) => b.frac - a.frac);\r\n        for (const r of remainders) {\r\n          if (slotsLeft <= 0) break;\r\n          offspringAlloc[r.i]++;\r\n          slotsLeft--;\r\n        }\r\n        // If we overshot (edge case via minOff), trim from largest allocations\r\n        if (slotsLeft < 0) {\r\n          const order = offspringAlloc\r\n            .map((v, i) => ({ i, v }))\r\n            .sort((a, b) => b.v - a.v);\r\n          for (const o of order) {\r\n            if (slotsLeft === 0) break;\r\n            if (offspringAlloc[o.i] > minOff) {\r\n              offspringAlloc[o.i]--;\r\n              slotsLeft++;\r\n            }\r\n          }\r\n        }\r\n        // Record allocation for telemetry (applied next generation's telemetry snapshot)\r\n        this._lastOffspringAlloc = this._species.map((sp, i) => ({\r\n          id: sp.id,\r\n          alloc: offspringAlloc[i] || 0,\r\n        }));\r\n        // Breed within species\r\n        this._prevInbreedingCount = this._lastInbreedingCount; // snapshot for telemetry next generation\r\n        this._lastInbreedingCount = 0;\r\n        offspringAlloc.forEach((count, idx) => {\r\n          if (count <= 0) return;\r\n          const sp = this._species[idx];\r\n          this._sortSpeciesMembers(sp);\r\n          const survivors = sp.members.slice(\r\n            0,\r\n            Math.max(\r\n              1,\r\n              Math.floor(\r\n                sp.members.length * (this.options!.survivalThreshold || 0.5)\r\n              )\r\n            )\r\n          );\r\n          for (let k = 0; k < count; k++) {\r\n            const p1 =\r\n              survivors[Math.floor(this._getRNG()() * survivors.length)];\r\n            let p2: Network;\r\n            if (\r\n              this.options.crossSpeciesMatingProb &&\r\n              this._species.length > 1 &&\r\n              this._getRNG()() < (this.options.crossSpeciesMatingProb || 0)\r\n            ) {\r\n              // Choose different species randomly\r\n              let otherIdx = idx;\r\n              let guard = 0;\r\n              while (otherIdx === idx && guard++ < 5)\r\n                otherIdx = Math.floor(this._getRNG()() * this._species.length);\r\n              const otherSp = this._species[otherIdx];\r\n              this._sortSpeciesMembers(otherSp);\r\n              const otherParents = otherSp.members.slice(\r\n                0,\r\n                Math.max(\r\n                  1,\r\n                  Math.floor(\r\n                    otherSp.members.length *\r\n                      (this.options!.survivalThreshold || 0.5)\r\n                  )\r\n                )\r\n              );\r\n              p2 =\r\n                otherParents[\r\n                  Math.floor(this._getRNG()() * otherParents.length)\r\n                ];\r\n            } else {\r\n              p2 = survivors[Math.floor(this._getRNG()() * survivors.length)];\r\n            }\r\n            const child = Network.crossOver(\r\n              p1,\r\n              p2,\r\n              this.options.equal || false\r\n            );\r\n            (child as any)._reenableProb = this.options.reenableProb;\r\n            (child as any)._id = this._nextGenomeId++;\r\n            if (this._lineageEnabled) {\r\n              (child as any)._parents = [(p1 as any)._id, (p2 as any)._id];\r\n              const d1 = (p1 as any)._depth ?? 0;\r\n              const d2 = (p2 as any)._depth ?? 0;\r\n              (child as any)._depth = 1 + Math.max(d1, d2);\r\n              if ((p1 as any)._id === (p2 as any)._id)\r\n                this._lastInbreedingCount++;\r\n            }\r\n            newPopulation.push(child);\r\n          }\r\n        });\r\n      }\r\n    } else {\r\n      const toBreed = Math.max(0, desiredPop - newPopulation.length);\r\n      for (let i = 0; i < toBreed; i++) newPopulation.push(this.getOffspring());\r\n    }\r\n\r\n    // Ensure minimum hidden nodes to avoid bottlenecks\r\n    for (const genome of newPopulation) {\r\n      if (!genome) continue;\r\n      this.ensureMinHiddenNodes(genome);\r\n      this.ensureNoDeadEnds(genome); // Ensure no dead ends or blind I/O\r\n    }\r\n\r\n    this.population = newPopulation; // Replace population instead of appending\r\n    // --- Evolution-time pruning (structural sparsification) ---\r\n    const evoPrune = this.options.evolutionPruning;\r\n    if (evoPrune && this.generation >= (evoPrune.startGeneration || 0)) {\r\n      const interval = evoPrune.interval || 1;\r\n      if ((this.generation - evoPrune.startGeneration) % interval === 0) {\r\n        const ramp = evoPrune.rampGenerations || 0;\r\n        let frac = 1;\r\n        if (ramp > 0) {\r\n          const t = Math.min(\r\n            1,\r\n            Math.max(0, (this.generation - evoPrune.startGeneration) / ramp)\r\n          );\r\n          frac = t;\r\n        }\r\n        const targetNow = (evoPrune.targetSparsity || 0) * frac;\r\n        for (const genome of this.population) {\r\n          if (genome && typeof genome.pruneToSparsity === 'function') {\r\n            (genome as any).pruneToSparsity(\r\n              targetNow,\r\n              evoPrune.method || 'magnitude'\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Adaptive pruning: adjust sparsity toward target based on complexity metric\r\n    if (this.options.adaptivePruning?.enabled) {\r\n      const ap = this.options.adaptivePruning;\r\n      if (this._adaptivePruneLevel === undefined) this._adaptivePruneLevel = 0;\r\n      const metric = ap.metric || 'connections';\r\n      const meanNodes =\r\n        this.population.reduce((a, g) => a + g.nodes.length, 0) /\r\n        (this.population.length || 1);\r\n      const meanConns =\r\n        this.population.reduce((a, g) => a + g.connections.length, 0) /\r\n        (this.population.length || 1);\r\n      const current = metric === 'nodes' ? meanNodes : meanConns;\r\n      // Define baseline as initial average captured first call\r\n      if ((this as any)._adaptivePruneBaseline === undefined)\r\n        (this as any)._adaptivePruneBaseline = current;\r\n      const base = (this as any)._adaptivePruneBaseline;\r\n      const desiredSparsity = ap.targetSparsity ?? 0.5; // fraction of baseline to remove\r\n      const targetRemaining = base * (1 - desiredSparsity);\r\n      const tol = ap.tolerance ?? 0.05;\r\n      const rate = ap.adjustRate ?? 0.02;\r\n      const diff = (current - targetRemaining) / (base || 1); // positive => above target complexity\r\n      if (Math.abs(diff) > tol) {\r\n        this._adaptivePruneLevel = Math.max(\r\n          0,\r\n          Math.min(\r\n            desiredSparsity,\r\n            this._adaptivePruneLevel + rate * (diff > 0 ? 1 : -1)\r\n          )\r\n        );\r\n        for (const g of this.population)\r\n          if (typeof (g as any).pruneToSparsity === 'function')\r\n            (g as any).pruneToSparsity(this._adaptivePruneLevel, 'magnitude');\r\n      }\r\n    }\r\n    this.mutate();\r\n    // Adapt per-genome mutation parameters for next generation (self-adaptive rates)\r\n    if (this.options.adaptiveMutation?.enabled) {\r\n      const am = this.options.adaptiveMutation;\r\n      const every = am.adaptEvery ?? 1;\r\n      if (every <= 1 || this.generation % every === 0) {\r\n        // Collect scores for percentile-based strategies\r\n        const scored = this.population.filter(\r\n          (g) => typeof g.score === 'number'\r\n        );\r\n        scored.sort((a, b) => (a.score || 0) - (b.score || 0));\r\n        const mid = Math.floor(scored.length / 2);\r\n        const topHalf = scored.slice(mid);\r\n        const bottomHalf = scored.slice(0, mid);\r\n        const sigmaBase = (am.sigma ?? 0.05) * 1.5; // amplify for clearer divergence\r\n        const minR = am.minRate ?? 0.01;\r\n        const maxR = am.maxRate ?? 1;\r\n        const strategy = am.strategy || 'twoTier';\r\n        let anyUp = false,\r\n          anyDown = false;\r\n        for (let idx = 0; idx < this.population.length; idx++) {\r\n          const g = this.population[idx];\r\n          if ((g as any)._mutRate === undefined) continue;\r\n          let rate = (g as any)._mutRate;\r\n          let delta = (this._getRNG()() * 2 - 1) * sigmaBase; // default random walk\r\n          if (strategy === 'twoTier') {\r\n            if (topHalf.length === 0 || bottomHalf.length === 0) {\r\n              // Fallback: alternate directions by index parity to guarantee variance\r\n              delta = idx % 2 === 0 ? Math.abs(delta) : -Math.abs(delta);\r\n            } else if (topHalf.includes(g)) delta = -Math.abs(delta);\r\n            else if (bottomHalf.includes(g)) delta = Math.abs(delta);\r\n          } else if (strategy === 'exploreLow') {\r\n            if (bottomHalf.includes(g)) delta = Math.abs(delta * 1.5);\r\n            else delta = -Math.abs(delta * 0.5);\r\n          } else if (strategy === 'anneal') {\r\n            const progress = Math.min(\r\n              1,\r\n              this.generation / (50 + this.population.length)\r\n            );\r\n            delta *= 1 - progress; // gradually reduce\r\n          }\r\n          rate += delta;\r\n          if (rate < minR) rate = minR;\r\n          if (rate > maxR) rate = maxR;\r\n          if (rate > (this.options.adaptiveMutation!.initialRate ?? 0.5))\r\n            anyUp = true;\r\n          if (rate < (this.options.adaptiveMutation!.initialRate ?? 0.5))\r\n            anyDown = true;\r\n          (g as any)._mutRate = rate;\r\n          if (am.adaptAmount) {\r\n            const aSigma = am.amountSigma ?? 0.25;\r\n            let aDelta = (this._getRNG()() * 2 - 1) * aSigma;\r\n            if (strategy === 'twoTier') {\r\n              if (topHalf.length === 0 || bottomHalf.length === 0)\r\n                aDelta = idx % 2 === 0 ? Math.abs(aDelta) : -Math.abs(aDelta);\r\n              else\r\n                aDelta = bottomHalf.includes(g)\r\n                  ? Math.abs(aDelta)\r\n                  : -Math.abs(aDelta);\r\n            }\r\n            let amt =\r\n              (g as any)._mutAmount ?? (this.options.mutationAmount || 1);\r\n            amt += aDelta;\r\n            amt = Math.round(amt);\r\n            const minA = am.minAmount ?? 1;\r\n            const maxA = am.maxAmount ?? 10;\r\n            if (amt < minA) amt = minA;\r\n            if (amt > maxA) amt = maxA;\r\n            (g as any)._mutAmount = amt;\r\n          }\r\n        }\r\n        // If still no divergence (rare), forcibly perturb half\r\n        if (strategy === 'twoTier' && !(anyUp && anyDown)) {\r\n          const baseline = this.options.adaptiveMutation!.initialRate ?? 0.5;\r\n          const half = Math.floor(this.population.length / 2);\r\n          for (let i = 0; i < this.population.length; i++) {\r\n            const g = this.population[i];\r\n            if ((g as any)._mutRate === undefined) continue;\r\n            if (i < half)\r\n              (g as any)._mutRate = Math.min(\r\n                (g as any)._mutRate + sigmaBase,\r\n                1\r\n              );\r\n            else\r\n              (g as any)._mutRate = Math.max(\r\n                (g as any)._mutRate - sigmaBase,\r\n                0.01\r\n              );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Invalidate compatibility caches after structural mutations\r\n    this.population.forEach((g: any) => {\r\n      if (g._compatCache) delete g._compatCache;\r\n    });\r\n\r\n    this.population.forEach((genome) => (genome.score = undefined));\r\n\r\n    this.generation++;\r\n    if (this.options.speciation) this._updateSpeciesStagnation();\r\n    // Global stagnation injection (refresh portion of worst genomes) if enabled\r\n    if (\r\n      (this.options.globalStagnationGenerations || 0) > 0 &&\r\n      this.generation - this._lastGlobalImproveGeneration >=\r\n        (this.options.globalStagnationGenerations || 0)\r\n    ) {\r\n      // Replace worst 20% (excluding elites if elitism >0)\r\n      const replaceFraction = 0.2;\r\n      const startIdx = Math.max(\r\n        this.options.elitism || 0,\r\n        Math.floor(this.population.length * (1 - replaceFraction))\r\n      );\r\n      for (let i = startIdx; i < this.population.length; i++) {\r\n        this.population[i] = new Network(this.input, this.output, {\r\n          minHidden: this.options.minHidden,\r\n        });\r\n        (this.population[i] as any)._reenableProb = this.options.reenableProb;\r\n      }\r\n      this._lastGlobalImproveGeneration = this.generation; // reset window after injection\r\n    }\r\n    // Adaptive re-enable probability tuning\r\n    if (this.options.reenableProb !== undefined) {\r\n      let succ = 0,\r\n        att = 0;\r\n      for (const g of this.population) {\r\n        succ += (g as any)._reenableSuccess || 0;\r\n        att += (g as any)._reenableAttempts || 0;\r\n        (g as any)._reenableSuccess = 0;\r\n        (g as any)._reenableAttempts = 0;\r\n      }\r\n      if (att > 20) {\r\n        // only adjust with enough samples\r\n        const ratio = succ / att;\r\n        // target moderate reuse ~0.3\r\n        const target = 0.3;\r\n        const delta = ratio - target;\r\n        this.options.reenableProb = Math.min(\r\n          0.9,\r\n          Math.max(0.05, this.options.reenableProb - delta * 0.1)\r\n        );\r\n      }\r\n    }\r\n    // Decay operator stats (EMA-like) to keep adaptation responsive\r\n    if (this.options.operatorAdaptation?.enabled) {\r\n      const decay = this.options.operatorAdaptation.decay ?? 0.9;\r\n      for (const [k, stat] of this._operatorStats.entries()) {\r\n        stat.success *= decay;\r\n        stat.attempts *= decay; // float counts\r\n        this._operatorStats.set(k, stat);\r\n      }\r\n    }\r\n\r\n    const __e1 =\r\n      typeof performance !== 'undefined' && (performance as any).now\r\n        ? (performance as any).now()\r\n        : Date.now();\r\n    this._lastEvolveDuration = __e1 - __e0;\r\n    return fittest;\r\n  }\r\n\r\n  /** Warn that evolution ended without a valid best genome. Always emits when called (tests rely on this). */\r\n  _warnIfNoBestGenome() {\r\n    try {\r\n      if (typeof console !== 'undefined' && console.warn) {\r\n        console.warn('Evolution completed without finding a valid best genome');\r\n      }\r\n    } catch {}\r\n  }\r\n\r\n  /**\r\n   * Creates the initial population of networks.\r\n   * If a base network is provided, clones it to create the population.\r\n   * @param network - The base network to clone, or null to create new networks.\r\n   */\r\n  createPool(network: Network | null): void {\r\n    this.population = [];\r\n    for (let i = 0; i < (this.options.popsize || 50); i++) {\r\n      const copy = network\r\n        ? Network.fromJSON(network.toJSON())\r\n        : new Network(this.input, this.output, {\r\n            minHidden: this.options.minHidden,\r\n          });\r\n      copy.score = undefined;\r\n      this.ensureNoDeadEnds(copy); // Ensure no dead ends or blind I/O\r\n      (copy as any)._reenableProb = this.options.reenableProb;\r\n      // Ensure at least one initial forward connection to allow ADD_NODE split innovations\r\n      if (copy.connections.length === 0) {\r\n        const inputNode = copy.nodes.find((n) => n.type === 'input');\r\n        const outputNode = copy.nodes.find((n) => n.type === 'output');\r\n        if (inputNode && outputNode) {\r\n          try {\r\n            copy.connect(inputNode, outputNode);\r\n          } catch {}\r\n        }\r\n      }\r\n      (copy as any)._id = this._nextGenomeId++;\r\n      if (this._lineageEnabled) {\r\n        (copy as any)._parents = [];\r\n        (copy as any)._depth = 0;\r\n      }\r\n      this.population.push(copy);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates an offspring by crossing over two parent networks.\r\n   * Uses the crossover method described in the Instinct algorithm.\r\n   * @returns A new network created from two parents.\r\n   * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6 Instinct: neuro-evolution on steroids by Thomas Wagenaar}\r\n   */\r\n  getOffspring(): Network {\r\n    const parent1 = this.getParent();\r\n    const parent2 = this.getParent();\r\n    const offspring = Network.crossOver(\r\n      parent1,\r\n      parent2,\r\n      this.options.equal || false\r\n    );\r\n    (offspring as any)._reenableProb = this.options.reenableProb;\r\n    (offspring as any)._id = this._nextGenomeId++;\r\n    if (this._lineageEnabled) {\r\n      (offspring as any)._parents = [\r\n        (parent1 as any)._id,\r\n        (parent2 as any)._id,\r\n      ];\r\n      const d1 = (parent1 as any)._depth ?? 0;\r\n      const d2 = (parent2 as any)._depth ?? 0;\r\n      (offspring as any)._depth = 1 + Math.max(d1, d2);\r\n      if ((parent1 as any)._id === (parent2 as any)._id)\r\n        this._lastInbreedingCount++;\r\n    }\r\n    // Ensure the offspring has the minimum required hidden nodes\r\n    this.ensureMinHiddenNodes(offspring);\r\n    this.ensureNoDeadEnds(offspring); // Ensure no dead ends or blind I/O\r\n    return offspring;\r\n  }\r\n\r\n  /**\r\n   * Selects a mutation method for a given genome based on constraints.\r\n   * Ensures that the mutation respects the maximum nodes, connections, and gates.\r\n   * @param genome - The genome to mutate.\r\n   * @returns The selected mutation method or null if no valid method is available.\r\n   */\r\n  selectMutationMethod(genome: Network, rawReturnForTest: boolean = true): any {\r\n    // If user specified FFW (either direct or nested) and test wants raw array identity\r\n    const isFFWDirect = this.options.mutation === methods.mutation.FFW;\r\n    const isFFWNested =\r\n      Array.isArray(this.options.mutation) &&\r\n      this.options.mutation.length === 1 &&\r\n      this.options.mutation[0] === methods.mutation.FFW;\r\n    if ((isFFWDirect || isFFWNested) && rawReturnForTest)\r\n      return methods.mutation.FFW; // test path expects identity\r\n    if (isFFWDirect)\r\n      return methods.mutation.FFW[\r\n        Math.floor(this._getRNG()() * methods.mutation.FFW.length)\r\n      ];\r\n    if (isFFWNested)\r\n      return methods.mutation.FFW[\r\n        Math.floor(this._getRNG()() * methods.mutation.FFW.length)\r\n      ];\r\n    let pool = this.options.mutation!;\r\n    // After mutation sanitation, options.mutation may now be a sanitized copy; retain array identity check for tests\r\n    if (\r\n      rawReturnForTest &&\r\n      Array.isArray(pool) &&\r\n      pool.length === methods.mutation.FFW.length &&\r\n      pool.every(\r\n        (m: any, i: number) => m && m.name === methods.mutation.FFW[i].name\r\n      )\r\n    ) {\r\n      return methods.mutation.FFW;\r\n    }\r\n    if (pool.length === 1 && Array.isArray(pool[0]) && pool[0].length)\r\n      pool = pool[0];\r\n    // Phase bias: during simplify phase, bias towards SUB_* operations; during complexify, bias towards ADD_*\r\n    if (this.options.phasedComplexity?.enabled && this._phase) {\r\n      // Filter out null/undefined entries defensively (e2e example surfaced undefined in pool)\r\n      pool = pool.filter((m: any) => !!m);\r\n      if (this._phase === 'simplify') {\r\n        const simplifyPool = pool.filter(\r\n          (m: any) =>\r\n            m && m.name && m.name.startsWith && m.name.startsWith('SUB_')\r\n        );\r\n        if (simplifyPool.length) pool = [...pool, ...simplifyPool];\r\n      } else if (this._phase === 'complexify') {\r\n        const addPool = pool.filter(\r\n          (m: any) =>\r\n            m && m.name && m.name.startsWith && m.name.startsWith('ADD_')\r\n        );\r\n        if (addPool.length) pool = [...pool, ...addPool];\r\n      }\r\n    }\r\n    // Operator adaptation weighting: duplicate high-success operators\r\n    if (this.options.operatorAdaptation?.enabled) {\r\n      const boost = this.options.operatorAdaptation.boost ?? 2;\r\n      const stats = this._operatorStats;\r\n      const augmented: any[] = [];\r\n      for (const m of pool) {\r\n        augmented.push(m);\r\n        const st = stats.get(m.name);\r\n        if (st && st.attempts > 5) {\r\n          const ratio = st.success / st.attempts;\r\n          if (ratio > 0.55) {\r\n            for (let i = 0; i < Math.min(boost, Math.floor(ratio * boost)); i++)\r\n              augmented.push(m);\r\n          }\r\n        }\r\n      }\r\n      pool = augmented;\r\n    }\r\n    let mutationMethod = pool[Math.floor(this._getRNG()() * pool.length)];\r\n\r\n    // Gate addition constraint check early so bandit doesn't reselect invalid ADD_GATE\r\n    if (\r\n      mutationMethod === methods.mutation.ADD_GATE &&\r\n      genome.gates.length >= (this.options.maxGates || Infinity)\r\n    ) {\r\n      return null;\r\n    }\r\n\r\n    if (\r\n      mutationMethod === methods.mutation.ADD_NODE &&\r\n      genome.nodes.length >= (this.options.maxNodes || Infinity)\r\n    ) {\r\n      return null;\r\n    }\r\n\r\n    if (\r\n      mutationMethod === methods.mutation.ADD_CONN &&\r\n      genome.connections.length >= (this.options.maxConns || Infinity)\r\n    ) {\r\n      return null;\r\n    }\r\n\r\n    // Multi-armed bandit UCB selection adjustment (post filtering) - replace chosen method with best UCB candidate\r\n    if (this.options.operatorBandit?.enabled) {\r\n      const c = this.options.operatorBandit.c ?? 1.4;\r\n      const minA = this.options.operatorBandit.minAttempts ?? 5;\r\n      const stats = this._operatorStats;\r\n      // Ensure stats entries exist\r\n      for (const m of pool)\r\n        if (!stats.has(m.name)) stats.set(m.name, { success: 0, attempts: 0 });\r\n      const totalAttempts =\r\n        Array.from(stats.values()).reduce((a, s) => a + s.attempts, 0) + 1e-9;\r\n      let best = mutationMethod;\r\n      let bestVal = -Infinity;\r\n      for (const m of pool) {\r\n        const st = stats.get(m.name)!;\r\n        const mean = st.attempts > 0 ? st.success / st.attempts : 0;\r\n        const bonus =\r\n          st.attempts < minA\r\n            ? Infinity\r\n            : c * Math.sqrt(Math.log(totalAttempts) / (st.attempts + 1e-9));\r\n        const val = mean + bonus;\r\n        if (val > bestVal) {\r\n          bestVal = val;\r\n          best = m;\r\n        }\r\n      }\r\n      // Use bandit-selected method\r\n      mutationMethod = best;\r\n    }\r\n\r\n    // Re-check ADD_GATE constraint after bandit selection\r\n    if (\r\n      mutationMethod === methods.mutation.ADD_GATE &&\r\n      genome.gates.length >= (this.options.maxGates || Infinity)\r\n    )\r\n      return null;\r\n\r\n    if (\r\n      !this.options.allowRecurrent &&\r\n      (mutationMethod === methods.mutation.ADD_BACK_CONN ||\r\n        mutationMethod === methods.mutation.ADD_SELF_CONN)\r\n    ) {\r\n      return null; // Skip recurrent mutations if not allowed\r\n    }\r\n\r\n    return mutationMethod;\r\n  }\r\n\r\n  /**\r\n   * Applies mutations to the population based on the mutation rate and amount.\r\n   * Each genome is mutated using the selected mutation methods.\r\n   * Slightly increases the chance of ADD_CONN mutation for more connectivity.\r\n   */\r\n  mutate(): void {\r\n    for (const genome of this.population) {\r\n      // Initialize adaptive parameters lazily\r\n      if (this.options.adaptiveMutation?.enabled) {\r\n        if ((genome as any)._mutRate === undefined) {\r\n          (genome as any)._mutRate =\r\n            this.options.mutationRate !== undefined\r\n              ? this.options.mutationRate\r\n              : this.options.adaptiveMutation.initialRate ??\r\n                (this.options.mutationRate || 0.7);\r\n          if (this.options.adaptiveMutation.adaptAmount)\r\n            (genome as any)._mutAmount = this.options.mutationAmount || 1;\r\n        }\r\n      }\r\n      const effectiveRate =\r\n        this.options.mutationRate !== undefined\r\n          ? this.options.mutationRate\r\n          : this.options.adaptiveMutation?.enabled\r\n          ? (genome as any)._mutRate\r\n          : this.options.mutationRate || 0.7;\r\n      const effectiveAmount =\r\n        this.options.adaptiveMutation?.enabled &&\r\n        this.options.adaptiveMutation.adaptAmount\r\n          ? (genome as any)._mutAmount ?? (this.options.mutationAmount || 1)\r\n          : this.options.mutationAmount || 1;\r\n      if (this._getRNG()() <= effectiveRate) {\r\n        for (let j = 0; j < effectiveAmount; j++) {\r\n          let mutationMethod = this.selectMutationMethod(genome, false);\r\n          // If selection returned the FFW array (test equality path), sample a real operator\r\n          if (Array.isArray(mutationMethod)) {\r\n            const arr = mutationMethod as any[];\r\n            mutationMethod = arr[Math.floor(this._getRNG()() * arr.length)];\r\n          }\r\n          if (mutationMethod && mutationMethod.name) {\r\n            const beforeNodes = genome.nodes.length;\r\n            const beforeConns = genome.connections.length;\r\n            if (mutationMethod === methods.mutation.ADD_NODE) {\r\n              this._mutateAddNodeReuse(genome);\r\n              // Ensure mutate spy triggers in tests without duplicating structure changes significantly\r\n              try {\r\n                genome.mutate(methods.mutation.MOD_WEIGHT);\r\n              } catch {}\r\n              this._invalidateGenomeCaches(genome);\r\n            } else if (mutationMethod === methods.mutation.ADD_CONN) {\r\n              this._mutateAddConnReuse(genome);\r\n              try {\r\n                genome.mutate(methods.mutation.MOD_WEIGHT);\r\n              } catch {}\r\n              this._invalidateGenomeCaches(genome);\r\n            } else {\r\n              genome.mutate(mutationMethod);\r\n              // Invalidate on potential structural ops\r\n              if (\r\n                mutationMethod === methods.mutation.ADD_GATE ||\r\n                mutationMethod === methods.mutation.SUB_NODE ||\r\n                mutationMethod === methods.mutation.SUB_CONN ||\r\n                mutationMethod === methods.mutation.ADD_SELF_CONN ||\r\n                mutationMethod === methods.mutation.ADD_BACK_CONN\r\n              ) {\r\n                this._invalidateGenomeCaches(genome);\r\n              }\r\n            }\r\n            if (this._getRNG()() < 0.5) this._mutateAddConnReuse(genome);\r\n            if (this.options.operatorAdaptation?.enabled) {\r\n              const stat = this._operatorStats.get(mutationMethod.name) || {\r\n                success: 0,\r\n                attempts: 0,\r\n              };\r\n              stat.attempts++;\r\n              const afterNodes = genome.nodes.length;\r\n              const afterConns = genome.connections.length;\r\n              if (afterNodes > beforeNodes || afterConns > beforeConns)\r\n                stat.success++;\r\n              this._operatorStats.set(mutationMethod.name, stat);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Perform ADD_NODE honoring global innovation reuse mapping\r\n  private _mutateAddNodeReuse(genome: Network) {\r\n    if (genome.connections.length === 0) {\r\n      // Create a baseline connection to allow a split so innovation registry is populated for tests\r\n      const inNode = genome.nodes.find((n) => n.type === 'input');\r\n      const outNode = genome.nodes.find((n) => n.type === 'output');\r\n      if (inNode && outNode) {\r\n        try {\r\n          genome.connect(inNode, outNode, 1);\r\n        } catch {}\r\n      }\r\n    }\r\n    // Choose a random enabled connection to split\r\n    const enabled = genome.connections.filter(\r\n      (c) => (c as any).enabled !== false\r\n    );\r\n    if (!enabled.length) return;\r\n    const conn = enabled[Math.floor(this._getRNG()() * enabled.length)];\r\n    const fromGene = (conn.from as any).geneId;\r\n    const toGene = (conn.to as any).geneId;\r\n    const key = fromGene + '->' + toGene;\r\n    const oldWeight = conn.weight;\r\n    // Remove existing connection\r\n    genome.disconnect(conn.from, conn.to);\r\n    let rec = this._nodeSplitInnovations.get(key);\r\n    if (!rec) {\r\n      // Create new node and two connections assigning fresh innovations\r\n      const NodeCls = require('./architecture/node').default;\r\n      const newNode = new NodeCls('hidden');\r\n      const inC = genome.connect(conn.from, newNode, 1)[0];\r\n      const outC = genome.connect(newNode, conn.to, oldWeight)[0];\r\n      if (inC) (inC as any).innovation = this._nextGlobalInnovation++;\r\n      if (outC) (outC as any).innovation = this._nextGlobalInnovation++;\r\n      rec = {\r\n        newNodeGeneId: (newNode as any).geneId,\r\n        inInnov: (inC as any)?.innovation,\r\n        outInnov: (outC as any)?.innovation,\r\n      };\r\n      this._nodeSplitInnovations.set(key, rec);\r\n      // Insert node before outputs for feedforward ordering\r\n      const toIdx = genome.nodes.indexOf(conn.to);\r\n      const insertIdx = Math.min(toIdx, genome.nodes.length - genome.output);\r\n      genome.nodes.splice(insertIdx, 0, newNode);\r\n    } else {\r\n      // Reuse existing historical marking\r\n      const NodeCls = require('./architecture/node').default;\r\n      const newNode = new NodeCls('hidden');\r\n      (newNode as any).geneId = rec.newNodeGeneId; // override auto geneId\r\n      const toIdx = genome.nodes.indexOf(conn.to);\r\n      const insertIdx = Math.min(toIdx, genome.nodes.length - genome.output);\r\n      genome.nodes.splice(insertIdx, 0, newNode);\r\n      const inC = genome.connect(conn.from, newNode, 1)[0];\r\n      const outC = genome.connect(newNode, conn.to, oldWeight)[0];\r\n      if (inC) (inC as any).innovation = rec.inInnov;\r\n      if (outC) (outC as any).innovation = rec.outInnov;\r\n    }\r\n  }\r\n  // Perform ADD_CONN with stable innovation reuse per node pair\r\n  private _mutateAddConnReuse(genome: Network) {\r\n    // Mirror logic from network.mutate ADD_CONN but intercept innovation assignment\r\n    // Build list of candidate pairs (feedforward only unless recurrent allowed)\r\n    const available: any[] = [];\r\n    for (let i = 0; i < genome.nodes.length - genome.output; i++) {\r\n      const from = genome.nodes[i];\r\n      for (\r\n        let j = Math.max(i + 1, genome.input);\r\n        j < genome.nodes.length;\r\n        j++\r\n      ) {\r\n        const to = genome.nodes[j];\r\n        if (!from.isProjectingTo(to)) available.push([from, to]);\r\n      }\r\n    }\r\n    if (!available.length) return;\r\n    const pair = available[Math.floor(this._getRNG()() * available.length)];\r\n    const from = pair[0];\r\n    const to = pair[1];\r\n    const key = (from as any).geneId + '->' + (to as any).geneId;\r\n    // If genome enforces acyclicity, ensure adding this edge won't create a cycle\r\n    if ((genome as any)._enforceAcyclic) {\r\n      // Use internal path check if exposed, else naive DFS\r\n      const createsCycle = (() => {\r\n        // Temporarily test if path exists from 'to' back to 'from'\r\n        const stack = [to];\r\n        const seen = new Set<any>();\r\n        while (stack.length) {\r\n          const n = stack.pop()!;\r\n          if (n === from) return true;\r\n          if (seen.has(n)) continue;\r\n          seen.add(n);\r\n          for (const c of n.connections.out) {\r\n            if (c.to !== n) stack.push(c.to);\r\n          }\r\n        }\r\n        return false;\r\n      })();\r\n      if (createsCycle) return; // skip candidate to maintain DAG\r\n    }\r\n    const conn = genome.connect(from, to)[0];\r\n    if (!conn) return;\r\n    if (this._connInnovations.has(key)) {\r\n      (conn as any).innovation = this._connInnovations.get(key)!;\r\n    } else {\r\n      (conn as any).innovation = this._nextGlobalInnovation++;\r\n      this._connInnovations.set(key, (conn as any).innovation);\r\n    }\r\n  }\r\n\r\n  // --- Speciation helpers (properly scoped) ---\r\n  private _fallbackInnov(c: any): number {\r\n    // Simple deterministic fallback if innovation missing\r\n    return (c.from?.index ?? 0) * 100000 + (c.to?.index ?? 0);\r\n  }\r\n  private _compatibilityDistance(a: Network, b: Network): number {\r\n    // Generation-scoped micro-cache to avoid recomputing distances (symmetry leveraged)\r\n    if (\r\n      !(this as any)._compatCacheGen ||\r\n      (this as any)._compatCacheGen !== this.generation\r\n    ) {\r\n      (this as any)._compatCacheGen = this.generation;\r\n      (this as any)._compatDistCache = new Map<string, number>();\r\n    }\r\n    const key =\r\n      (a as any)._id < (b as any)._id\r\n        ? `${(a as any)._id}|${(b as any)._id}`\r\n        : `${(b as any)._id}|${(a as any)._id}`;\r\n    const cacheMap: Map<string, number> = (this as any)._compatDistCache;\r\n    if (cacheMap.has(key)) return cacheMap.get(key)!;\r\n    // Cached sorted innovation lists to avoid repeated map/set allocations\r\n    const getCache = (n: Network) => {\r\n      const anyN = n as any;\r\n      if (!anyN._compatCache) {\r\n        const list: [number, number][] = n.connections.map((c: any) => [\r\n          c.innovation ?? this._fallbackInnov(c),\r\n          c.weight,\r\n        ]);\r\n        list.sort((x, y) => x[0] - y[0]);\r\n        anyN._compatCache = list;\r\n      }\r\n      return anyN._compatCache as [number, number][];\r\n    };\r\n    const aList = getCache(a);\r\n    const bList = getCache(b);\r\n    let i = 0,\r\n      j = 0;\r\n    let matches = 0,\r\n      disjoint = 0,\r\n      excess = 0;\r\n    let weightDiff = 0;\r\n    const maxInnovA = aList.length ? aList[aList.length - 1][0] : 0;\r\n    const maxInnovB = bList.length ? bList[bList.length - 1][0] : 0;\r\n    while (i < aList.length && j < bList.length) {\r\n      const [innovA, wA] = aList[i];\r\n      const [innovB, wB] = bList[j];\r\n      if (innovA === innovB) {\r\n        matches++;\r\n        weightDiff += Math.abs(wA - wB);\r\n        i++;\r\n        j++;\r\n      } else if (innovA < innovB) {\r\n        // gene only in A\r\n        if (innovA > maxInnovB) excess++;\r\n        else disjoint++;\r\n        i++;\r\n      } else {\r\n        // gene only in B\r\n        if (innovB > maxInnovA) excess++;\r\n        else disjoint++;\r\n        j++;\r\n      }\r\n    }\r\n    // Remaining genes are excess relative to other list\r\n    if (i < aList.length) excess += aList.length - i;\r\n    if (j < bList.length) excess += bList.length - j;\r\n    const N = Math.max(1, Math.max(aList.length, bList.length));\r\n    const avgWeightDiff = matches ? weightDiff / matches : 0;\r\n    const o = this.options;\r\n    const dist =\r\n      (o.excessCoeff! * excess) / N +\r\n      (o.disjointCoeff! * disjoint) / N +\r\n      o.weightDiffCoeff! * avgWeightDiff;\r\n    cacheMap.set(key, dist);\r\n    return dist;\r\n  }\r\n  private _speciate() {\r\n    // Preserve previous membership for turnover\r\n    this._prevSpeciesMembers.clear();\r\n    for (const sp of this._species) {\r\n      const set = new Set<number>();\r\n      for (const m of sp.members) set.add((m as any)._id);\r\n      this._prevSpeciesMembers.set(sp.id, set);\r\n    }\r\n    // Clear members\r\n    this._species.forEach((sp) => (sp.members = []));\r\n    // Assign genomes\r\n    for (const genome of this.population) {\r\n      let assigned = false;\r\n      for (const sp of this._species) {\r\n        const dist = this._compatibilityDistance(genome, sp.representative);\r\n        if (dist < (this.options.compatibilityThreshold || 3)) {\r\n          sp.members.push(genome);\r\n          assigned = true;\r\n          break;\r\n        }\r\n      }\r\n      if (!assigned) {\r\n        const sid = this._nextSpeciesId++;\r\n        this._species.push({\r\n          id: sid,\r\n          members: [genome],\r\n          representative: genome,\r\n          lastImproved: this.generation,\r\n          bestScore: genome.score || -Infinity,\r\n        });\r\n        this._speciesCreated.set(sid, this.generation);\r\n      }\r\n    }\r\n    // Remove empties\r\n    this._species = this._species.filter((sp) => sp.members.length > 0);\r\n    // Refresh representatives (first member)\r\n    this._species.forEach((sp) => {\r\n      sp.representative = sp.members[0];\r\n    });\r\n    // Apply age penalty (soft) before sharing adjustments? (Here after assignment, before dynamic threshold update already executed earlier or will adapt next gen)\r\n    const ageProt = this.options.speciesAgeProtection || {\r\n      grace: 3,\r\n      oldPenalty: 0.5,\r\n    };\r\n    for (const sp of this._species) {\r\n      const created = this._speciesCreated.get(sp.id) ?? this.generation;\r\n      const age = this.generation - created;\r\n      if (age >= (ageProt.grace ?? 3) * 10) {\r\n        // heuristic 'very old'\r\n        // scale member scores by oldPenalty to reduce reproductive share without immediate elimination\r\n        const pen = ageProt.oldPenalty ?? 0.5;\r\n        if (pen < 1)\r\n          sp.members.forEach((m) => {\r\n            if (typeof m.score === 'number') m.score *= pen;\r\n          });\r\n      }\r\n    }\r\n    // Dynamic threshold controller\r\n    if (this.options.speciation && (this.options.targetSpecies || 0) > 0) {\r\n      const target = this.options.targetSpecies!;\r\n      const observed = this._species.length;\r\n      const adj = this.options.compatAdjust!;\r\n      const sw = Math.max(1, adj.smoothingWindow || 1);\r\n      const alpha = 2 / (sw + 1);\r\n      this._compatSpeciesEMA =\r\n        this._compatSpeciesEMA === undefined\r\n          ? observed\r\n          : this._compatSpeciesEMA +\r\n            alpha * (observed - this._compatSpeciesEMA);\r\n      const smoothed = this._compatSpeciesEMA;\r\n      const error = target - smoothed; // positive => want more species => decrease threshold\r\n      this._compatIntegral = this._compatIntegral * (adj.decay || 0.95) + error;\r\n      const delta =\r\n        (adj.kp || 0) * error + (adj.ki || 0) * this._compatIntegral;\r\n      let newThresh = (this.options.compatibilityThreshold || 3) - delta;\r\n      const minT = adj.minThreshold || 0.5;\r\n      const maxT = adj.maxThreshold || 10;\r\n      if (newThresh < minT) {\r\n        newThresh = minT;\r\n        this._compatIntegral = 0;\r\n      }\r\n      if (newThresh > maxT) {\r\n        newThresh = maxT;\r\n        this._compatIntegral = 0;\r\n      }\r\n      this.options.compatibilityThreshold = newThresh;\r\n    }\r\n    // Auto compatibility coefficient tuning (adjust excess/disjoint weighting to influence clustering)\r\n    if (\r\n      this.options.autoCompatTuning?.enabled &&\r\n      (this.options.targetSpecies || 0) > 0\r\n    ) {\r\n      const tgt =\r\n        this.options.autoCompatTuning.target ?? this.options.targetSpecies!;\r\n      const obs = this._species.length;\r\n      const err = tgt - obs; // positive -> want more species (lower effective distances) -> reduce coeffs\r\n      const rate = this.options.autoCompatTuning.adjustRate ?? 0.01;\r\n      const minC = this.options.autoCompatTuning.minCoeff ?? 0.1;\r\n      const maxC = this.options.autoCompatTuning.maxCoeff ?? 5.0;\r\n      const factor = 1 - rate * Math.sign(err); // if err>0 reduce coeffs slightly, else increase\r\n      if (err !== 0) {\r\n        this.options.excessCoeff = Math.min(\r\n          maxC,\r\n          Math.max(minC, this.options.excessCoeff! * factor)\r\n        );\r\n        this.options.disjointCoeff = Math.min(\r\n          maxC,\r\n          Math.max(minC, this.options.disjointCoeff! * factor)\r\n        );\r\n        // weightDiffCoeff left unchanged for stability\r\n      }\r\n    }\r\n    // Snapshot history\r\n    if (this.options.speciesAllocation?.extendedHistory) {\r\n      const stats = this._species.map((sp) => {\r\n        const sizes = sp.members.map((m) => ({\r\n          nodes: m.nodes.length,\r\n          conns: m.connections.length,\r\n          score: m.score || 0,\r\n          nov: (m as any)._novelty || 0,\r\n          ent: this._structuralEntropy(m),\r\n        }));\r\n        const avg = (arr: number[]) =>\r\n          arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;\r\n        let compSum = 0,\r\n          compCount = 0; // mean intra-species compatibility (sample first 10)\r\n        for (let i = 0; i < sp.members.length && i < 10; i++)\r\n          for (let j = i + 1; j < sp.members.length && j < 10; j++) {\r\n            compSum += this._compatibilityDistance(\r\n              sp.members[i],\r\n              sp.members[j]\r\n            );\r\n            compCount++;\r\n          }\r\n        const meanCompat = compCount ? compSum / compCount : 0;\r\n        const last = this._speciesLastStats.get(sp.id);\r\n        const meanNodes = avg(sizes.map((s) => s.nodes));\r\n        const meanConns = avg(sizes.map((s) => s.conns));\r\n        const deltaMeanNodes = last ? meanNodes - last.meanNodes : 0;\r\n        const deltaMeanConns = last ? meanConns - last.meanConns : 0;\r\n        const deltaBestScore = last ? sp.bestScore - last.best : 0;\r\n        const created = this._speciesCreated.get(sp.id) ?? this.generation;\r\n        const age = this.generation - created;\r\n        let turnoverRate = 0;\r\n        const prevSet = this._prevSpeciesMembers.get(sp.id);\r\n        if (prevSet && sp.members.length) {\r\n          let newCount = 0;\r\n          for (const m of sp.members)\r\n            if (!prevSet.has((m as any)._id)) newCount++;\r\n          turnoverRate = newCount / sp.members.length;\r\n        }\r\n        const varCalc = (arr: number[]) => {\r\n          if (!arr.length) return 0;\r\n          const m = avg(arr);\r\n          return avg(arr.map((v) => (v - m) * (v - m)));\r\n        };\r\n        const varNodes = varCalc(sizes.map((s) => s.nodes));\r\n        const varConns = varCalc(sizes.map((s) => s.conns));\r\n        // Innovation & enablement stats\r\n        let innovSum = 0,\r\n          innovCount = 0,\r\n          maxInnov = -Infinity,\r\n          minInnov = Infinity;\r\n        let enabled = 0,\r\n          disabled = 0;\r\n        for (const m of sp.members)\r\n          for (const c of m.connections) {\r\n            const innov = (c as any).innovation ?? this._fallbackInnov(c);\r\n            innovSum += innov;\r\n            innovCount++;\r\n            if (innov > maxInnov) maxInnov = innov;\r\n            if (innov < minInnov) minInnov = innov;\r\n            if ((c as any).enabled === false) disabled++;\r\n            else enabled++;\r\n          }\r\n        const meanInnovation = innovCount ? innovSum / innovCount : 0;\r\n        const innovationRange =\r\n          isFinite(maxInnov) && isFinite(minInnov) && maxInnov > minInnov\r\n            ? maxInnov - minInnov\r\n            : 0;\r\n        const enabledRatio =\r\n          enabled + disabled > 0 ? enabled / (enabled + disabled) : 0;\r\n        return {\r\n          id: sp.id,\r\n          size: sp.members.length,\r\n          best: sp.bestScore,\r\n          lastImproved: sp.lastImproved,\r\n          age,\r\n          meanNodes,\r\n          meanConns,\r\n          meanScore: avg(sizes.map((s) => s.score)),\r\n          meanNovelty: avg(sizes.map((s) => s.nov)),\r\n          meanCompat,\r\n          meanEntropy: avg(sizes.map((s) => s.ent)),\r\n          varNodes,\r\n          varConns,\r\n          deltaMeanNodes,\r\n          deltaMeanConns,\r\n          deltaBestScore,\r\n          turnoverRate,\r\n          meanInnovation,\r\n          innovationRange,\r\n          enabledRatio,\r\n        };\r\n      });\r\n      for (const st of stats)\r\n        this._speciesLastStats.set(st.id, {\r\n          meanNodes: st.meanNodes,\r\n          meanConns: st.meanConns,\r\n          best: st.best,\r\n        });\r\n      this._speciesHistory.push({ generation: this.generation, stats });\r\n    } else {\r\n      this._speciesHistory.push({\r\n        generation: this.generation,\r\n        stats: this._species.map((sp) => ({\r\n          id: sp.id,\r\n          size: sp.members.length,\r\n          best: sp.bestScore,\r\n          lastImproved: sp.lastImproved,\r\n        })),\r\n      });\r\n    }\r\n    if (this._speciesHistory.length > 200) this._speciesHistory.shift();\r\n  }\r\n  private _applyFitnessSharing() {\r\n    const sigma = this.options.sharingSigma || 0;\r\n    if (sigma > 0) {\r\n      // Kernel fitness sharing within species based on compatibility distance\r\n      this._species.forEach((sp) => {\r\n        const members = sp.members;\r\n        for (let i = 0; i < members.length; i++) {\r\n          const mi = members[i];\r\n          if (typeof mi.score !== 'number') continue;\r\n          let shSum = 0;\r\n          for (let j = 0; j < members.length; j++) {\r\n            const mj = members[j];\r\n            const dist = i === j ? 0 : this._compatibilityDistance(mi, mj);\r\n            if (dist < sigma) {\r\n              const ratio = dist / sigma;\r\n              // Quadratic kernel (1 - (d/sigma)^2)\r\n              shSum += 1 - ratio * ratio;\r\n            }\r\n          }\r\n          if (shSum <= 0) shSum = 1; // safety\r\n          mi.score = mi.score / shSum;\r\n        }\r\n      });\r\n    } else {\r\n      // Simple per-species averaging (classic NEAT style)\r\n      this._species.forEach((sp) => {\r\n        const size = sp.members.length;\r\n        sp.members.forEach((m) => {\r\n          if (typeof m.score === 'number') m.score = m.score / size;\r\n        });\r\n      });\r\n    }\r\n  }\r\n  private _sortSpeciesMembers(sp: { members: Network[] }) {\r\n    sp.members.sort((a, b) => (b.score || 0) - (a.score || 0));\r\n  }\r\n  private _updateSpeciesStagnation() {\r\n    const stagn = this.options.stagnationGenerations || 15;\r\n    this._species.forEach((sp) => {\r\n      this._sortSpeciesMembers(sp);\r\n      const top = sp.members[0];\r\n      if ((top.score || -Infinity) > sp.bestScore) {\r\n        sp.bestScore = top.score || -Infinity;\r\n        sp.lastImproved = this.generation;\r\n      }\r\n    });\r\n    const survivors = this._species.filter(\r\n      (sp) => this.generation - sp.lastImproved <= stagn\r\n    );\r\n    if (survivors.length) this._species = survivors;\r\n  }\r\n  getSpeciesStats(): {\r\n    id: number;\r\n    size: number;\r\n    bestScore: number;\r\n    lastImproved: number;\r\n  }[] {\r\n    return this._species.map((sp) => ({\r\n      id: sp.id,\r\n      size: sp.members.length,\r\n      bestScore: sp.bestScore,\r\n      lastImproved: sp.lastImproved,\r\n    }));\r\n  }\r\n  getSpeciesHistory(): {\r\n    generation: number;\r\n    stats: { id: number; size: number; best: number; lastImproved: number }[];\r\n  }[] {\r\n    return this._speciesHistory;\r\n  }\r\n  getNoveltyArchiveSize(): number {\r\n    return this._noveltyArchive.length;\r\n  }\r\n  getMultiObjectiveMetrics(): {\r\n    rank: number;\r\n    crowding: number;\r\n    score: number;\r\n    nodes: number;\r\n    connections: number;\r\n  }[] {\r\n    return this.population.map((g) => ({\r\n      rank: (g as any)._moRank ?? 0,\r\n      crowding: (g as any)._moCrowd ?? 0,\r\n      score: g.score || 0,\r\n      nodes: g.nodes.length,\r\n      connections: g.connections.length,\r\n    }));\r\n  }\r\n  getOperatorStats(): { name: string; success: number; attempts: number }[] {\r\n    return Array.from(this._operatorStats.entries()).map(([name, s]) => ({\r\n      name,\r\n      success: s.success,\r\n      attempts: s.attempts,\r\n    }));\r\n  }\r\n  getTelemetry(): any[] {\r\n    return this._telemetry;\r\n  }\r\n  exportTelemetryJSONL(): string {\r\n    return this._telemetry.map((e) => JSON.stringify(e)).join('\\n');\r\n  }\r\n  exportTelemetryCSV(maxEntries = 500): string {\r\n    const slice = this._telemetry.slice(-maxEntries);\r\n    if (!slice.length) return '';\r\n    // Collect headers (shallow) + flatten complexity.* and perf.* if present\r\n    const baseKeys = new Set<string>();\r\n    const complexKeys = new Set<string>();\r\n    const perfKeys = new Set<string>();\r\n    const lineageKeys = new Set<string>();\r\n    const diversityLineageKeys = new Set<string>();\r\n    let includeOps = false;\r\n    let includeObjectives = false;\r\n    let includeObjAges = false;\r\n    let includeSpeciesAlloc = false;\r\n    let includeObjEvents = false;\r\n    let includeObjImportance = false;\r\n    for (const e of slice) {\r\n      Object.keys(e).forEach((k) => {\r\n        if (k !== 'complexity' && k !== 'perf' && k !== 'ops' && k !== 'fronts')\r\n          baseKeys.add(k);\r\n      });\r\n      if (Array.isArray(e.fronts)) baseKeys.add('fronts');\r\n      if (e.complexity)\r\n        Object.keys(e.complexity).forEach((k) => complexKeys.add(k));\r\n      if (e.perf) Object.keys(e.perf).forEach((k) => perfKeys.add(k));\r\n      if (e.lineage) Object.keys(e.lineage).forEach((k) => lineageKeys.add(k));\r\n      if (e.diversity) {\r\n        if ('lineageMeanDepth' in e.diversity)\r\n          diversityLineageKeys.add('lineageMeanDepth');\r\n        if ('lineageMeanPairDist' in e.diversity)\r\n          diversityLineageKeys.add('lineageMeanPairDist');\r\n      }\r\n      if ('rng' in e) baseKeys.add('rng');\r\n      if (Array.isArray(e.ops) && e.ops.length) includeOps = true;\r\n      if (Array.isArray(e.objectives)) includeObjectives = true;\r\n      if (e.objAges) includeObjAges = true;\r\n      if (Array.isArray(e.speciesAlloc)) includeSpeciesAlloc = true;\r\n      if (Array.isArray(e.objEvents) && e.objEvents.length)\r\n        includeObjEvents = true;\r\n      if (e.objImportance) includeObjImportance = true;\r\n    }\r\n    const headers = [\r\n      ...baseKeys,\r\n      ...[...complexKeys].map((k) => `complexity.${k}`),\r\n      ...[...perfKeys].map((k) => `perf.${k}`),\r\n      ...[...lineageKeys].map((k) => `lineage.${k}`),\r\n      ...[...diversityLineageKeys].map((k) => `diversity.${k}`),\r\n    ];\r\n    if (includeOps) headers.push('ops');\r\n    if (includeObjectives) headers.push('objectives');\r\n    if (includeObjAges) headers.push('objAges');\r\n    if (includeSpeciesAlloc) headers.push('speciesAlloc');\r\n    if (includeObjEvents) headers.push('objEvents');\r\n    if (includeObjImportance) headers.push('objImportance');\r\n    const csvLines = [headers.join(',')];\r\n    for (const e of slice) {\r\n      const row: string[] = [];\r\n      for (const h of headers) {\r\n        if (h.startsWith('complexity.')) {\r\n          const key = h.slice('complexity.'.length);\r\n          row.push(\r\n            e.complexity && key in e.complexity\r\n              ? JSON.stringify(e.complexity[key])\r\n              : ''\r\n          );\r\n        } else if (h.startsWith('perf.')) {\r\n          const key = h.slice('perf.'.length);\r\n          row.push(e.perf && key in e.perf ? JSON.stringify(e.perf[key]) : '');\r\n        } else if (h.startsWith('lineage.')) {\r\n          const key = h.slice('lineage.'.length);\r\n          row.push(\r\n            e.lineage && key in e.lineage ? JSON.stringify(e.lineage[key]) : ''\r\n          );\r\n        } else if (h.startsWith('diversity.')) {\r\n          const key = h.slice('diversity.'.length);\r\n          row.push(\r\n            e.diversity && key in e.diversity\r\n              ? JSON.stringify(e.diversity[key])\r\n              : ''\r\n          );\r\n        } else if (h === 'fronts') {\r\n          row.push(Array.isArray(e.fronts) ? JSON.stringify(e.fronts) : '');\r\n        } else if (h === 'ops') {\r\n          row.push(Array.isArray(e.ops) ? JSON.stringify(e.ops) : '');\r\n        } else if (h === 'objectives') {\r\n          row.push(\r\n            Array.isArray(e.objectives) ? JSON.stringify(e.objectives) : ''\r\n          );\r\n        } else if (h === 'objAges') {\r\n          row.push(e.objAges ? JSON.stringify(e.objAges) : '');\r\n        } else if (h === 'speciesAlloc') {\r\n          row.push(\r\n            Array.isArray(e.speciesAlloc) ? JSON.stringify(e.speciesAlloc) : ''\r\n          );\r\n        } else if (h === 'objEvents') {\r\n          row.push(\r\n            Array.isArray(e.objEvents) ? JSON.stringify(e.objEvents) : ''\r\n          );\r\n        } else if (h === 'objImportance') {\r\n          row.push(e.objImportance ? JSON.stringify(e.objImportance) : '');\r\n        } else {\r\n          row.push(JSON.stringify((e as any)[h]));\r\n        }\r\n      }\r\n      csvLines.push(row.join(','));\r\n    }\r\n    return csvLines.join('\\n');\r\n  }\r\n  clearTelemetry() {\r\n    this._telemetry = [];\r\n  }\r\n  getObjectives(): { key: string; direction: 'max' | 'min' }[] {\r\n    return this._getObjectives().map((o) => ({\r\n      key: o.key,\r\n      direction: o.direction,\r\n    }));\r\n  }\r\n  getObjectiveEvents(): { gen: number; type: 'add' | 'remove'; key: string }[] {\r\n    return this._objectiveEvents.slice();\r\n  }\r\n  getLineageSnapshot(limit = 20): { id: number; parents: number[] }[] {\r\n    return this.population.slice(0, limit).map((g) => ({\r\n      id: (g as any)._id ?? -1,\r\n      parents: Array.isArray((g as any)._parents)\r\n        ? (g as any)._parents.slice()\r\n        : [],\r\n    }));\r\n  }\r\n  exportSpeciesHistoryCSV(maxEntries = 200): string {\r\n    const hist = this._speciesHistory.slice(-maxEntries);\r\n    if (!hist.length) return '';\r\n    // Collect dynamic headers from union of keys in stats objects\r\n    const keySet = new Set<string>(['generation']);\r\n    for (const h of hist)\r\n      for (const s of h.stats) Object.keys(s).forEach((k) => keySet.add(k));\r\n    const headers = Array.from(keySet);\r\n    const lines = [headers.join(',')];\r\n    for (const h of hist) {\r\n      for (const s of h.stats) {\r\n        const row: string[] = [];\r\n        for (const k of headers) {\r\n          if (k === 'generation') row.push(JSON.stringify(h.generation));\r\n          else row.push(JSON.stringify((s as any)[k]));\r\n        }\r\n        lines.push(row.join(','));\r\n      }\r\n    }\r\n    return lines.join('\\n');\r\n  }\r\n  getParetoFronts(maxFronts = 3): Network[][] {\r\n    if (!this.options.multiObjective?.enabled) return [[...this.population]];\r\n    // reconstruct fronts from stored ranks (avoids re-sorting again)\r\n    const fronts: Network[][] = [];\r\n    for (let r = 0; r < maxFronts; r++) {\r\n      const front = this.population.filter(\r\n        (g) => ((g as any)._moRank ?? 0) === r\r\n      );\r\n      if (!front.length) break;\r\n      fronts.push(front);\r\n    }\r\n    return fronts;\r\n  }\r\n  getDiversityStats() {\r\n    return this._diversityStats;\r\n  }\r\n  registerObjective(\r\n    key: string,\r\n    direction: 'min' | 'max',\r\n    accessor: (g: Network) => number\r\n  ) {\r\n    if (!this.options.multiObjective)\r\n      (this.options as any).multiObjective = { enabled: true };\r\n    const mo: any = this.options.multiObjective;\r\n    if (!mo.objectives) mo.objectives = [];\r\n    mo.objectives = mo.objectives.filter((o: any) => o.key !== key);\r\n    mo.objectives.push({ key, direction, accessor });\r\n    this._objectivesList = undefined as any;\r\n  }\r\n  clearObjectives() {\r\n    if (this.options.multiObjective?.objectives)\r\n      this.options.multiObjective.objectives = [] as any;\r\n    this._objectivesList = undefined as any;\r\n  }\r\n  // Advanced archives & performance accessors\r\n  getParetoArchive(maxEntries = 50) {\r\n    return this._paretoArchive.slice(-maxEntries);\r\n  }\r\n  exportParetoFrontJSONL(maxEntries = 100): string {\r\n    const slice = this._paretoObjectivesArchive.slice(-maxEntries);\r\n    return slice.map((e) => JSON.stringify(e)).join('\\n');\r\n  }\r\n  getPerformanceStats() {\r\n    return {\r\n      lastEvalMs: this._lastEvalDuration,\r\n      lastEvolveMs: this._lastEvolveDuration,\r\n    };\r\n  }\r\n  // Utility exports / maintenance\r\n  exportSpeciesHistoryJSONL(maxEntries = 200): string {\r\n    const slice = this._speciesHistory.slice(-maxEntries);\r\n    return slice.map((e) => JSON.stringify(e)).join('\\n');\r\n  }\r\n  resetNoveltyArchive() {\r\n    this._noveltyArchive = [];\r\n  }\r\n  clearParetoArchive() {\r\n    this._paretoArchive = [];\r\n  }\r\n\r\n  /**\r\n   * Sorts the population in descending order of fitness scores.\r\n   * Ensures that the fittest genomes are at the start of the population array.\r\n   */\r\n  sort(): void {\r\n    this.population.sort((a, b) => (b.score ?? 0) - (a.score ?? 0));\r\n  }\r\n\r\n  /**\r\n   * Selects a parent genome for breeding based on the selection method.\r\n   * Supports multiple selection strategies, including POWER, FITNESS_PROPORTIONATE, and TOURNAMENT.\r\n   * @returns The selected parent genome.\r\n   * @throws Error if tournament size exceeds population size.\r\n   */\r\n  getParent(): Network {\r\n    const selection = this.options.selection;\r\n    const selectionName = selection?.name;\r\n    switch (selectionName) {\r\n      case 'POWER':\r\n        if (\r\n          this.population[0]?.score !== undefined &&\r\n          this.population[1]?.score !== undefined &&\r\n          this.population[0].score < this.population[1].score\r\n        ) {\r\n          this.sort();\r\n        }\r\n        const index = Math.floor(\r\n          Math.pow(this._getRNG()(), selection.power || 1) *\r\n            this.population.length\r\n        );\r\n        return this.population[index];\r\n      case 'FITNESS_PROPORTIONATE':\r\n        let totalFitness = 0;\r\n        let minimalFitness = 0;\r\n        this.population.forEach((genome) => {\r\n          minimalFitness = Math.min(minimalFitness, genome.score ?? 0);\r\n          totalFitness += genome.score ?? 0;\r\n        });\r\n        minimalFitness = Math.abs(minimalFitness);\r\n        totalFitness += minimalFitness * this.population.length;\r\n\r\n        const random = this._getRNG()() * totalFitness;\r\n        let value = 0;\r\n        for (const genome of this.population) {\r\n          value += (genome.score ?? 0) + minimalFitness;\r\n          if (random < value) return genome;\r\n        }\r\n        return this.population[\r\n          Math.floor(this._getRNG()() * this.population.length)\r\n        ];\r\n      case 'TOURNAMENT':\r\n        if (selection.size > this.options.popsize!) {\r\n          throw new Error('Tournament size must be less than population size.');\r\n        }\r\n        const tournament = [];\r\n        for (let i = 0; i < selection.size; i++) {\r\n          tournament.push(\r\n            this.population[\r\n              Math.floor(this._getRNG()() * this.population.length)\r\n            ]\r\n          );\r\n        }\r\n        tournament.sort((a, b) => (b.score ?? 0) - (a.score ?? 0));\r\n        for (let i = 0; i < tournament.length; i++) {\r\n          if (\r\n            this._getRNG()() < selection.probability ||\r\n            i === tournament.length - 1\r\n          ) {\r\n            return tournament[i];\r\n          }\r\n        }\r\n        break;\r\n      default:\r\n        // fallback for legacy or custom selection objects\r\n        if (selection === methods.selection.POWER) {\r\n          // ...repeat POWER logic...\r\n          if (\r\n            this.population[0]?.score !== undefined &&\r\n            this.population[1]?.score !== undefined &&\r\n            this.population[0].score < this.population[1].score\r\n          ) {\r\n            this.sort();\r\n          }\r\n          const index = Math.floor(\r\n            Math.pow(this._getRNG()(), selection.power || 1) *\r\n              this.population.length\r\n          );\r\n          return this.population[index];\r\n        }\r\n        if (selection === methods.selection.FITNESS_PROPORTIONATE) {\r\n          // ...repeat FITNESS_PROPORTIONATE logic...\r\n          let totalFitness = 0;\r\n          let minimalFitness = 0;\r\n          this.population.forEach((genome) => {\r\n            minimalFitness = Math.min(minimalFitness, genome.score ?? 0);\r\n            totalFitness += genome.score ?? 0;\r\n          });\r\n          minimalFitness = Math.abs(minimalFitness);\r\n          totalFitness += minimalFitness * this.population.length;\r\n\r\n          const random = this._getRNG()() * totalFitness;\r\n          let value = 0;\r\n          for (const genome of this.population) {\r\n            value += (genome.score ?? 0) + minimalFitness;\r\n            if (random < value) return genome;\r\n          }\r\n          return this.population[\r\n            Math.floor(this._getRNG()() * this.population.length)\r\n          ];\r\n        }\r\n        if (selection === methods.selection.TOURNAMENT) {\r\n          // ...repeat TOURNAMENT logic...\r\n          if (selection.size > this.options.popsize!) {\r\n            throw new Error(\r\n              'Tournament size must be less than population size.'\r\n            );\r\n          }\r\n          const tournament = [];\r\n          for (let i = 0; i < selection.size; i++) {\r\n            tournament.push(\r\n              this.population[\r\n                Math.floor(this._getRNG()() * this.population.length)\r\n              ]\r\n            );\r\n          }\r\n          tournament.sort((a, b) => (b.score ?? 0) - (a.score ?? 0));\r\n          for (let i = 0; i < tournament.length; i++) {\r\n            if (\r\n              this._getRNG()() < selection.probability ||\r\n              i === tournament.length - 1\r\n            ) {\r\n              return tournament[i];\r\n            }\r\n          }\r\n        }\r\n        break;\r\n    }\r\n    return this.population[0]; // Default fallback\r\n  }\r\n\r\n  /**\r\n   * Retrieves the fittest genome from the population.\r\n   * Ensures that the population is evaluated and sorted before returning the result.\r\n   * @returns The fittest genome in the population.\r\n   */\r\n  getFittest(): Network {\r\n    if (this.population[this.population.length - 1].score === undefined) {\r\n      this.evaluate();\r\n    }\r\n    if (\r\n      this.population[1] &&\r\n      (this.population[0].score ?? 0) < (this.population[1].score ?? 0)\r\n    ) {\r\n      this.sort();\r\n    }\r\n    return this.population[0];\r\n  }\r\n\r\n  /**\r\n   * Calculates the average fitness score of the population.\r\n   * Ensures that the population is evaluated before calculating the average.\r\n   * @returns The average fitness score of the population.\r\n   */\r\n  getAverage(): number {\r\n    if (this.population[this.population.length - 1].score === undefined) {\r\n      this.evaluate();\r\n    }\r\n    const totalScore = this.population.reduce(\r\n      (sum, genome) => sum + (genome.score ?? 0),\r\n      0\r\n    );\r\n    return totalScore / this.population.length;\r\n  }\r\n\r\n  /**\r\n   * Exports the current population as an array of JSON objects.\r\n   * Useful for saving the state of the population for later use.\r\n   * @returns An array of JSON representations of the population.\r\n   */\r\n  export(): any[] {\r\n    return this.population.map((genome) => genome.toJSON());\r\n  }\r\n\r\n  /**\r\n   * Imports a population from an array of JSON objects.\r\n   * Replaces the current population with the imported one.\r\n   * @param json - An array of JSON objects representing the population.\r\n   */\r\n  import(json: any[]): void {\r\n    this.population = json.map((genome) => Network.fromJSON(genome));\r\n    this.options.popsize = this.population.length;\r\n  }\r\n  /**\r\n   * Convenience: export full evolutionary state (meta + population genomes).\r\n   * Combines innovation registries and serialized genomes for easy persistence.\r\n   */\r\n  exportState(): any {\r\n    return {\r\n      neat: this.toJSON(),\r\n      population: this.export(),\r\n    };\r\n  }\r\n  /**\r\n   * Convenience: restore full evolutionary state previously produced by exportState().\r\n   * @param bundle Object with shape { neat, population }\r\n   * @param fitness Fitness function to attach\r\n   */\r\n  static importState(bundle: any, fitness: (n: Network) => number): Neat {\r\n    if (!bundle || typeof bundle !== 'object')\r\n      throw new Error('Invalid state bundle');\r\n    const neat = Neat.fromJSON(bundle.neat, fitness);\r\n    if (Array.isArray(bundle.population)) neat.import(bundle.population);\r\n    return neat;\r\n  }\r\n  // Serialize NEAT meta (without population) for persistence of innovation history\r\n  toJSON(): any {\r\n    return {\r\n      input: this.input,\r\n      output: this.output,\r\n      generation: this.generation,\r\n      options: this.options,\r\n      nodeSplitInnovations: Array.from(this._nodeSplitInnovations.entries()),\r\n      connInnovations: Array.from(this._connInnovations.entries()),\r\n      nextGlobalInnovation: this._nextGlobalInnovation,\r\n    };\r\n  }\r\n  static fromJSON(json: any, fitness: (n: Network) => number): Neat {\r\n    const neat = new Neat(json.input, json.output, fitness, json.options || {});\r\n    neat.generation = json.generation || 0;\r\n    if (Array.isArray(json.nodeSplitInnovations))\r\n      neat._nodeSplitInnovations = new Map(json.nodeSplitInnovations);\r\n    if (Array.isArray(json.connInnovations))\r\n      neat._connInnovations = new Map(json.connInnovations);\r\n    if (typeof json.nextGlobalInnovation === 'number')\r\n      neat._nextGlobalInnovation = json.nextGlobalInnovation;\r\n    return neat;\r\n  }\r\n}\r\n", "/**\r\n * BrowserTerminalUtility\r\n *\r\n * Minimal drop-in replacement for `TerminalUtility` that works in the browser.\r\n * It provides a DOM-based \"clear screen\" and keeps the same evolveUntilSolved API.\r\n */\r\nimport { IEvolutionFunctionResult, IEvolutionStepResult } from './interfaces';\r\n\r\nexport class BrowserTerminalUtility {\r\n  /**\r\n   * Create a clearer that clears a DOM container's contents.\r\n   * If no container is provided it will try to use an element with id \"ascii-maze-output\".\r\n   */\r\n  static createTerminalClearer(container?: HTMLElement): () => void {\r\n    const el =\r\n      container ??\r\n      (typeof document !== 'undefined'\r\n        ? document.getElementById('ascii-maze-output')\r\n        : null);\r\n    return () => {\r\n      if (el) el.innerHTML = '';\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Same semantics as the Node version: repeatedly call evolveFn until success or threshold reached.\r\n   */\r\n  static async evolveUntilSolved(\r\n    evolveFn: () => Promise<IEvolutionFunctionResult>,\r\n    minProgressToPass: number = 60,\r\n    maxTries: number = 10\r\n  ): Promise<{ finalResult: IEvolutionStepResult; tries: number }> {\r\n    let tries = 0;\r\n    let lastResult: IEvolutionStepResult = {\r\n      success: false,\r\n      progress: 0,\r\n    } as any;\r\n    while (tries < maxTries) {\r\n      tries++;\r\n      const { finalResult } = await evolveFn();\r\n      lastResult = finalResult;\r\n      if (finalResult.success || finalResult.progress >= minProgressToPass) {\r\n        return { finalResult, tries };\r\n      }\r\n    }\r\n    return { finalResult: lastResult, tries };\r\n  }\r\n}\r\n", "/**\r\n * browserLogger.ts\r\n *\r\n * Provides a `createBrowserLogger` factory that returns a function compatible with `forceLog`.\r\n * The logger converts common ANSI sequences into inline HTML styles and appends\r\n * formatted output to a <pre> element inside the provided container.\r\n */\r\n\r\n/** Minimal mapping of 256-color palette indices used by the demo to CSS hex colors. */\r\nconst ANSI_256_MAP: { [code: number]: string } = {\r\n  205: '#ff6ac1',\r\n  93: '#b48bf2',\r\n  154: '#a6d189',\r\n  51: '#00bcd4',\r\n  226: '#ffd166',\r\n  214: '#ff9f43',\r\n  196: '#ff3b30',\r\n  46: '#00e676',\r\n  123: '#6ec6ff',\r\n  177: '#caa6ff',\r\n  80: '#00bfa5',\r\n  121: '#9bdc8a',\r\n  203: '#ff6b9f',\r\n  99: '#6b62d6',\r\n  44: '#00a9e0',\r\n  220: '#ffd54f',\r\n  250: '#ececec',\r\n  45: '#00aaff',\r\n  201: '#ff4fc4',\r\n  231: '#ffffff',\r\n  218: '#ffc6d3',\r\n  217: '#ffcdb5',\r\n  117: '#6fb3ff',\r\n  118: '#6ee07a',\r\n  48: '#00a300',\r\n  57: '#2f78ff',\r\n  33: '#1e90ff',\r\n  87: '#00d7ff',\r\n  159: '#cfeeff',\r\n  208: '#ff8a00',\r\n  197: '#ff5ea6',\r\n  234: '#0e1114',\r\n  23: '#123044',\r\n  17: '#000b16',\r\n  16: '#000000',\r\n  39: '#0078ff',\r\n};\r\n\r\nfunction escapeHtml(s: string) {\r\n  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n}\r\n\r\nfunction ensurePre(container?: HTMLElement) {\r\n  const host =\r\n    container ??\r\n    (typeof document !== 'undefined'\r\n      ? document.getElementById('ascii-maze-output')\r\n      : null);\r\n  if (!host) return null;\r\n  let pre = host.querySelector('pre');\r\n  if (!pre) {\r\n    pre = document.createElement('pre');\r\n    pre.style.fontFamily = 'monospace';\r\n    pre.style.whiteSpace = 'pre';\r\n    pre.style.margin = '0';\r\n    pre.style.padding = '4px';\r\n    pre.style.fontSize = '10px';\r\n    host.appendChild(pre);\r\n  }\r\n  return pre as HTMLPreElement;\r\n}\r\n\r\n/**\r\n * Convert a string that may contain SGR ANSI sequences (\\x1b[...m) into HTML.\r\n * Supports: 0 (reset), 1 (bold), 38;5;<n> (fg), 48;5;<n> (bg), and simple color codes.\r\n */\r\nfunction ansiToHtml(input: string) {\r\n  const re = /\\x1b\\[([0-9;]*)m/g;\r\n  let out = '';\r\n  let lastIndex = 0;\r\n  let style: { color?: string; background?: string; fontWeight?: string } = {};\r\n\r\n  let match: RegExpExecArray | null;\r\n  while ((match = re.exec(input)) !== null) {\r\n    const chunk = input.substring(lastIndex, match.index);\r\n    if (chunk) {\r\n      const text = escapeHtml(chunk);\r\n      if (Object.keys(style).length) {\r\n        const css: string[] = [];\r\n        if (style.color) css.push(`color: ${style.color}`);\r\n        if (style.background) css.push(`background: ${style.background}`);\r\n        if (style.fontWeight) css.push(`font-weight: ${style.fontWeight}`);\r\n        out += `<span style=\"${css.join(';')}\">${text}</span>`;\r\n      } else {\r\n        out += text;\r\n      }\r\n    }\r\n\r\n    const codes = match[1]\r\n      .split(';')\r\n      .filter((c) => c.length)\r\n      .map((c) => parseInt(c, 10));\r\n    if (codes.length === 0) {\r\n      // CSI m with no codes = reset\r\n      style = {};\r\n    } else {\r\n      // Process codes sequentially\r\n      for (let i = 0; i < codes.length; i++) {\r\n        const c = codes[i];\r\n        if (c === 0) {\r\n          style = {};\r\n        } else if (c === 1) {\r\n          style.fontWeight = '700';\r\n        } else if (c === 22) {\r\n          delete style.fontWeight;\r\n        } else if (c === 38 && codes[i + 1] === 5) {\r\n          const n = codes[i + 2];\r\n          if (typeof n === 'number' && ANSI_256_MAP[n])\r\n            style.color = ANSI_256_MAP[n];\r\n          i += 2;\r\n        } else if (c === 48 && codes[i + 1] === 5) {\r\n          const n = codes[i + 2];\r\n          if (typeof n === 'number' && ANSI_256_MAP[n])\r\n            style.background = ANSI_256_MAP[n];\r\n          i += 2;\r\n        } else if (c >= 30 && c <= 37) {\r\n          // basic colors, map a few\r\n          const basic = [\r\n            '#000000',\r\n            '#800000',\r\n            '#008000',\r\n            '#808000',\r\n            '#000080',\r\n            '#800080',\r\n            '#008080',\r\n            '#c0c0c0',\r\n          ];\r\n          style.color = basic[c - 30];\r\n        } else if (c >= 90 && c <= 97) {\r\n          const bright = [\r\n            '#808080',\r\n            '#ff0000',\r\n            '#00ff00',\r\n            '#ffff00',\r\n            '#0000ff',\r\n            '#ff00ff',\r\n            '#00ffff',\r\n            '#ffffff',\r\n          ];\r\n          style.color = bright[c - 90];\r\n        } else if (c === 39) {\r\n          delete style.color;\r\n        } else if (c === 49) {\r\n          delete style.background;\r\n        }\r\n      }\r\n    }\r\n\r\n    lastIndex = re.lastIndex;\r\n  }\r\n\r\n  // Trailing text\r\n  if (lastIndex < input.length) {\r\n    const tail = escapeHtml(input.substring(lastIndex));\r\n    if (Object.keys(style).length) {\r\n      const css: string[] = [];\r\n      if (style.color) css.push(`color: ${style.color}`);\r\n      if (style.background) css.push(`background: ${style.background}`);\r\n      if (style.fontWeight) css.push(`font-weight: ${style.fontWeight}`);\r\n      out += `<span style=\"${css.join(';')}\">${tail}</span>`;\r\n    } else {\r\n      out += tail;\r\n    }\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\nexport function createBrowserLogger(container?: HTMLElement) {\r\n  return (...args: any[]) => {\r\n    // Resolve (or recreate) the <pre> element each time because the clearer\r\n    // may remove it (clearFunction sets container.innerHTML = ''), leaving\r\n    // a stale reference otherwise.\r\n    const pre = ensurePre(container);\r\n\r\n    // Detect an optional options object in the last argument. Consumers can\r\n    // pass `{ prepend: true }` to indicate the text should be added at the\r\n    // top of the log (useful for archive views where newest entries appear\r\n    // above older ones).\r\n    let opts: any = undefined;\r\n    if (\r\n      args.length &&\r\n      typeof args[args.length - 1] === 'object' &&\r\n      args[args.length - 1] &&\r\n      'prepend' in args[args.length - 1]\r\n    ) {\r\n      opts = args[args.length - 1];\r\n      args = args.slice(0, -1);\r\n    }\r\n\r\n    const text = args\r\n      .map((a) => (typeof a === 'string' ? a : JSON.stringify(a)))\r\n      .join(' ');\r\n    // Convert ANSI -> HTML and preserve explicit newlines as <br/> so the\r\n    // boxed ASCII layout remains intact inside the pre element.\r\n    const html = ansiToHtml(text).replace(/\\n/g, '<br/>') + '<br/>';\r\n    if (!pre) return;\r\n\r\n    if (opts && opts.prepend) {\r\n      // Put new content above existing content so newest entries appear first.\r\n      pre.innerHTML = html + pre.innerHTML;\r\n      // Scroll to top so the newly prepended item is visible\r\n      pre.scrollTop = 0;\r\n    } else {\r\n      // Default behavior: append at the bottom\r\n      pre.innerHTML += html;\r\n      // Keep pre scrolled to bottom\r\n      pre.scrollTop = pre.scrollHeight;\r\n    }\r\n  };\r\n}\r\n", "/**\r\n * Utility class for maze logic and encoding.\r\n * Provides static methods for encoding, position finding, BFS, and progress calculation.\r\n */\r\nexport class MazeUtils {\r\n  /**\r\n   * Converts an ASCII/Unicode maze (array of strings) into a 2D numeric array for processing by the agent.\r\n   *\r\n   * Encoding:\r\n   *   '#' = -1 (wall/obstacle)\r\n   *   Box drawing characters (\u2550,\u2551,\u2554,\u2557,\u255A,\u255D,\u2560,\u2563,\u2566,\u2569,\u256C) = -1 (wall/obstacle)\r\n   *   '.' = 0 (open path)\r\n   *   'E' = 1 (exit/goal)\r\n   *   'S' = 2 (start position)\r\n   *   any other character = 0 (treated as open path)\r\n   *\r\n   * @param asciiMaze - Array of strings representing the maze.\r\n   * @returns 2D array of numbers encoding the maze elements.\r\n   */\r\n  static encodeMaze(asciiMaze: string[]): number[][] {\r\n    /**\r\n     * Set of characters representing walls in the maze.\r\n     * Includes box-drawing and hash characters.\r\n     */\r\n    const wallChars = new Set([\r\n      '#',\r\n      '\u2550',\r\n      '\u2551',\r\n      '\u2554',\r\n      '\u2557',\r\n      '\u255A',\r\n      '\u255D',\r\n      '\u2560',\r\n      '\u2563',\r\n      '\u2566',\r\n      '\u2569',\r\n      '\u256C',\r\n    ]);\r\n    // Map each row and cell to its numeric encoding\r\n    return asciiMaze.map((row) =>\r\n      [...row].map((cell) => {\r\n        if (wallChars.has(cell)) return -1;\r\n        switch (cell) {\r\n          case '.':\r\n            return 0;\r\n          case 'E':\r\n            return 1;\r\n          case 'S':\r\n            return 2;\r\n          default:\r\n            return 0;\r\n        }\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Finds the (x, y) position of a given character in the ASCII maze.\r\n   * @param asciiMaze - Array of strings representing the maze.\r\n   * @param char - Character to find (e.g., 'S' for start, 'E' for exit).\r\n   * @returns [x, y] coordinates of the character.\r\n   * @throws Error if the character is not found in the maze.\r\n   */\r\n  static findPosition(asciiMaze: string[], char: string): [number, number] {\r\n    // Search each row for the target character\r\n    for (let y = 0; y < asciiMaze.length; y++) {\r\n      /**\r\n       * Index of the character in the current row, or -1 if not found.\r\n       */\r\n      const x = asciiMaze[y].indexOf(char);\r\n      if (x !== -1) return [x, y];\r\n    }\r\n    throw new Error(`Character ${char} not found in maze`);\r\n  }\r\n\r\n  /**\r\n   * Computes the shortest path distance between two points in the maze using BFS.\r\n   * Returns Infinity if no path exists.\r\n   * @param encodedMaze - 2D array representation of the maze.\r\n   * @param start - [x, y] start position.\r\n   * @param goal - [x, y] goal position.\r\n   * @returns Shortest path length (number of steps), or Infinity if unreachable.\r\n   */\r\n  static bfsDistance(\r\n    encodedMaze: number[][],\r\n    start: [number, number],\r\n    goal: [number, number]\r\n  ): number {\r\n    /**\r\n     * Goal coordinates\r\n     */\r\n    const [gx, gy] = goal;\r\n    // If the goal is a wall, return Infinity\r\n    if (encodedMaze[gy][gx] === -1) return Infinity;\r\n    /**\r\n     * BFS queue: each entry is [[x, y], distance]\r\n     */\r\n    const queue: Array<[[number, number], number]> = [[start, 0]];\r\n    /**\r\n     * Set of visited positions (as string keys)\r\n     */\r\n    const visited = new Set<string>();\r\n    /**\r\n     * Helper to create a unique key for a position\r\n     */\r\n    const key = ([x, y]: [number, number]) => `${x},${y}`;\r\n    visited.add(key(start));\r\n    /**\r\n     * Possible movement directions (N, E, S, W)\r\n     */\r\n    const directions = [\r\n      [0, -1],\r\n      [1, 0],\r\n      [0, 1],\r\n      [-1, 0],\r\n    ];\r\n    // BFS loop\r\n    while (queue.length > 0) {\r\n      const [[x, y], dist] = queue.shift()!;\r\n      if (x === gx && y === gy) return dist;\r\n      for (const [dx, dy] of directions) {\r\n        const nx = x + dx;\r\n        const ny = y + dy;\r\n        if (\r\n          nx >= 0 &&\r\n          ny >= 0 &&\r\n          ny < encodedMaze.length &&\r\n          nx < encodedMaze[0].length &&\r\n          encodedMaze[ny][nx] !== -1 &&\r\n          !visited.has(key([nx, ny]))\r\n        ) {\r\n          visited.add(key([nx, ny]));\r\n          queue.push([[nx, ny], dist + 1]);\r\n        }\r\n      }\r\n    }\r\n    return Infinity;\r\n  }\r\n\r\n  /**\r\n   * Calculates the agent's progress toward the exit as a percentage.\r\n   * Progress is measured as the proportion of the shortest path covered from start to exit.\r\n   * @param encodedMaze - 2D array representation of the maze.\r\n   * @param currentPos - [x, y] current agent position.\r\n   * @param startPos - [x, y] start position.\r\n   * @param exitPos - [x, y] exit position.\r\n   * @returns Progress percentage (0-100).\r\n   */\r\n  static calculateProgress(\r\n    encodedMaze: number[][],\r\n    currentPos: [number, number],\r\n    startPos: [number, number],\r\n    exitPos: [number, number]\r\n  ): number {\r\n    /**\r\n     * Total shortest path distance from start to exit\r\n     */\r\n    const totalDistance = MazeUtils.bfsDistance(encodedMaze, startPos, exitPos);\r\n    if (totalDistance === 0) return 100;\r\n    /**\r\n     * Remaining shortest path distance from current position to exit\r\n     */\r\n    const remainingDistance = MazeUtils.bfsDistance(\r\n      encodedMaze,\r\n      currentPos,\r\n      exitPos\r\n    );\r\n    // Calculate progress as a percentage\r\n    return Math.min(\r\n      100,\r\n      Math.max(\r\n        0,\r\n        Math.round(((totalDistance - remainingDistance) / totalDistance) * 100)\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Calculates progress using a precomputed distance map (goal-centric BFS distances).\r\n   * Faster alternative to repeated BFS calls. Distance map holds distance from each cell TO the exit (goal).\r\n   * @param distanceMap - 2D array of distances (Infinity for walls/unreachable)\r\n   * @param currentPos - Agent current position [x,y]\r\n   * @param startPos - Start position [x,y]\r\n   * @returns Progress percentage (0-100)\r\n   */\r\n  static calculateProgressFromDistanceMap(\r\n    distanceMap: number[][],\r\n    currentPos: [number, number],\r\n    startPos: [number, number]\r\n  ): number {\r\n    /**\r\n     * Start and current coordinates\r\n     */\r\n    const [sx, sy] = startPos;\r\n    const [cx, cy] = currentPos;\r\n    /**\r\n     * Total distance from start to goal (from distance map)\r\n     */\r\n    const totalDistance = distanceMap[sy]?.[sx];\r\n    /**\r\n     * Remaining distance from current position to goal (from distance map)\r\n     */\r\n    const remaining = distanceMap[cy]?.[cx];\r\n    if (\r\n      totalDistance == null ||\r\n      remaining == null ||\r\n      !isFinite(totalDistance) ||\r\n      totalDistance <= 0\r\n    )\r\n      return 0;\r\n    // Calculate progress as a percentage\r\n    const prog = ((totalDistance - remaining) / totalDistance) * 100;\r\n    return Math.min(100, Math.max(0, Math.round(prog)));\r\n  }\r\n\r\n  /**\r\n   * Builds a full distance map (Manhattan shortest path lengths via BFS) from a goal cell to every reachable cell.\r\n   * Walls are marked as Infinity. Unreachable cells remain Infinity.\r\n   * @param encodedMaze - 2D maze encoding\r\n   * @param goal - [x,y] goal position (typically exit)\r\n   */\r\n  static buildDistanceMap(\r\n    encodedMaze: number[][],\r\n    goal: [number, number]\r\n  ): number[][] {\r\n    /**\r\n     * Maze height and width\r\n     */\r\n    const height = encodedMaze.length;\r\n    const width = encodedMaze[0].length;\r\n    /**\r\n     * Distance map (initialized to Infinity)\r\n     */\r\n    const dist: number[][] = Array.from({ length: height }, () =>\r\n      Array(width).fill(Infinity)\r\n    );\r\n    /**\r\n     * Goal coordinates\r\n     */\r\n    const [gx, gy] = goal;\r\n    if (encodedMaze[gy][gx] === -1) return dist;\r\n    /**\r\n     * BFS queue for distance propagation\r\n     */\r\n    const q: Array<[number, number]> = [[gx, gy]];\r\n    dist[gy][gx] = 0;\r\n    /**\r\n     * Possible movement directions (N, E, S, W)\r\n     */\r\n    const dirs = [\r\n      [0, -1],\r\n      [1, 0],\r\n      [0, 1],\r\n      [-1, 0],\r\n    ];\r\n    // BFS loop to fill distance map\r\n    while (q.length) {\r\n      const [x, y] = q.shift()!;\r\n      const d = dist[y][x];\r\n      for (const [dx, dy] of dirs) {\r\n        const nx = x + dx;\r\n        const ny = y + dy;\r\n        if (\r\n          nx >= 0 &&\r\n          ny >= 0 &&\r\n          ny < height &&\r\n          nx < width &&\r\n          encodedMaze[ny][nx] !== -1 &&\r\n          dist[ny][nx] === Infinity\r\n        ) {\r\n          dist[ny][nx] = d + 1;\r\n          q.push([nx, ny]);\r\n        }\r\n      }\r\n    }\r\n    return dist;\r\n  }\r\n}\r\n", "/**\r\n * ANSI color codes for maze visualization in the terminal.\r\n * These codes use a TRON-inspired color palette with vibrant cyberspace blues,\r\n * electric whites, and neon accents for a futuristic digital look.\r\n *\r\n * The palette features the iconic TRON colors that work together to create\r\n * the feeling of being inside a digital world or computer system.\r\n *\r\n * All color codes are provided as string escape sequences for use in terminal output.\r\n */\r\nexport const colors = {\r\n  // Basic formatting\r\n  reset: '\\x1b[0m', // Reset all attributes\r\n  bright: '\\x1b[1m', // Bright/bold text\r\n  dim: '\\x1b[2m', // Dim text\r\n\r\n  // Neon foreground colors (expanded palette)\r\n  neonPink: '\\x1b[38;5;205m', // Neon pink\r\n  neonPurple: '\\x1b[38;5;93m', // Neon purple\r\n  neonLime: '\\x1b[38;5;154m', // Neon lime green\r\n  neonAqua: '\\x1b[38;5;51m', // Neon aqua\r\n  neonYellow: '\\x1b[38;5;226m', // Neon yellow\r\n  neonOrange: '\\x1b[38;5;214m', // Neon orange (brighter)\r\n  neonRed: '\\x1b[38;5;196m', // Neon red\r\n  neonGreen: '\\x1b[38;5;46m', // Neon green\r\n  neonSky: '\\x1b[38;5;123m', // Neon sky blue\r\n  neonViolet: '\\x1b[38;5;177m', // Neon violet\r\n  neonTurquoise: '\\x1b[38;5;80m', // Neon turquoise\r\n  neonMint: '\\x1b[38;5;121m', // Neon mint\r\n  neonCoral: '\\x1b[38;5;203m', // Neon coral\r\n  neonIndigo: '\\x1b[38;5;99m', // Neon indigo\r\n  neonTeal: '\\x1b[38;5;44m', // Neon teal\r\n  neonGold: '\\x1b[38;5;220m', // Neon gold\r\n  neonSilver: '\\x1b[38;5;250m', // Neon silver\r\n  neonBlue: '\\x1b[38;5;45m', // Neon blue (extra)\r\n  neonMagenta: '\\x1b[38;5;201m', // Neon magenta (extra)\r\n  neonCyan: '\\x1b[38;5;87m', // Neon cyan (extra)\r\n  neonWhite: '\\x1b[38;5;231m', // Neon white (brightest)\r\n  neonRose: '\\x1b[38;5;218m', // Neon rose\r\n  neonPeach: '\\x1b[38;5;217m', // Neon peach\r\n  neonAzure: '\\x1b[38;5;117m', // Neon azure\r\n  neonChartreuse: '\\x1b[38;5;118m', // Neon chartreuse\r\n  neonSpring: '\\x1b[38;5;48m', // Neon spring green\r\n  neonAmber: '\\x1b[38;5;214m', // Neon amber (duplicate of orange, for clarity)\r\n  neonFuchsia: '\\x1b[38;5;207m', // Neon fuchsia\r\n\r\n  // TRON primary colors (foreground)\r\n  blueCore: '\\x1b[38;5;39m', // Primary TRON blue\r\n  cyanNeon: '\\x1b[38;5;87m', // Electric cyan\r\n  blueNeon: '\\x1b[38;5;45m', // Bright neon blue\r\n  whiteNeon: '\\x1b[38;5;159m', // Electric white-blue\r\n  orangeNeon: '\\x1b[38;5;208m', // TRON orange (for contrast)\r\n  magentaNeon: '\\x1b[38;5;201m', // Digital magenta\r\n\r\n  // Base colors (foreground)\r\n  red: '\\x1b[38;5;197m', // Program termination red\r\n  green: '\\x1b[38;5;118m', // User/CLU green\r\n  yellow: '\\x1b[38;5;220m', // Warning yellow\r\n  blue: '\\x1b[38;5;33m', // Deep blue\r\n  cyan: '\\x1b[38;5;51m', // Light cyan\r\n\r\n  // Neon background colors (expanded palette)\r\n  bgNeonPink: '\\x1b[48;5;205m',\r\n  bgNeonPurple: '\\x1b[48;5;93m',\r\n  bgNeonLime: '\\x1b[48;5;154m',\r\n  bgNeonAqua: '\\x1b[48;5;51m',\r\n  bgNeonYellow: '\\x1b[48;5;226m',\r\n  bgNeonOrange: '\\x1b[48;5;214m',\r\n  bgNeonRed: '\\x1b[48;5;196m',\r\n  bgNeonGreen: '\\x1b[48;5;46m',\r\n  bgNeonSky: '\\x1b[48;5;123m',\r\n  bgNeonViolet: '\\x1b[48;5;177m',\r\n  bgNeonTurquoise: '\\x1b[48;5;80m',\r\n  bgNeonMint: '\\x1b[48;5;121m',\r\n  bgNeonCoral: '\\x1b[48;5;203m',\r\n  bgNeonIndigo: '\\x1b[48;5;99m',\r\n  bgNeonTeal: '\\x1b[48;5;44m',\r\n  bgNeonGold: '\\x1b[48;5;220m',\r\n  bgNeonSilver: '\\x1b[48;5;250m',\r\n  bgNeonBlue: '\\x1b[48;5;45m', // Neon blue background (extra)\r\n  bgNeonMagenta: '\\x1b[48;5;201m', // Neon magenta background (extra)\r\n  bgNeonCyan: '\\x1b[48;5;87m', // Neon cyan background (extra)\r\n  bgNeonWhite: '\\x1b[48;5;231m', // Neon white background (brightest)\r\n  bgNeonRose: '\\x1b[48;5;218m', // Neon rose background\r\n  bgNeonPeach: '\\x1b[48;5;217m', // Neon peach background\r\n  bgNeonAzure: '\\x1b[48;5;117m', // Neon azure background\r\n  bgNeonChartreuse: '\\x1b[48;5;118m', // Neon chartreuse background\r\n  bgNeonSpring: '\\x1b[48;5;48m', // Neon spring green background\r\n  bgNeonAmber: '\\x1b[48;5;214m', // Neon amber background (duplicate of orange, for clarity)\r\n  bgNeonFuchsia: '\\x1b[48;5;207m', // Neon fuchsia background\r\n\r\n  // TRON background colors\r\n  bgBlueCore: '\\x1b[48;5;39m', // Primary TRON blue background\r\n  bgCyanNeon: '\\x1b[48;5;87m', // Electric cyan background (for agent)\r\n  bgBlueNeon: '\\x1b[48;5;45m', // Bright neon blue background\r\n  bgWhiteNeon: '\\x1b[48;5;159m', // Electric white-blue background\r\n  bgOrangeNeon: '\\x1b[48;5;208m', // TRON orange background\r\n  bgMagentaNeon: '\\x1b[48;5;201m', // Digital magenta background\r\n\r\n  // Common backgrounds\r\n  bgRed: '\\x1b[48;5;197m', // Program termination red background\r\n  bgGreen: '\\x1b[48;5;118m', // User/CLU green background\r\n  bgYellow: '\\x1b[48;5;220m', // Warning yellow background\r\n  bgBlue: '\\x1b[48;5;33m', // Deep blue background\r\n\r\n  // Maze-specific colors\r\n  darkWallBg: '\\x1b[48;5;17m', // Dark blue for walls\r\n  darkWallText: '\\x1b[38;5;17m', // Dark blue text for wall symbols\r\n  floorBg: '\\x1b[48;5;234m', // Almost black for empty floor\r\n  floorText: '\\x1b[38;5;234m', // Almost black text for floor symbols\r\n  gridLineBg: '\\x1b[48;5;23m', // Subtle grid line color\r\n  gridLineText: '\\x1b[38;5;23m', // Subtle grid line text\r\n\r\n  // Special highlights\r\n  bgBlack: '\\x1b[48;5;16m', // Pure black background\r\n  pureBlue: '\\x1b[38;5;57;1m', // Vibrant system blue\r\n  pureOrange: '\\x1b[38;5;214;1m', // Vibrant TRON orange (for CLU/villains)\r\n  pureGreen: '\\x1b[38;5;46;1m', // Pure green for user programs\r\n};\r\n", "/**\r\n * Network Visualization - Handles neural network visualization for terminal display\r\n *\r\n * This module contains functions for visualizing neural networks in the terminal,\r\n * providing an ASCII representation of the network architecture and activation values.\r\n *\r\n * These visualizations help in understanding:\r\n * - Network architecture (inputs, hidden layers, outputs)\r\n * - Activation patterns during maze solving\r\n * - Connection structure between layers\r\n */\r\n\r\nimport { INetwork } from './interfaces'; // Added INetwork import\r\nimport { colors } from './colors';\r\nimport { IVisualizationNode, IVisualizationConnection } from './interfaces';\r\n\r\n/**\r\n * NetworkVisualization provides static methods for visualizing neural networks in the terminal.\r\n * It includes utilities for formatting, grouping, and rendering network structure and activations.\r\n */\r\nexport class NetworkVisualization {\r\n  /**\r\n   * Pads a string to a specific width with alignment options.\r\n   *\r\n   * @param str - String to pad.\r\n   * @param width - Target width for the string.\r\n   * @param padChar - Character to use for padding (default: space).\r\n   * @param align - Alignment option ('left', 'center', or 'right').\r\n   * @returns Padded string of specified width with chosen alignment.\r\n   */\r\n  static pad(\r\n    str: string,\r\n    width: number,\r\n    padChar: string = ' ',\r\n    align: 'left' | 'center' | 'right' = 'center'\r\n  ): string {\r\n    str = str ?? '';\r\n    const len = str.replace(/\\x1b\\[[0-9;]*m/g, '').length; // Account for ANSI color codes\r\n    if (len >= width) return str;\r\n\r\n    const padLen = width - len;\r\n    if (align === 'left') return str + padChar.repeat(padLen);\r\n    if (align === 'right') return padChar.repeat(padLen) + str;\r\n\r\n    const left = Math.floor(padLen / 2);\r\n    const right = padLen - left;\r\n    return padChar.repeat(left) + str + padChar.repeat(right);\r\n  }\r\n\r\n  /**\r\n   * Gets activation value from a node, with safety checks.\r\n   * For output nodes, ensures values are properly clamped between 0 and 1.\r\n   *\r\n   * @param node - Neural network node object.\r\n   * @returns Cleaned and normalized activation value.\r\n   */\r\n  static getNodeValue(node: any): number {\r\n    if (\r\n      typeof node.activation === 'number' &&\r\n      isFinite(node.activation) &&\r\n      !isNaN(node.activation)\r\n    ) {\r\n      // For output nodes, clamp between 0 and 1 for proper display\r\n      if (node.type === 'output') {\r\n        return Math.max(0, Math.min(1, node.activation));\r\n      }\r\n      // For other node types, allow a wider range but still cap for display\r\n      return Math.max(-999, Math.min(999, node.activation));\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Gets the appropriate color for an activation value based on its range.\r\n   * Uses a TRON-inspired color palette for activation values.\r\n   *\r\n   * @param value - Activation value to colorize.\r\n   * @returns ANSI color code for the value.\r\n   */\r\n  static getActivationColor(value: number): string {\r\n    // Use TRON-inspired color palette for activation values\r\n    if (value >= 2.0) return colors.bgOrangeNeon + colors.bright; // Very high positive\r\n    if (value >= 1.0) return colors.orangeNeon; // High positive\r\n    if (value >= 0.5) return colors.cyanNeon; // Medium positive\r\n    if (value >= 0.1) return colors.neonGreen; // Low positive\r\n    if (value >= -0.1) return colors.whiteNeon; // Near zero\r\n    if (value >= -0.5) return colors.blue; // Low negative\r\n    if (value >= -1.0) return colors.blueCore; // Medium negative\r\n    if (value >= -2.0) return colors.bgNeonAqua + colors.bright; // High negative\r\n    return colors.bgNeonViolet + colors.neonSilver; // Very high negative\r\n  }\r\n\r\n  /**\r\n   * Formats a numeric value for display with color based on its value.\r\n   *\r\n   * @param v - Numeric value to format.\r\n   * @returns Colorized string representation of the value.\r\n   */\r\n  static fmtColoredValue(v: number): string {\r\n    if (typeof v !== 'number' || isNaN(v) || !isFinite(v)) return ' 0.000';\r\n\r\n    const color = NetworkVisualization.getActivationColor(v);\r\n    let formattedValue;\r\n\r\n    formattedValue = (v >= 0 ? ' ' : '') + v.toFixed(6);\r\n\r\n    return color + formattedValue + colors.reset;\r\n  }\r\n\r\n  /**\r\n   * Groups hidden nodes into layers based on their connections.\r\n   *\r\n   * @param inputNodes - Array of input nodes.\r\n   * @param hiddenNodes - Array of hidden nodes.\r\n   * @param outputNodes - Array of output nodes.\r\n   * @returns Array of hidden node arrays, each representing a layer.\r\n   */\r\n  static groupHiddenByLayer(\r\n    inputNodes: any[],\r\n    hiddenNodes: any[],\r\n    outputNodes: any[]\r\n  ): any[][] {\r\n    if (hiddenNodes.length === 0) return [];\r\n\r\n    let layers: any[][] = [];\r\n    let prevLayer = inputNodes;\r\n    let remaining = [...hiddenNodes];\r\n\r\n    while (remaining.length > 0) {\r\n      const currentLayer = remaining.filter(\r\n        (h) =>\r\n          h.connections &&\r\n          h.connections.in &&\r\n          h.connections.in.length > 0 &&\r\n          h.connections.in.every((conn: any) => prevLayer.includes(conn.from))\r\n      );\r\n\r\n      if (currentLayer.length === 0) {\r\n        layers.push(remaining);\r\n        break;\r\n      }\r\n\r\n      layers.push(currentLayer);\r\n      prevLayer = currentLayer;\r\n      remaining = remaining.filter((h) => !currentLayer.includes(h));\r\n    }\r\n\r\n    return layers;\r\n  }\r\n\r\n  /**\r\n   * Groups nodes by their activation values to create meaningful average representations.\r\n   * Creates more granular grouping based on activation ranges.\r\n   *\r\n   * @param nodes - Array of neural network nodes to group.\r\n   * @returns Object containing groups of nodes and corresponding labels.\r\n   */\r\n  static groupNodesByActivation(\r\n    nodes: any[]\r\n  ): {\r\n    groups: any[][];\r\n    labels: string[];\r\n  } {\r\n    // Calculate activation values\r\n    /**\r\n     * Activation values for each node, used for grouping.\r\n     */\r\n    const activations = nodes.map((node) =>\r\n      NetworkVisualization.getNodeValue(node)\r\n    );\r\n\r\n    /**\r\n     * Activation ranges for grouping nodes by value.\r\n     */\r\n    const ranges = [\r\n      { min: 2.0, max: Infinity, label: 'v-high+' },\r\n      { min: 1.0, max: 2.0, label: 'high+' },\r\n      { min: 0.5, max: 1.0, label: 'mid+' },\r\n      { min: 0.1, max: 0.5, label: 'low+' },\r\n      { min: -0.1, max: 0.1, label: 'zero\u00B1' },\r\n      { min: -0.5, max: -0.1, label: 'low-' },\r\n      { min: -1.0, max: -0.5, label: 'mid-' },\r\n      { min: -2.0, max: -1.0, label: 'high-' },\r\n      { min: -Infinity, max: -2.0, label: 'v-high-' },\r\n    ];\r\n\r\n    /**\r\n     * Arrays to hold groups of nodes and their labels.\r\n     */\r\n    const groups: any[][] = [];\r\n    const labels: string[] = [];\r\n\r\n    // Group nodes by activation ranges\r\n    for (const range of ranges) {\r\n      const nodesInRange = nodes.filter(\r\n        (_, i) => activations[i] >= range.min && activations[i] < range.max\r\n      );\r\n\r\n      if (nodesInRange.length > 0) {\r\n        groups.push(nodesInRange);\r\n        labels.push(range.label);\r\n      }\r\n    }\r\n\r\n    return { groups, labels };\r\n  }\r\n\r\n  /**\r\n   * Prepares hidden layers for display, condensing large layers\r\n   * to show all nodes as averages with meaningful distribution.\r\n   *\r\n   * @param hiddenLayers - Array of hidden layer node arrays.\r\n   * @param maxVisiblePerLayer - Maximum number of nodes to display per layer.\r\n   * @returns Object containing display-ready layers and metrics.\r\n   */\r\n  static prepareHiddenLayersForDisplay(\r\n    hiddenLayers: any[][],\r\n    maxVisiblePerLayer: number = 10\r\n  ): {\r\n    displayLayers: any[][];\r\n    layerDisplayCounts: number[];\r\n    averageNodes: { [key: string]: { avgValue: number; count: number } };\r\n  } {\r\n    /**\r\n     * Maximum number of nodes to display per layer (rest are averaged).\r\n     */\r\n    const MAX_VISIBLE = maxVisiblePerLayer;\r\n\r\n    /**\r\n     * Stores average node info for each group.\r\n     */\r\n    const averageNodes: {\r\n      [key: string]: { avgValue: number; count: number };\r\n    } = {};\r\n\r\n    /**\r\n     * Arrays for display-ready layers and their display counts.\r\n     */\r\n    const displayLayers: any[][] = [];\r\n    const layerDisplayCounts: number[] = [];\r\n\r\n    hiddenLayers.forEach((layer, layerIdx) => {\r\n      if (layer.length <= MAX_VISIBLE) {\r\n        // If layer is small enough, show all nodes\r\n        displayLayers.push([...layer]);\r\n        layerDisplayCounts.push(layer.length);\r\n      } else {\r\n        // For large layers, show all nodes as averages to better represent distribution\r\n\r\n        // Group nodes by activation values\r\n        const { groups, labels } = NetworkVisualization.groupNodesByActivation(\r\n          layer\r\n        );\r\n\r\n        // If we have too many groups, we need to merge some to fit in MAX_VISIBLE\r\n        let finalGroups = groups;\r\n        let finalLabels = labels;\r\n\r\n        if (groups.length > MAX_VISIBLE) {\r\n          // We'll prioritize groups with more nodes and merge smaller ones\r\n          const rankedGroups = groups\r\n            .map((g, i) => ({\r\n              group: g,\r\n              label: labels[i],\r\n              size: g.length,\r\n            }))\r\n            .sort((a, b) => b.size - a.size);\r\n\r\n          // Take top MAX_VISIBLE-1 groups\r\n          const topGroups = rankedGroups.slice(0, MAX_VISIBLE - 1);\r\n\r\n          // Combine all remaining small groups\r\n          const remainingGroups = rankedGroups.slice(MAX_VISIBLE - 1);\r\n          const mergedGroup = remainingGroups.reduce(\r\n            (acc, curr) => {\r\n              acc.group = [...acc.group, ...curr.group];\r\n              return acc;\r\n            },\r\n            { group: [], label: 'other\u00B1', size: 0 }\r\n          );\r\n\r\n          if (mergedGroup.group.length > 0) {\r\n            topGroups.push(mergedGroup);\r\n          }\r\n\r\n          // Sort back to original order by activation range (assumed by label)\r\n          topGroups.sort((a, b) => {\r\n            // Sort by activation range - very high+ first, very high- last\r\n            const aIsNegative = a.label.includes('-');\r\n            const bIsNegative = b.label.includes('-');\r\n\r\n            if (aIsNegative && !bIsNegative) return 1;\r\n            if (!aIsNegative && bIsNegative) return -1;\r\n\r\n            if (a.label.includes('v-') && !b.label.includes('v-'))\r\n              return aIsNegative ? 1 : -1;\r\n            if (!a.label.includes('v-') && b.label.includes('v-'))\r\n              return aIsNegative ? -1 : 1;\r\n\r\n            if (a.label.includes('high') && !b.label.includes('high'))\r\n              return aIsNegative ? 1 : -1;\r\n            if (!a.label.includes('high') && b.label.includes('high'))\r\n              return aIsNegative ? -1 : 1;\r\n\r\n            return 0;\r\n          });\r\n\r\n          finalGroups = topGroups.map((g) => g.group);\r\n          finalLabels = topGroups.map((g) => g.label);\r\n        }\r\n\r\n        // Create \"virtual\" average nodes for each group\r\n        const avgNodes = finalGroups.map((group, groupIdx) => {\r\n          const avgKey = `layer${layerIdx}-avg-${groupIdx}`;\r\n          const sum = group.reduce(\r\n            (acc: number, node: any) =>\r\n              acc + NetworkVisualization.getNodeValue(node),\r\n            0\r\n          );\r\n          const avgValue = group.length > 0 ? sum / group.length : 0;\r\n\r\n          // Store average node info\r\n          averageNodes[avgKey] = {\r\n            avgValue,\r\n            count: group.length,\r\n          };\r\n\r\n          // Create a \"virtual\" average node to display\r\n          return {\r\n            id: -1 * (layerIdx * 1000 + groupIdx),\r\n            uuid: avgKey,\r\n            type: 'hidden',\r\n            activation: avgValue,\r\n            isAverage: true,\r\n            avgCount: group.length,\r\n            label: finalLabels[groupIdx],\r\n          };\r\n        });\r\n\r\n        // Add only the average nodes\r\n        displayLayers.push(avgNodes);\r\n        layerDisplayCounts.push(avgNodes.length);\r\n      }\r\n    });\r\n\r\n    return { displayLayers, layerDisplayCounts, averageNodes };\r\n  }\r\n\r\n  /**\r\n   * Utility to create a visualization node from a neataptic node.\r\n   *\r\n   * @param node - Neural network node object.\r\n   * @param index - Index of the node in the network.\r\n   * @returns Visualization node object.\r\n   */\r\n  static toVisualizationNode(node: any, index: number): IVisualizationNode {\r\n    // Use node.index if available, else fallback to array index\r\n    const id = typeof node.index === 'number' ? node.index : index;\r\n    return {\r\n      id,\r\n      uuid: String(id),\r\n      type: node.type,\r\n      activation: node.activation,\r\n      bias: node.bias,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Visualizes a neural network's structure and activations in ASCII format.\r\n   *\r\n   * Creates a comprehensive terminal-friendly visualization showing:\r\n   * - Network architecture with layers\r\n   * - Node activation values with color coding\r\n   * - Connection counts between layers\r\n   * - Condensed representation of large hidden layers\r\n   *\r\n   * @param network - The neural network to visualize.\r\n   * @returns String containing the ASCII visualization.\r\n   */\r\n  static visualizeNetworkSummary(network: INetwork): string {\r\n    /**\r\n     * Visualization constants:\r\n     * - ARROW: ASCII arrow between layers\r\n     * - ARROW_WIDTH: width of the arrow string\r\n     * - TOTAL_WIDTH: total width of the visualization\r\n     */\r\n    const ARROW = '  \u2500\u2500\u25B6  ';\r\n    const ARROW_WIDTH = ARROW.length;\r\n    const TOTAL_WIDTH = 150; // Width of the entire visualization\r\n\r\n    /**\r\n     * Determine input count dynamically (inputs + constants).\r\n     * Fallback to 18 if not detected (for legacy schemas).\r\n     */\r\n    const detectedInputNodes = (network.nodes || []).filter(\r\n      (n: any) => n.type === 'input' || n.type === 'constant'\r\n    );\r\n    const INPUT_COUNT = detectedInputNodes.length || 18; // fallback to expected 18 with memory inputs\r\n\r\n    /**\r\n     * Number of output nodes (hardcoded for maze solver: N, E, S, W).\r\n     */\r\n    const OUTPUT_COUNT = 4;\r\n\r\n    // Extract nodes from network\r\n    const nodes = network.nodes || [];\r\n\r\n    /**\r\n     * Arrays of input, output, and hidden nodes for visualization.\r\n     */\r\n    const inputNodes: IVisualizationNode[] = nodes\r\n      .filter((n) => n.type === 'input' || n.type === 'constant')\r\n      .map(NetworkVisualization.toVisualizationNode);\r\n    const outputNodes: IVisualizationNode[] = nodes\r\n      .filter((n) => n.type === 'output')\r\n      .map(NetworkVisualization.toVisualizationNode);\r\n    const hiddenNodesRaw: IVisualizationNode[] = nodes\r\n      .filter((n) => n.type === 'hidden')\r\n      .map(NetworkVisualization.toVisualizationNode);\r\n\r\n    /**\r\n     * Group hidden nodes into layers for visualization.\r\n     */\r\n    const hiddenLayers = NetworkVisualization.groupHiddenByLayer(\r\n      inputNodes,\r\n      hiddenNodesRaw,\r\n      outputNodes\r\n    );\r\n    const numHiddenLayers = hiddenLayers.length;\r\n\r\n    /**\r\n     * Prepare hidden layers for display (condensing large layers to averages).\r\n     */\r\n    const {\r\n      displayLayers,\r\n      layerDisplayCounts,\r\n      averageNodes,\r\n    } = NetworkVisualization.prepareHiddenLayersForDisplay(hiddenLayers);\r\n\r\n    /**\r\n     * Map connections using node index as unique identifier for visualization.\r\n     */\r\n    const connections: IVisualizationConnection[] = (\r\n      network.connections || []\r\n    ).map((conn: any) => ({\r\n      weight: conn.weight,\r\n      fromUUID: String(conn.from.index), // Use .index directly as per INodeStruct\r\n      toUUID: String(conn.to.index), // Use .index directly as per INodeStruct\r\n      gaterUUID: conn.gater ? String(conn.gater.index) : null, // Use .index directly\r\n      enabled: typeof conn.enabled === 'boolean' ? conn.enabled : true,\r\n    }));\r\n\r\n    /**\r\n     * Calculate connection counts between layers for summary display.\r\n     * connectionCounts[i] = number of connections from layer i to i+1\r\n     */\r\n    const connectionCounts: number[] = [];\r\n\r\n    // Count input \u2192 first hidden (or output if no hidden)\r\n    let firstCount = 0;\r\n    const firstTargetLayer =\r\n      hiddenLayers.length > 0 ? hiddenLayers[0] : outputNodes;\r\n    for (const conn of network.connections || []) {\r\n      if (\r\n        inputNodes.some((n) => n.id === conn.from.index) &&\r\n        firstTargetLayer.some((n) => n.id === conn.to.index)\r\n      ) {\r\n        firstCount++;\r\n      }\r\n    }\r\n    connectionCounts.push(firstCount);\r\n\r\n    // Count between hidden layers\r\n    for (let i = 0; i < hiddenLayers.length - 1; i++) {\r\n      let count = 0;\r\n      for (const conn of network.connections || []) {\r\n        if (\r\n          hiddenLayers[i].some((n) => n.id === conn.from.index) &&\r\n          hiddenLayers[i + 1].some((n) => n.id === conn.to.index)\r\n        ) {\r\n          count++;\r\n        }\r\n      }\r\n      connectionCounts.push(count);\r\n    }\r\n\r\n    // Count last hidden \u2192 output\r\n    if (hiddenLayers.length > 0) {\r\n      let lastCount = 0;\r\n      for (const conn of network.connections || []) {\r\n        if (\r\n          hiddenLayers[hiddenLayers.length - 1].some(\r\n            (n) => n.id === conn.from.index\r\n          ) &&\r\n          outputNodes.some((n) => n.id === conn.to.index)\r\n        ) {\r\n          lastCount++;\r\n        }\r\n      }\r\n      connectionCounts.push(lastCount);\r\n    }\r\n\r\n    // --- Layer/connection summary footer ---\r\n\r\n    /**\r\n     * Layout calculations for columns and arrows.\r\n     * - numLayers: total number of layers (input + hidden + output)\r\n     * - numArrows: number of arrows between layers\r\n     * - availableWidth: width for all columns\r\n     * - columnWidth: width of each column\r\n     */\r\n    const numLayers = 2 + numHiddenLayers; // input + hidden + output\r\n    const numArrows = numLayers - 1;\r\n    const availableWidth = TOTAL_WIDTH - numArrows * ARROW_WIDTH;\r\n    const columnWidth = Math.floor(availableWidth / numLayers);\r\n\r\n    /**\r\n     * Build the header row for the visualization, including layer names and connection counts.\r\n     */\r\n    let header = '';\r\n    header +=\r\n      `${colors.blueCore}\u2551` +\r\n      NetworkVisualization.pad(\r\n        `${colors.neonGreen}Input Layer [${INPUT_COUNT}]${colors.reset}`,\r\n        columnWidth - 1\r\n      );\r\n\r\n    // First arrow with connection count on the left\r\n    const firstConnCount = connectionCounts[0];\r\n    const firstArrowText = `${\r\n      colors.blueNeon\r\n    }${firstConnCount} ${ARROW.trim()}${colors.reset}`;\r\n    header += NetworkVisualization.pad(firstArrowText, ARROW_WIDTH);\r\n\r\n    // Add hidden layer headers with connection counts\r\n    for (let i = 0; i < numHiddenLayers; i++) {\r\n      header += NetworkVisualization.pad(\r\n        `${colors.cyanNeon}Hidden ${i + 1} [${hiddenLayers[i].length}]${\r\n          colors.reset\r\n        }`,\r\n        columnWidth\r\n      );\r\n\r\n      if (i < numHiddenLayers) {\r\n        // Arrow with connection count on the left\r\n        const connCount = connectionCounts[i + 1] || 0;\r\n        const arrowText = `${colors.blueNeon}${connCount} ${ARROW.trim()}${\r\n          colors.reset\r\n        }`;\r\n        header += NetworkVisualization.pad(arrowText, ARROW_WIDTH);\r\n      }\r\n    }\r\n\r\n    header +=\r\n      NetworkVisualization.pad(\r\n        `${colors.orangeNeon}Output Layer [${OUTPUT_COUNT}]${colors.reset}`,\r\n        columnWidth,\r\n        ' ',\r\n        'center'\r\n      ) + `${colors.blueCore}\u2551${colors.reset}`;\r\n\r\n    // Prepare display data for each layer\r\n    // For input nodes: Always show all detected inputs.\r\n    // Annotate first 6 (if present) with semantic labels of current minimal vision schema.\r\n    /**\r\n     * Array of input nodes to display, padded to INPUT_COUNT.\r\n     */\r\n    const inputDisplayNodes = Array(INPUT_COUNT)\r\n      .fill(null)\r\n      .map((_, i) => inputNodes[i] || { activation: 0 });\r\n\r\n    /**\r\n     * Semantic labels for the first 6 input nodes (if present).\r\n     */\r\n    const INPUT_LABELS6 = [\r\n      'compass',\r\n      'openN',\r\n      'openE',\r\n      'openS',\r\n      'openW',\r\n      'progress',\r\n    ];\r\n\r\n    /**\r\n     * Array of output nodes to display, always 4 (N, E, S, W), padded if needed.\r\n     */\r\n    const outputDisplayNodes = Array(OUTPUT_COUNT)\r\n      .fill(null)\r\n      .map((_, i) => outputNodes[i] || { activation: 0 });\r\n\r\n    /**\r\n     * Maximum number of rows needed for the visualization table.\r\n     */\r\n    const maxRows = Math.max(INPUT_COUNT, ...layerDisplayCounts, OUTPUT_COUNT);\r\n\r\n    /**\r\n     * Array to hold each row of the visualization table.\r\n     */\r\n    const rows: string[] = [];\r\n    for (let rowIdx = 0; rowIdx < maxRows; rowIdx++) {\r\n      /**\r\n       * String for the current row being built.\r\n       */\r\n      let row = '';\r\n\r\n      // Input column\r\n      if (rowIdx < INPUT_COUNT) {\r\n        /**\r\n         * Node and value for this input row.\r\n         */\r\n        const node = inputDisplayNodes[rowIdx];\r\n        const value = NetworkVisualization.getNodeValue(node);\r\n        /**\r\n         * Optional semantic label for the first 6 inputs.\r\n         */\r\n        const label = rowIdx < 6 ? INPUT_LABELS6[rowIdx] : '';\r\n        /**\r\n         * Formatted label string for display (with color if present).\r\n         */\r\n        const labelStr = label\r\n          ? ` ${colors.whiteNeon}${label}${colors.reset}`\r\n          : '';\r\n        row += NetworkVisualization.pad(\r\n          `${colors.blueCore}\u2551   ${colors.neonGreen}\u25CF${\r\n            colors.reset\r\n          }${NetworkVisualization.fmtColoredValue(value)}${labelStr}`,\r\n          columnWidth,\r\n          ' ',\r\n          'left'\r\n        );\r\n      } else {\r\n        row += NetworkVisualization.pad('', columnWidth);\r\n      }\r\n\r\n      // First arrow - calculate proportional connection counts\r\n      if (rowIdx === 0) {\r\n        /**\r\n         * For the first row, show proportional connection count (not total).\r\n         */\r\n        const totalInputs = Math.min(INPUT_COUNT, inputNodes.length);\r\n        const firstHiddenTotal = displayLayers[0]?.length || 0;\r\n\r\n        if (totalInputs > 0 && firstHiddenTotal > 0) {\r\n          /**\r\n           * Proportional number of connections for the first visible row.\r\n           */\r\n          const nodeProportion = Math.ceil(\r\n            connectionCounts[0] / Math.max(1, totalInputs)\r\n          );\r\n          row += NetworkVisualization.pad(\r\n            `${colors.blueNeon}${nodeProportion} \u2500\u2500\u25B6${colors.reset}`,\r\n            ARROW_WIDTH\r\n          );\r\n        } else {\r\n          row += NetworkVisualization.pad(\r\n            `${colors.blueNeon}${ARROW}${colors.reset}`,\r\n            ARROW_WIDTH\r\n          );\r\n        }\r\n      } else if (rowIdx < INPUT_COUNT && rowIdx < displayLayers[0]?.length) {\r\n        /**\r\n         * For input rows, show proportional connections to first hidden layer.\r\n         */\r\n        const totalInputs = Math.min(INPUT_COUNT, inputNodes.length);\r\n        const firstHiddenTotal = displayLayers[0]?.length || 0;\r\n\r\n        if (totalInputs > 0 && firstHiddenTotal > 0) {\r\n          /**\r\n           * Proportional number of connections for this input node.\r\n           */\r\n          const nodeProportion = Math.ceil(\r\n            connectionCounts[0] / Math.max(3, totalInputs * 2)\r\n          );\r\n          row += NetworkVisualization.pad(\r\n            `${colors.blueNeon}${nodeProportion} \u2500\u2500\u25B6${colors.reset}`,\r\n            ARROW_WIDTH\r\n          );\r\n        } else {\r\n          row += NetworkVisualization.pad(\r\n            `${colors.blueNeon}${ARROW}${colors.reset}`,\r\n            ARROW_WIDTH\r\n          );\r\n        }\r\n      } else {\r\n        // For other rows, just show the arrow without a number\r\n        row += NetworkVisualization.pad(\r\n          `${colors.blueNeon}${ARROW}${colors.reset}`,\r\n          ARROW_WIDTH\r\n        );\r\n      }\r\n\r\n      // Hidden layers\r\n      for (let layerIdx = 0; layerIdx < numHiddenLayers; layerIdx++) {\r\n        /**\r\n         * The current hidden layer for this column.\r\n         */\r\n        const layer = displayLayers[layerIdx];\r\n        if (rowIdx < layer.length) {\r\n          /**\r\n           * The node (or average node) for this row in the current layer.\r\n           */\r\n          const node = layer[rowIdx];\r\n\r\n          if (node.isAverage) {\r\n            // Special formatting for average nodes\r\n            /**\r\n             * Label for the average node group (if present).\r\n             */\r\n            const labelText = node.label ? `${node.label} ` : '';\r\n            /**\r\n             * Formatted average node display string.\r\n             */\r\n            const avgText = `${colors.cyanNeon}\u25A0${\r\n              colors.reset\r\n            }${NetworkVisualization.fmtColoredValue(node.activation)} ${\r\n              colors.dim\r\n            }(${labelText}avg of ${node.avgCount})${colors.reset}`;\r\n            row += NetworkVisualization.pad(avgText, columnWidth, ' ', 'left');\r\n          } else {\r\n            /**\r\n             * Value for this hidden node.\r\n             */\r\n            const value = NetworkVisualization.getNodeValue(node);\r\n            row += NetworkVisualization.pad(\r\n              `${colors.cyanNeon}\u25A0${\r\n                colors.reset\r\n              }${NetworkVisualization.fmtColoredValue(value)}`,\r\n              columnWidth,\r\n              ' ',\r\n              'left'\r\n            );\r\n          }\r\n        } else {\r\n          row += NetworkVisualization.pad(' ', columnWidth);\r\n        }\r\n\r\n        // Arrow between columns - calculate proportional connection counts\r\n        if (layerIdx < numHiddenLayers - 1) {\r\n          /**\r\n           * Arrow to next hidden layer, with proportional connection count.\r\n           */\r\n          const connCount = connectionCounts[layerIdx + 1];\r\n          if (rowIdx === 0) {\r\n            /**\r\n             * Proportional connection count for first row.\r\n             */\r\n            const currentLayerSize = displayLayers[layerIdx]?.length || 1;\r\n            const nodeProportion = Math.ceil(\r\n              connCount / Math.max(3, currentLayerSize * 2)\r\n            );\r\n            row += NetworkVisualization.pad(\r\n              `${colors.blueNeon}${nodeProportion} \u2500\u2500\u25B6${colors.reset}`,\r\n              ARROW_WIDTH\r\n            );\r\n          } else if (\r\n            rowIdx < layer.length &&\r\n            rowIdx < displayLayers[layerIdx + 1]?.length\r\n          ) {\r\n            /**\r\n             * Proportional connections between these hidden layers.\r\n             */\r\n            const currentLayerSize = displayLayers[layerIdx]?.length || 1;\r\n            const nextLayerSize = displayLayers[layerIdx + 1]?.length || 1;\r\n\r\n            // For hidden \u2192 hidden connections, distribute more evenly based on layer sizes\r\n            const proportion = Math.max(\r\n              1,\r\n              Math.min(5, Math.ceil(connCount / Math.max(3, currentLayerSize)))\r\n            );\r\n            row += NetworkVisualization.pad(\r\n              `${colors.blueNeon}${proportion} \u2500\u2500\u25B6${colors.reset}`,\r\n              ARROW_WIDTH\r\n            );\r\n          } else {\r\n            // Otherwise just show arrow\r\n            row += NetworkVisualization.pad(\r\n              `${colors.blueNeon}${ARROW}${colors.reset}`,\r\n              ARROW_WIDTH\r\n            );\r\n          }\r\n        } else {\r\n          // Last arrow to output layer\r\n          /**\r\n           * Connection count from last hidden to output layer.\r\n           */\r\n          const connCount = connectionCounts[connectionCounts.length - 1];\r\n          if (rowIdx === 0) {\r\n            /**\r\n             * Proportional connection count for first row to output.\r\n             */\r\n            const lastLayerSize =\r\n              displayLayers[displayLayers.length - 1]?.length || 1;\r\n            const nodeProportion = Math.ceil(\r\n              connCount / Math.max(3, lastLayerSize * 2)\r\n            );\r\n            row += NetworkVisualization.pad(\r\n              `${colors.blueNeon}${nodeProportion} \u2500\u2500\u25B6${colors.reset}`,\r\n              ARROW_WIDTH\r\n            );\r\n          } else if (rowIdx < layer.length && rowIdx < OUTPUT_COUNT) {\r\n            /**\r\n             * Proportional connections to output layer.\r\n             */\r\n            const lastLayerSize =\r\n              displayLayers[displayLayers.length - 1]?.length || 1;\r\n\r\n            // For last hidden \u2192 output, calculate a reasonable proportion\r\n            // This should show a small number, typically 1-5, not the total\r\n            const proportion = Math.max(\r\n              1,\r\n              Math.min(5, Math.ceil(connCount / Math.max(5, lastLayerSize * 2)))\r\n            );\r\n            row += NetworkVisualization.pad(\r\n              `${colors.blueNeon}${proportion} \u2500\u2500\u25B6${colors.reset}`,\r\n              ARROW_WIDTH\r\n            );\r\n          } else {\r\n            // Otherwise just show arrow\r\n            row += NetworkVisualization.pad(\r\n              `${colors.blueNeon}${ARROW}${colors.reset}`,\r\n              ARROW_WIDTH\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // Output column - ALWAYS show all 4 outputs\r\n      if (rowIdx < OUTPUT_COUNT) {\r\n        /**\r\n         * Output node and value for this row.\r\n         */\r\n        const node = outputDisplayNodes[rowIdx];\r\n        const value = NetworkVisualization.getNodeValue(node);\r\n        row +=\r\n          NetworkVisualization.pad(\r\n            `${colors.orangeNeon}\u25B2${\r\n              colors.reset\r\n            }${NetworkVisualization.fmtColoredValue(value)}`,\r\n            columnWidth,\r\n            ' ',\r\n            'left'\r\n          ) + `${colors.blueCore}\u2551${colors.reset}`;\r\n      } else {\r\n        row += NetworkVisualization.pad('', columnWidth);\r\n      }\r\n\r\n      // Add the completed row to the visualization table.\r\n      rows.push(row);\r\n    }\r\n\r\n    // Combine all parts with a legend and helpful explanations\r\n    return [\r\n      header,\r\n      ...rows,\r\n      // Spacer row\r\n      `${colors.blueCore}\u2551       ${NetworkVisualization.pad(' ', 140)} \u2551${\r\n        colors.reset\r\n      }`,\r\n      // Feed-forward flow explanation\r\n      `${colors.blueCore}\u2551       ${NetworkVisualization.pad(\r\n        'Arrows indicate feed-forward flow.',\r\n        140,\r\n        ' ',\r\n        'left'\r\n      )} ${colors.blueCore}\u2551${colors.reset}`,\r\n      // Spacer row\r\n      `${colors.blueCore}\u2551       ${NetworkVisualization.pad(' ', 140)} \u2551${\r\n        colors.reset\r\n      }`,\r\n\r\n      // Legend for node types\r\n      `${colors.blueCore}\u2551       ${NetworkVisualization.pad(\r\n        `${colors.whiteNeon}Legend:  ${colors.neonGreen}\u25CF${colors.reset}=Input                    ${colors.cyanNeon}\u25A0${colors.reset}=Hidden                    ${colors.orangeNeon}\u25B2${colors.reset}=Output`,\r\n        140,\r\n        ' ',\r\n        'left'\r\n      )} ${colors.blueCore}\u2551${colors.reset}`,\r\n      // Legend for activation groups\r\n      `${colors.blueCore}\u2551       ${NetworkVisualization.pad(\r\n        `${colors.whiteNeon}Groups:  ${colors.bgOrangeNeon}${colors.bright}v-high+${colors.reset}=Very high positive   ${colors.orangeNeon}high+${colors.reset}=High positive    ${colors.cyanNeon}mid+${colors.reset}=Medium positive    ${colors.neonGreen}low+${colors.reset}=Low positive`,\r\n        140,\r\n        ' ',\r\n        'left'\r\n      )} ${colors.blueCore}\u2551${colors.reset}`,\r\n      // Legend for near-zero group\r\n      `${colors.blueCore}\u2551       ${NetworkVisualization.pad(\r\n        `${colors.whiteNeon}         zero\u00B1${colors.reset}=Near zero`,\r\n        140,\r\n        ' ',\r\n        'left'\r\n      )} ${colors.blueCore}\u2551${colors.reset}`,\r\n      // Legend for negative groups\r\n      `${colors.blueCore}\u2551       ${NetworkVisualization.pad(\r\n        `         ${colors.bgBlueCore}${colors.bright}v-high-${colors.reset}=Very high negative   ${colors.blueNeon}${colors.bright}high-${colors.reset}=High negative    ${colors.blueCore}mid-${colors.reset}=Medium negative    ${colors.blue}low-${colors.reset}=Low negative`,\r\n        140,\r\n        ' ',\r\n        'left'\r\n      )} ${colors.blueCore}\u2551${colors.reset}`,\r\n    ].join('\\n');\r\n  }\r\n}\r\n", "/**\r\n * Maze Visualization - Handles rendering and visualization of mazes\r\n *\r\n * This module contains functions for visualizing mazes in the terminal,\r\n * including colored cell rendering, path visualization, and progress indicators.\r\n * It provides an intuitive way to observe the agent's behavior and solution paths.\r\n *\r\n * The visualization uses ANSI color codes to create a rich terminal interface\r\n * showing different maze elements (walls, paths, start/exit) and the agent's\r\n * current position and traversal history.\r\n */\r\n\r\nimport { MazeUtils } from './mazeUtils';\r\nimport { colors } from './colors';\r\nimport { NetworkVisualization } from './networkVisualization';\r\n\r\n/**\r\n * MazeVisualization provides static methods for rendering mazes and agent progress.\r\n */\r\nexport class MazeVisualization {\r\n  /**\r\n   * Renders a single maze cell with proper coloring based on its content and agent location.\r\n   *\r\n   * Applies appropriate colors and styling to each cell in the maze:\r\n   * - Different colors for walls, open paths, start and exit positions\r\n   * - Highlights the agent's current position\r\n   * - Marks cells that are part of the agent's path\r\n   * - Renders box drawing characters as walls with proper styling\r\n   *\r\n   * @param cell - The character representing the cell ('S', 'E', '#', '.' etc.)\r\n   * @param x - X-coordinate of the cell\r\n   * @param y - Y-coordinate of the cell\r\n   * @param agentX - X-coordinate of the agent's current position\r\n   * @param agentY - Y-coordinate of the agent's current position\r\n   * @param path - Optional set of visited coordinates in \"x,y\" format\r\n   * @returns Colorized string representing the cell\r\n   */\r\n  static renderCell(\r\n    cell: string,\r\n    x: number,\r\n    y: number,\r\n    agentX: number,\r\n    agentY: number,\r\n    path: Set<string> | undefined\r\n  ): string {\r\n    // Unicode box drawing characters that should be treated as walls\r\n    const wallChars = new Set([\r\n      '#',\r\n      '\u2550',\r\n      '\u2551',\r\n      '\u2554',\r\n      '\u2557',\r\n      '\u255A',\r\n      '\u255D',\r\n      '\u2560',\r\n      '\u2563',\r\n      '\u2566',\r\n      '\u2569',\r\n      '\u256C',\r\n    ]);\r\n\r\n    // Agent's current position takes precedence in visualization\r\n    if (x === agentX && y === agentY) {\r\n      if (cell === 'S')\r\n        return `${colors.bgBlack}${colors.orangeNeon}S${colors.reset}`;\r\n      if (cell === 'E')\r\n        return `${colors.bgBlack}${colors.orangeNeon}E${colors.reset}`;\r\n      return `${colors.bgBlack}${colors.orangeNeon}A${colors.reset}`; // 'A' for Agent - TRON cyan\r\n    }\r\n\r\n    // Render other cell types\r\n    switch (cell) {\r\n      case 'S':\r\n        return `${colors.bgBlack}${colors.orangeNeon}S${colors.reset}`; // Start position\r\n      case 'E':\r\n        return `${colors.bgBlack}${colors.orangeNeon}E${colors.reset}`; // Exit position - TRON orange\r\n      case '.':\r\n        // Show path breadcrumbs if this cell was visited\r\n        if (path && path.has(`${x},${y}`))\r\n          return `${colors.floorBg}${colors.orangeNeon}\u2022${colors.reset}`;\r\n        return `${colors.floorBg}${colors.gridLineText}.${colors.reset}`; // Open path - dark floor with subtle grid\r\n      default:\r\n        // For box drawing characters and # - render as wall\r\n        if (wallChars.has(cell)) {\r\n          return `${colors.bgBlack}${colors.blueNeon}${cell}${colors.reset}`;\r\n        }\r\n        return cell; // Any other character\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Renders the entire maze as a colored ASCII string, showing the agent and its path.\r\n   *\r\n   * Converts the maze data structure into a human-readable, colorized representation showing:\r\n   * - The maze layout with walls and open paths\r\n   * - The start and exit positions\r\n   * - The agent's current position\r\n   * - The path the agent has taken (if provided)\r\n   *\r\n   * @param asciiMaze - Array of strings representing the maze layout\r\n   * @param [agentX, agentY] - Current position of the agent\r\n   * @param path - Optional array of positions representing the agent's path\r\n   * @returns A multi-line string with the visualized maze\r\n   */\r\n  static visualizeMaze(\r\n    asciiMaze: string[],\r\n    [agentX, agentY]: [number, number],\r\n    path?: [number, number][]\r\n  ): string {\r\n    // Convert path array to a set of \"x,y\" strings for quick lookup\r\n    const visitedPositions = path\r\n      ? new Set(path.map((pos) => `${pos[0]},${pos[1]}`))\r\n      : undefined;\r\n\r\n    // Process each row and cell\r\n    return asciiMaze\r\n      .map((row, y) =>\r\n        [...row]\r\n          .map((cell, x) =>\r\n            this.renderCell(cell, x, y, agentX, agentY, visitedPositions)\r\n          )\r\n          .join('')\r\n      )\r\n      .join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Prints a summary of the agent's attempt, including success, steps, and efficiency.\r\n   *\r\n   * Provides performance metrics about the agent's solution attempt:\r\n   * - Whether it successfully reached the exit\r\n   * - How many steps it took\r\n   * - How efficient the path was compared to the optimal BFS distance\r\n   *\r\n   * @param currentBest - Object containing the simulation results, network, and generation\r\n   * @param maze - Array of strings representing the maze layout\r\n   * @param forceLog - Function used for logging output\r\n   */\r\n  static printMazeStats(\r\n    currentBest: {\r\n      result: any;\r\n      network: any;\r\n      generation: number;\r\n    },\r\n    maze: string[],\r\n    forceLog: (...args: any[]) => void\r\n  ): void {\r\n    const { result, generation } = currentBest;\r\n    const successColor = result.success ? colors.cyanNeon : colors.neonRed;\r\n\r\n    // Find maze start and end positions\r\n    const startPos = MazeUtils.findPosition(maze, 'S');\r\n    const exitPos = MazeUtils.findPosition(maze, 'E');\r\n    const optimalLength = MazeUtils.bfsDistance(\r\n      MazeUtils.encodeMaze(maze),\r\n      startPos,\r\n      exitPos\r\n    );\r\n\r\n    // Layout constants (keep in sync with DashboardManager framing)\r\n    const FRAME_WIDTH = 148;\r\n    const LEFT_PAD = 7;\r\n    const RIGHT_PAD = 1;\r\n    const CONTENT_WIDTH = FRAME_WIDTH - LEFT_PAD - RIGHT_PAD;\r\n\r\n    forceLog(\r\n      `${colors.blueCore}\u2551${NetworkVisualization.pad(' ', FRAME_WIDTH, ' ')}${\r\n        colors.blueCore\r\n      }\u2551${colors.reset}`\r\n    );\r\n    forceLog(\r\n      `${colors.blueCore}\u2551${NetworkVisualization.pad(' ', FRAME_WIDTH, ' ')}${\r\n        colors.blueCore\r\n      }\u2551${colors.reset}`\r\n    );\r\n    forceLog(\r\n      `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n        `${colors.neonSilver}Success:${colors.neonIndigo} ${successColor}${\r\n          result.success ? 'YES' : 'NO'\r\n        }`,\r\n        CONTENT_WIDTH,\r\n        ' ',\r\n        'left'\r\n      )}${' '.repeat(RIGHT_PAD)}${colors.blueCore}\u2551${colors.reset}`\r\n    );\r\n    // Print generation number with color and padding\r\n    forceLog(\r\n      `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n        `${colors.neonSilver}Generation:${colors.neonIndigo} ${successColor}${generation}`,\r\n        CONTENT_WIDTH,\r\n        ' ',\r\n        'left'\r\n      )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n    );\r\n    // Print fitness score\r\n    forceLog(\r\n      `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n        `${colors.neonSilver}Fitness:${\r\n          colors.neonOrange\r\n        } ${result.fitness.toFixed(2)}`,\r\n        CONTENT_WIDTH,\r\n        ' ',\r\n        'left'\r\n      )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n    );\r\n    // Print steps taken\r\n    forceLog(\r\n      `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n        `${colors.neonSilver}Steps taken:${colors.neonIndigo} ${result.steps}`,\r\n        CONTENT_WIDTH,\r\n        ' ',\r\n        'left'\r\n      )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n    );\r\n    // Print path length\r\n    forceLog(\r\n      `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n        `${colors.neonSilver}Path length:${colors.neonIndigo} ${result.path.length}${colors.blueCore}`,\r\n        CONTENT_WIDTH,\r\n        ' ',\r\n        'left'\r\n      )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n    );\r\n    // Print optimal distance to exit\r\n    forceLog(\r\n      `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n        `${colors.neonSilver}Optimal distance to exit:${colors.neonYellow} ${optimalLength}`,\r\n        CONTENT_WIDTH,\r\n        ' ',\r\n        'left'\r\n      )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n    );\r\n    // Print a blank padded line for spacing\r\n    forceLog(\r\n      `${colors.blueCore}\u2551${NetworkVisualization.pad(' ', FRAME_WIDTH, ' ')}${\r\n        colors.blueCore\r\n      }\u2551${colors.reset}`\r\n    );\r\n\r\n    if (result.success) {\r\n      /**\r\n       * If the agent succeeded, calculate and display detailed path statistics.\r\n       * This includes path efficiency, overhead, direction changes, unique cells, revisits, and decisions per cell.\r\n       */\r\n\r\n      /**\r\n       * Path length is the number of steps taken (excluding the starting cell).\r\n       * Used to compare actual path to optimal path.\r\n       */\r\n      const pathLength = result.path.length - 1;\r\n\r\n      /**\r\n       * Efficiency: ratio of optimal path to actual path, capped at 100%.\r\n       * Shows how close the agent's path is to the shortest possible.\r\n       */\r\n      const efficiency = Math.min(\r\n        100,\r\n        Math.round((optimalLength / pathLength) * 100)\r\n      ).toFixed(1);\r\n\r\n      /**\r\n       * Overhead: how much longer the path is compared to optimal, as a percent.\r\n       * Positive values mean the agent took a longer route than necessary.\r\n       */\r\n      const overhead = ((pathLength / optimalLength) * 100 - 100).toFixed(1);\r\n\r\n      /**\r\n       * Set of unique cells visited by the agent, for coverage and revisit stats.\r\n       */\r\n      const uniqueCells = new Set<string>();\r\n\r\n      /**\r\n       * Number of times the agent revisited a cell it had already visited.\r\n       */\r\n      let revisitedCells = 0;\r\n\r\n      /**\r\n       * Number of times the agent changed direction (N, S, E, W) during its path.\r\n       */\r\n      let directionChanges = 0;\r\n\r\n      /**\r\n       * Tracks the last direction moved, to count direction changes.\r\n       */\r\n      let lastDirection: string | null = null;\r\n\r\n      // Analyze the path for revisits and direction changes\r\n      for (let i = 0; i < result.path.length; i++) {\r\n        /**\r\n         * Current cell coordinates in the path.\r\n         */\r\n        const [x, y] = result.path[i];\r\n        /**\r\n         * Unique string key for the cell, used in the Set.\r\n         */\r\n        const cellKey = `${x},${y}`;\r\n\r\n        // Count revisits\r\n        if (uniqueCells.has(cellKey)) {\r\n          revisitedCells++;\r\n        } else {\r\n          uniqueCells.add(cellKey);\r\n        }\r\n\r\n        // Count direction changes (if not the first step)\r\n        if (i > 0) {\r\n          /**\r\n           * Previous cell coordinates in the path.\r\n           */\r\n          const [prevX, prevY] = result.path[i - 1];\r\n          /**\r\n           * Delta X and Y to determine direction.\r\n           */\r\n          const dx = x - prevX;\r\n          const dy = y - prevY;\r\n\r\n          // Determine direction: N, S, E, W\r\n          let currentDirection = '';\r\n          if (dx > 0) currentDirection = 'E';\r\n          else if (dx < 0) currentDirection = 'W';\r\n          else if (dy > 0) currentDirection = 'S';\r\n          else if (dy < 0) currentDirection = 'N';\r\n\r\n          // Increment if direction changed\r\n          if (lastDirection !== null && currentDirection !== lastDirection) {\r\n            directionChanges++;\r\n          }\r\n          lastDirection = currentDirection;\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Maze width and height, used for coverage calculation.\r\n       */\r\n      const mazeWidth = maze[0].length;\r\n      const mazeHeight = maze.length;\r\n\r\n      /**\r\n       * Encoded maze (walls as -1, open as 0), for walkable cell counting.\r\n       */\r\n      const encodedMaze = MazeUtils.encodeMaze(maze);\r\n\r\n      /**\r\n       * Number of walkable (non-wall) cells in the maze.\r\n       */\r\n      let walkableCells = 0;\r\n      for (let y = 0; y < mazeHeight; y++) {\r\n        for (let x = 0; x < mazeWidth; x++) {\r\n          if (encodedMaze[y][x] !== -1) {\r\n            walkableCells++;\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Percentage of walkable cells visited by the agent.\r\n       */\r\n      const coveragePercent = (\r\n        (uniqueCells.size / walkableCells) *\r\n        100\r\n      ).toFixed(1);\r\n\r\n      // Display detailed statistics\r\n      forceLog(\r\n        `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n          `${colors.neonSilver}Path efficiency:      ${colors.neonIndigo} ${optimalLength}/${pathLength} (${efficiency}%)`,\r\n          CONTENT_WIDTH,\r\n          ' ',\r\n          'left'\r\n        )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n      );\r\n      forceLog(\r\n        `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n          `${colors.neonSilver}Optimal steps:        ${colors.neonIndigo} ${optimalLength}`,\r\n          CONTENT_WIDTH,\r\n          ' ',\r\n          'left'\r\n        )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n      );\r\n      forceLog(\r\n        `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n          `${colors.neonSilver}Path overhead:        ${colors.neonIndigo} ${overhead}% longer than optimal`,\r\n          CONTENT_WIDTH,\r\n          ' ',\r\n          'left'\r\n        )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n      );\r\n      forceLog(\r\n        `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n          `${colors.neonSilver}Direction changes:    ${colors.neonIndigo} ${directionChanges}`,\r\n          CONTENT_WIDTH,\r\n          ' ',\r\n          'left'\r\n        )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n      );\r\n      forceLog(\r\n        `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n          `${colors.neonSilver}Unique cells visited: ${colors.neonIndigo} ${uniqueCells.size} (${coveragePercent}% of maze)`,\r\n          CONTENT_WIDTH,\r\n          ' ',\r\n          'left'\r\n        )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n      );\r\n      forceLog(\r\n        `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n          `${colors.neonSilver}Cells revisited:      ${colors.neonIndigo} ${revisitedCells} times`,\r\n          CONTENT_WIDTH,\r\n          ' ',\r\n          'left'\r\n        )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n      );\r\n      forceLog(\r\n        `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n          `${colors.neonSilver}Decisions per cell:   ${colors.neonIndigo} ${(\r\n            directionChanges / uniqueCells.size\r\n          ).toFixed(2)}`,\r\n          CONTENT_WIDTH,\r\n          ' ',\r\n          'left'\r\n        )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n      );\r\n      forceLog(\r\n        `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n          `${colors.neonOrange}Agent successfully navigated the maze!`,\r\n          CONTENT_WIDTH,\r\n          ' ',\r\n          'left'\r\n        )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n      );\r\n    } else {\r\n      /**\r\n       * If the agent did not succeed, display progress toward the exit and unique cells visited.\r\n       * This helps visualize partial progress and exploration.\r\n       */\r\n      // Calculate best progress toward the exit (as a percent)\r\n      const bestProgress = MazeUtils.calculateProgress(\r\n        MazeUtils.encodeMaze(maze),\r\n        result.path[result.path.length - 1],\r\n        startPos,\r\n        exitPos\r\n      );\r\n\r\n      // Track unique cells visited\r\n      const uniqueCells = new Set<string>();\r\n      for (const [x, y] of result.path) {\r\n        uniqueCells.add(`${x},${y}`);\r\n      }\r\n\r\n      // Display partial progress statistics\r\n      forceLog(\r\n        `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n          `${colors.neonSilver}Best progress toward exit:      ${colors.neonIndigo} ${bestProgress}%`,\r\n          CONTENT_WIDTH,\r\n          ' ',\r\n          'left'\r\n        )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n      );\r\n      forceLog(\r\n        `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n          `${colors.neonSilver}Shortest possible steps:        ${colors.neonIndigo} ${optimalLength}`,\r\n          CONTENT_WIDTH,\r\n          ' ',\r\n          'left'\r\n        )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n      );\r\n      forceLog(\r\n        `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n          `${colors.neonSilver}Unique cells visited:           ${colors.neonIndigo} ${uniqueCells.size}`,\r\n          CONTENT_WIDTH,\r\n          ' ',\r\n          'left'\r\n        )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n      );\r\n      forceLog(\r\n        `${colors.blueCore}\u2551${' '.repeat(LEFT_PAD)}${NetworkVisualization.pad(\r\n          `${colors.neonSilver}Agent trying to reach the exit. ${colors.neonIndigo}`,\r\n          CONTENT_WIDTH,\r\n          ' ',\r\n          'left'\r\n        )}${' '.repeat(RIGHT_PAD)}\u2551${colors.reset}`\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Displays a colored progress bar for agent progress.\r\n   *\r\n   * Creates a visual representation of the agent's progress toward the exit\r\n   * as a horizontal bar with appropriate coloring based on percentage.\r\n   *\r\n   * @param progress - Progress percentage (0-100)\r\n   * @param length - Length of the progress bar in characters (default: 60)\r\n   * @returns A string containing the formatted progress bar\r\n   */\r\n  static displayProgressBar(progress: number, length: number = 60): string {\r\n    /**\r\n     * Number of filled positions in the progress bar, based on percent complete.\r\n     */\r\n    const filledLength = Math.max(\r\n      0,\r\n      Math.min(length, Math.floor((length * progress) / 100))\r\n    );\r\n\r\n    /**\r\n     * Characters for the progress bar:\r\n     * - startChar: left cap\r\n     * - endChar: right cap\r\n     * - fillChar: filled section\r\n     * - emptyChar: unfilled section\r\n     * - pointerChar: current progress pointer\r\n     */\r\n    const startChar = `${colors.blueCore}|>|`;\r\n    const endChar = `${colors.blueCore}|<|`;\r\n    const fillChar = `${colors.neonOrange}\u2550`;\r\n    const emptyChar = `${colors.neonIndigo}:`;\r\n    const pointerChar = `${colors.neonOrange}\u25B6`; // Indicates the current progress point\r\n\r\n    // Build the progress bar string\r\n    let bar = '';\r\n    bar += startChar;\r\n\r\n    if (filledLength > 0) {\r\n      bar += fillChar.repeat(filledLength - 1);\r\n      bar += pointerChar;\r\n    }\r\n\r\n    /**\r\n     * Number of empty positions remaining in the bar.\r\n     */\r\n    const emptyLength = length - filledLength;\r\n    if (emptyLength > 0) {\r\n      bar += emptyChar.repeat(emptyLength);\r\n    }\r\n\r\n    bar += endChar;\r\n\r\n    /**\r\n     * Color for the bar, based on progress percent (TRON palette).\r\n     */\r\n    const color =\r\n      progress < 30\r\n        ? colors.neonYellow\r\n        : progress < 70\r\n        ? colors.orangeNeon\r\n        : colors.cyanNeon;\r\n    return `${color}${bar}${colors.reset} ${progress}%`;\r\n  }\r\n\r\n  /**\r\n   * Formats elapsed time in a human-readable way.\r\n   *\r\n   * Converts seconds into appropriate units (seconds, minutes, hours)\r\n   * for more intuitive display of time durations.\r\n   *\r\n   * @param seconds - Time in seconds\r\n   * @returns Formatted string (e.g., \"5.3s\", \"2m 30s\", \"1h 15m\")\r\n   */\r\n  static formatElapsedTime(seconds: number): string {\r\n    // If less than a minute, show seconds with one decimal\r\n    if (seconds < 60) return `${seconds.toFixed(1)}s`;\r\n\r\n    // If less than an hour, show minutes and seconds\r\n    if (seconds < 3600) {\r\n      /**\r\n       * Number of whole minutes in the input seconds.\r\n       */\r\n      const minutes = Math.floor(seconds / 60);\r\n      /**\r\n       * Remaining seconds after extracting minutes.\r\n       */\r\n      const remainingSeconds = seconds % 60;\r\n      return `${minutes}m ${remainingSeconds.toFixed(0)}s`;\r\n    }\r\n\r\n    /**\r\n     * Number of whole hours in the input seconds.\r\n     */\r\n    const hours = Math.floor(seconds / 3600);\r\n    /**\r\n     * Number of whole minutes after extracting hours.\r\n     */\r\n    const minutes = Math.floor((seconds % 3600) / 60);\r\n    return `${hours}h ${minutes}m`;\r\n  }\r\n}\r\n", "/**\r\n * Dashboard Manager - Handles the visualization dashboard\r\n *\r\n * This module contains the DashboardManager class, which manages the\r\n * state of the dynamic terminal dashboard that displays maze solving progress\r\n * and optionally appends solved mazes to an archive area. The implementation\r\n * is designed to be readable for educational purposes: it gathers telemetry\r\n * from the running NEAT instance, keeps small historical series for sparklines,\r\n * and renders both a live view (cleared and redrawn each frame) and an\r\n * archive view (appended once per solved maze).\r\n */\r\nimport { Network } from '../../../src/neataptic';\r\nimport { MazeUtils } from './mazeUtils';\r\nimport { MazeVisualization } from './mazeVisualization';\r\nimport { NetworkVisualization } from './networkVisualization';\r\nimport { colors } from './colors';\r\nimport { INetwork, IDashboardManager } from './interfaces';\r\n\r\n/**\r\n * DashboardManager: manages solved mazes, current best, and terminal output.\r\n * Supports an optional archive logger to which solved-maze blocks are appended\r\n * while the live logger is used for the active maze redraws.\r\n */\r\n/**\r\n * DashboardManager\r\n *\r\n * Responsibilities:\r\n * - Keep track of solved mazes and avoid duplicates.\r\n * - Maintain the current best solution (for live rendering).\r\n * - Collect small telemetry histories used to render sparklines.\r\n * - Render a compact terminal-style dashboard to `logFunction` and\r\n *   append formatted solved-maze blocks to `archiveLogFunction` when present.\r\n *\r\n * Constructor parameters are function references so the dashboard can remain\r\n * agnostic about where output actually goes (Node console, browser DOM, etc.).\r\n */\r\nexport class DashboardManager implements IDashboardManager {\r\n  // List of solved maze records (keeps full maze + solution for archival display)\r\n  private solvedMazes: Array<{\r\n    maze: string[];\r\n    result: any;\r\n    network: INetwork;\r\n    generation: number;\r\n  }> = [];\r\n\r\n  // Set of maze keys we've already archived to avoid duplicate entries\r\n  private solvedMazeKeys: Set<string> = new Set<string>();\r\n\r\n  // Currently evolving/best candidate for the active maze (live view)\r\n  private currentBest: {\r\n    result: any;\r\n    network: INetwork;\r\n    generation: number;\r\n  } | null = null;\r\n\r\n  // Functions supplied by the embedding environment. Keep dashboard I/O pluggable.\r\n  private clearFunction: () => void;\r\n  private logFunction: (...args: any[]) => void;\r\n  private archiveLogFunction?: (...args: any[]) => void;\r\n\r\n  // Telemetry and small history windows used for rendering trends/sparklines\r\n  private _lastTelemetry: any = null;\r\n  private _lastBestFitness: number | null = null;\r\n  private _bestFitnessHistory: number[] = [];\r\n  private _complexityNodesHistory: number[] = [];\r\n  private _complexityConnsHistory: number[] = [];\r\n  private _hypervolumeHistory: number[] = [];\r\n  private _progressHistory: number[] = [];\r\n  private _speciesCountHistory: number[] = [];\r\n\r\n  // Layout constants for the ASCII-art framed display\r\n  private static readonly FRAME_INNER_WIDTH = 148;\r\n  private static readonly LEFT_PADDING = 7;\r\n  private static readonly RIGHT_PADDING = 1;\r\n  private static readonly CONTENT_WIDTH =\r\n    DashboardManager.FRAME_INNER_WIDTH -\r\n    DashboardManager.LEFT_PADDING -\r\n    DashboardManager.RIGHT_PADDING;\r\n  private static readonly STAT_LABEL_WIDTH = 28;\r\n  private static opennessLegend =\r\n    'Openness: 1=best, (0,1)=longer improving, 0.001=only backtrack, 0=wall/dead/non-improving';\r\n\r\n  /**\r\n   * Construct a new DashboardManager\r\n   *\r\n   * @param clearFn - function that clears the \"live\" output area (no-op for archive)\r\n   * @param logFn - function that accepts strings to render the live dashboard\r\n   * @param archiveLogFn - optional function to which solved-maze archive blocks are appended\r\n   */\r\n  constructor(\r\n    clearFn: () => void,\r\n    logFn: (...args: any[]) => void,\r\n    archiveLogFn?: (...args: any[]) => void\r\n  ) {\r\n    this.clearFunction = clearFn;\r\n    this.logFunction = logFn;\r\n    this.archiveLogFunction = archiveLogFn;\r\n  }\r\n\r\n  /**\r\n   * formatStat\r\n   *\r\n   * Small helper that returns a prettified line containing a label and value\r\n   * with color codes applied. The resulting string fits into the dashboard\r\n   * content width and includes frame padding.\r\n   */\r\n  private formatStat(\r\n    label: string,\r\n    value: string | number,\r\n    colorLabel = colors.neonSilver,\r\n    colorValue = colors.cyanNeon,\r\n    labelWidth = DashboardManager.STAT_LABEL_WIDTH\r\n  ) {\r\n    // Ensure label ends with ':' and pad to labelWidth for column alignment\r\n    const lbl = label.endsWith(':') ? label : label + ':';\r\n    const paddedLabel = lbl.padEnd(labelWidth, ' ');\r\n\r\n    // Compose colored label + value, then pad/truncate to content width\r\n    const composed = `${colorLabel}${paddedLabel}${colorValue} ${value}${colors.reset}`;\r\n    return `${colors.blueCore}\u2551${' '.repeat(\r\n      DashboardManager.LEFT_PADDING\r\n    )}${NetworkVisualization.pad(\r\n      composed,\r\n      DashboardManager.CONTENT_WIDTH,\r\n      ' ',\r\n      'left'\r\n    )}${' '.repeat(DashboardManager.RIGHT_PADDING)}${colors.blueCore}\u2551${\r\n      colors.reset\r\n    }`;\r\n  }\r\n\r\n  /**\r\n   * buildSparkline\r\n   *\r\n   * Create a compact sparkline string (using block characters) from a numeric\r\n   * series. The series is normalized to the block range and trimmed to the\r\n   * requested width by taking the most recent values.\r\n   */\r\n  private buildSparkline(data: number[], width = 32): string {\r\n    if (!data || !data.length) return '';\r\n    const blocks = ['\u2581', '\u2582', '\u2583', '\u2584', '\u2585', '\u2586', '\u2587', '\u2588'];\r\n    const slice = data.slice(-width);\r\n    const min = Math.min(...slice);\r\n    const max = Math.max(...slice);\r\n    // Avoid division by zero\r\n    const range = max - min || 1;\r\n    return slice\r\n      .map((v) => {\r\n        // Map value into block index\r\n        const idx = Math.floor(((v - min) / range) * (blocks.length - 1));\r\n        return blocks[idx];\r\n      })\r\n      .join('');\r\n  }\r\n\r\n  /**\r\n   * getMazeKey\r\n   *\r\n   * Create a lightweight key for a maze (used to dedupe solved mazes).\r\n   * The format is intentionally simple (concatenated rows) since the set\r\n   * is only used for equality checks within a single run.\r\n   */\r\n  private getMazeKey(maze: string[]) {\r\n    return maze.join('');\r\n  }\r\n\r\n  /**\r\n   * appendSolvedToArchive\r\n   *\r\n   * When a maze is solved for the first time, format and append a boxed\r\n   * representation of the solved maze to the provided `archiveLogFunction`.\r\n   * The block includes a header, optional small trend sparklines, the\r\n   * centered maze drawing, and several efficiency stats derived from the path.\r\n   *\r\n   * This function is careful to be a no-op if no archive logger was provided\r\n   * during construction.\r\n   *\r\n   * @param solved - record containing maze, solution and generation\r\n   * @param displayNumber - 1-based ordinal for the solved maze in the archive\r\n   */\r\n  private appendSolvedToArchive(\r\n    solved: {\r\n      maze: string[];\r\n      result: any;\r\n      network: INetwork;\r\n      generation: number;\r\n    },\r\n    displayNumber: number\r\n  ) {\r\n    // If the embedder did not supply an archive logger, there's nothing to do\r\n    if (!this.archiveLogFunction) return;\r\n\r\n    // Render solved maze visualization using the MazeVisualization helper\r\n    const endPos = solved.result.path[solved.result.path.length - 1];\r\n    const solvedMazeVisualization = MazeVisualization.visualizeMaze(\r\n      solved.maze,\r\n      endPos,\r\n      solved.result.path\r\n    );\r\n    const solvedMazeLines = Array.isArray(solvedMazeVisualization)\r\n      ? solvedMazeVisualization\r\n      : solvedMazeVisualization.split('\\n');\r\n\r\n    // Center each maze line to the frame width\r\n    const centeredSolvedMaze = solvedMazeLines\r\n      .map((line) =>\r\n        NetworkVisualization.pad(line, DashboardManager.FRAME_INNER_WIDTH, ' ')\r\n      )\r\n      .join('\\n');\r\n\r\n    // Create boxed header / title / separator lines consistent with the dashboard frame\r\n    const header = `${colors.blueCore}\u2560${NetworkVisualization.pad(\r\n      '\u2550'.repeat(DashboardManager.FRAME_INNER_WIDTH),\r\n      DashboardManager.FRAME_INNER_WIDTH,\r\n      '\u2550'\r\n    )}\u2563${colors.reset}`;\r\n    const title = `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n      `${colors.orangeNeon} SOLVED #${displayNumber} (Gen ${solved.generation})${colors.reset}${colors.blueCore}`,\r\n      DashboardManager.FRAME_INNER_WIDTH,\r\n      ' '\r\n    )}\u2551${colors.reset}`;\r\n    const sep = `${colors.blueCore}\u2560${NetworkVisualization.pad(\r\n      '\u2500'.repeat(DashboardManager.FRAME_INNER_WIDTH),\r\n      DashboardManager.FRAME_INNER_WIDTH,\r\n      '\u2500'\r\n    )}\u2563${colors.reset}`;\r\n\r\n    // Build the entire boxed block as one string so we can prepend it to the\r\n    // archive (newest-first). Building a single string also reduces DOM churn.\r\n    const blockLines: string[] = [];\r\n    blockLines.push(header);\r\n    blockLines.push(title);\r\n    blockLines.push(sep);\r\n\r\n    // Optional trending sparklines derived from stored history windows\r\n    const solvedLabelWidth = 22;\r\n    const solvedStat = (label: string, value: string) =>\r\n      this.formatStat(\r\n        label,\r\n        value,\r\n        colors.neonSilver,\r\n        colors.cyanNeon,\r\n        solvedLabelWidth\r\n      );\r\n\r\n    const spark = this.buildSparkline(this._bestFitnessHistory, 64);\r\n    const sparkComplexityNodes = this.buildSparkline(\r\n      this._complexityNodesHistory,\r\n      64\r\n    );\r\n    const sparkComplexityConns = this.buildSparkline(\r\n      this._complexityConnsHistory,\r\n      64\r\n    );\r\n    const sparkHyper = this.buildSparkline(this._hypervolumeHistory, 64);\r\n    const sparkProgress = this.buildSparkline(this._progressHistory, 64);\r\n    const sparkSpecies = this.buildSparkline(this._speciesCountHistory, 64);\r\n\r\n    if (spark) blockLines.push(solvedStat('Fitness trend', spark));\r\n    if (sparkComplexityNodes)\r\n      blockLines.push(solvedStat('Nodes trend', sparkComplexityNodes));\r\n    if (sparkComplexityConns)\r\n      blockLines.push(solvedStat('Conns trend', sparkComplexityConns));\r\n    if (sparkHyper) blockLines.push(solvedStat('Hypervol trend', sparkHyper));\r\n    if (sparkProgress)\r\n      blockLines.push(solvedStat('Progress trend', sparkProgress));\r\n    if (sparkSpecies)\r\n      blockLines.push(solvedStat('Species trend', sparkSpecies));\r\n\r\n    // Blank spacer line inside the box\r\n    blockLines.push(\r\n      `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n        ' ',\r\n        DashboardManager.FRAME_INNER_WIDTH,\r\n        ' '\r\n      )}${colors.blueCore}\u2551${colors.reset}`\r\n    );\r\n\r\n    // Append the centered maze drawing, row by row (each padded into the frame)\r\n    centeredSolvedMaze\r\n      .split('\\n')\r\n      .forEach((l) =>\r\n        blockLines.push(\r\n          `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n            l,\r\n            DashboardManager.FRAME_INNER_WIDTH,\r\n            ' '\r\n          )}${colors.blueCore}\u2551${colors.reset}`\r\n        )\r\n      );\r\n\r\n    // Compute a few path efficiency stats: optimal length (BFS), actual path length, revisit counts\r\n    const startPos = MazeUtils.findPosition(solved.maze, 'S');\r\n    const exitPos = MazeUtils.findPosition(solved.maze, 'E');\r\n    const optimalLength = MazeUtils.bfsDistance(\r\n      MazeUtils.encodeMaze(solved.maze),\r\n      startPos,\r\n      exitPos\r\n    );\r\n    const pathLength = solved.result.path.length - 1;\r\n    const efficiency = Math.min(\r\n      100,\r\n      Math.round((optimalLength / pathLength) * 100)\r\n    ).toFixed(1);\r\n    const overhead = ((pathLength / optimalLength) * 100 - 100).toFixed(1);\r\n\r\n    // Count unique vs revisited cells along the path\r\n    const uniqueCells = new Set<string>();\r\n    let revisitedCells = 0;\r\n    for (const [x, y] of solved.result.path) {\r\n      const cellKey = `${x},${y}`;\r\n      if (uniqueCells.has(cellKey)) revisitedCells++;\r\n      else uniqueCells.add(cellKey);\r\n    }\r\n\r\n    // Append efficiency & fitness stats\r\n    blockLines.push(\r\n      solvedStat(\r\n        'Path efficiency',\r\n        `${optimalLength}/${pathLength} (${efficiency}%)`\r\n      )\r\n    );\r\n    blockLines.push(\r\n      solvedStat('Path overhead', `${overhead}% longer than optimal`)\r\n    );\r\n    blockLines.push(solvedStat('Unique cells visited', `${uniqueCells.size}`));\r\n    blockLines.push(solvedStat('Cells revisited', `${revisitedCells} times`));\r\n    blockLines.push(solvedStat('Steps', `${solved.result.steps}`));\r\n    blockLines.push(\r\n      solvedStat('Fitness', `${solved.result.fitness.toFixed(2)}`)\r\n    );\r\n\r\n    // Bottom border of the boxed block\r\n    blockLines.push(\r\n      `${colors.blueCore}\u255A${NetworkVisualization.pad(\r\n        '\u2550'.repeat(DashboardManager.FRAME_INNER_WIDTH),\r\n        DashboardManager.FRAME_INNER_WIDTH,\r\n        '\u2550'\r\n      )}\u255D${colors.reset}`\r\n    );\r\n\r\n    // Finally, emit the entire block using the archive logger. Pass the `{ prepend: true }`\r\n    // option so the logger places the newest block at the top of the archive.\r\n    try {\r\n      (this.archiveLogFunction as any)(blockLines.join('\\n'), {\r\n        prepend: true,\r\n      });\r\n    } catch {\r\n      // Fallback: if the archive logger doesn't accept options, just append each line\r\n      const append = this.archiveLogFunction ?? (() => {});\r\n      blockLines.forEach((ln) => append(ln));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * update\r\n   *\r\n   * Called by the evolution engine to report the latest candidate solution\r\n   * (or the current best). The dashboard will:\r\n   * - update the currentBest reference used for the live view\r\n   * - if the provided result is a successful solve and it's the first time\r\n   *   we've seen this maze, append an archive block\r\n   * - stash the latest telemetry values into small circular buffers for sparklines\r\n   * - finally call `redraw` to update the live output\r\n   */\r\n  update(\r\n    maze: string[],\r\n    result: any,\r\n    network: INetwork,\r\n    generation: number,\r\n    neatInstance?: any\r\n  ): void {\r\n    // Update live candidate\r\n    this.currentBest = { result, network, generation };\r\n\r\n    // If this run solved the maze and it's a new maze, add & archive it\r\n    if (result.success) {\r\n      const mazeKey = this.getMazeKey(maze);\r\n      if (!this.solvedMazeKeys.has(mazeKey)) {\r\n        this.solvedMazes.push({ maze, result, network, generation });\r\n        this.solvedMazeKeys.add(mazeKey);\r\n        // Append to archive immediately when first solved\r\n        const displayNumber = this.solvedMazes.length; // 1-based\r\n        this.appendSolvedToArchive(\r\n          { maze, result, network, generation },\r\n          displayNumber\r\n        );\r\n      }\r\n    }\r\n\r\n    // Pull the latest telemetry from the NEAT instance (if available)\r\n    const telemetry = neatInstance?.getTelemetry?.();\r\n    if (telemetry && telemetry.length) {\r\n      // Keep only the most recent telemetry object\r\n      this._lastTelemetry = telemetry[telemetry.length - 1];\r\n\r\n      // Record best fitness into a small history window for trend views\r\n      const bestFit = this.currentBest?.result?.fitness;\r\n      if (typeof bestFit === 'number') {\r\n        this._lastBestFitness = bestFit;\r\n        this._bestFitnessHistory.push(bestFit);\r\n        if (this._bestFitnessHistory.length > 500)\r\n          this._bestFitnessHistory.shift();\r\n      }\r\n\r\n      // Complexity telemetry: mean nodes/connectivity across population\r\n      const c = this._lastTelemetry?.complexity;\r\n      if (c) {\r\n        if (typeof c.meanNodes === 'number') {\r\n          this._complexityNodesHistory.push(c.meanNodes);\r\n          if (this._complexityNodesHistory.length > 500)\r\n            this._complexityNodesHistory.shift();\r\n        }\r\n        if (typeof c.meanConns === 'number') {\r\n          this._complexityConnsHistory.push(c.meanConns);\r\n          if (this._complexityConnsHistory.length > 500)\r\n            this._complexityConnsHistory.shift();\r\n        }\r\n      }\r\n\r\n      // Hypervolume is used for multi-objective tracking\r\n      const h = this._lastTelemetry?.hyper;\r\n      if (typeof h === 'number') {\r\n        this._hypervolumeHistory.push(h);\r\n        if (this._hypervolumeHistory.length > 500)\r\n          this._hypervolumeHistory.shift();\r\n      }\r\n\r\n      // Progress: how close a candidate is to the exit\r\n      const prog = this.currentBest?.result?.progress;\r\n      if (typeof prog === 'number') {\r\n        this._progressHistory.push(prog);\r\n        if (this._progressHistory.length > 500) this._progressHistory.shift();\r\n      }\r\n\r\n      // Species count history\r\n      const sc = this._lastTelemetry?.species;\r\n      if (typeof sc === 'number') {\r\n        this._speciesCountHistory.push(sc);\r\n        if (this._speciesCountHistory.length > 500)\r\n          this._speciesCountHistory.shift();\r\n      }\r\n    }\r\n\r\n    // Render the live dashboard\r\n    this.redraw(maze, neatInstance);\r\n  }\r\n\r\n  /**\r\n   * redraw\r\n   *\r\n   * Responsible for clearing the live area and printing a compact snapshot of\r\n   * the current best candidate, a short network summary, the maze drawing and\r\n   * several telemetry-derived stats. The function uses `logFunction` for all\r\n   * output lines so the same renderer can be used both in Node and in the\r\n   * browser (DOM adapter).\r\n   */\r\n  redraw(currentMaze: string[], neat?: any): void {\r\n    // Clear the live area (archive is untouched)\r\n    this.clearFunction();\r\n\r\n    // Header: top frame lines\r\n    this.logFunction(\r\n      `${colors.blueCore}\u2554${NetworkVisualization.pad(\r\n        '\u2550',\r\n        DashboardManager.FRAME_INNER_WIDTH,\r\n        '\u2550'\r\n      )}${colors.blueCore}\u2557${colors.reset}`\r\n    );\r\n    this.logFunction(\r\n      `${colors.blueCore}\u255A${NetworkVisualization.pad(\r\n        '\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566',\r\n        DashboardManager.FRAME_INNER_WIDTH,\r\n        '\u2550'\r\n      )}${colors.blueCore}\u255D${colors.reset}`\r\n    );\r\n    this.logFunction(\r\n      `${colors.blueCore}${NetworkVisualization.pad(\r\n        `\u2551 ${colors.neonYellow}ASCII maze${colors.blueCore} \u2551`,\r\n        150,\r\n        ' '\r\n      )}${colors.reset}`\r\n    );\r\n    this.logFunction(\r\n      `${colors.blueCore}\u2554${NetworkVisualization.pad(\r\n        '\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569',\r\n        DashboardManager.FRAME_INNER_WIDTH,\r\n        '\u2550'\r\n      )}${colors.blueCore}\u2557${colors.reset}`\r\n    );\r\n\r\n    // Print current best for active maze if available\r\n    if (this.currentBest) {\r\n      this.logFunction(\r\n        `${colors.blueCore}\u2560${NetworkVisualization.pad(\r\n          '\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550',\r\n          DashboardManager.FRAME_INNER_WIDTH,\r\n          '\u2550'\r\n        )}${colors.blueCore}\u2563${colors.reset}`\r\n      );\r\n      this.logFunction(\r\n        `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n          `${colors.orangeNeon}EVOLVING (GEN ${this.currentBest.generation})`,\r\n          DashboardManager.FRAME_INNER_WIDTH,\r\n          ' '\r\n        )}${colors.blueCore}\u2551${colors.reset}`\r\n      );\r\n      this.logFunction(\r\n        `${colors.blueCore}\u2560${NetworkVisualization.pad(\r\n          '\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550',\r\n          DashboardManager.FRAME_INNER_WIDTH,\r\n          '\u2550'\r\n        )}${colors.blueCore}\u2563${colors.reset}`\r\n      );\r\n      this.logFunction(\r\n        `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n          ' ',\r\n          DashboardManager.FRAME_INNER_WIDTH,\r\n          ' '\r\n        )}${colors.blueCore}\u2551${colors.reset}`\r\n      );\r\n\r\n      // Network summary (compact visualization)\r\n      this.logFunction(\r\n        `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n          ' ',\r\n          DashboardManager.FRAME_INNER_WIDTH,\r\n          ' '\r\n        )}${colors.blueCore}\u2551${colors.reset}`\r\n      );\r\n      this.logFunction(\r\n        NetworkVisualization.visualizeNetworkSummary(this.currentBest.network)\r\n      );\r\n      this.logFunction(\r\n        `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n          ' ',\r\n          DashboardManager.FRAME_INNER_WIDTH,\r\n          ' '\r\n        )}${colors.blueCore}\u2551${colors.reset}`\r\n      );\r\n\r\n      // Maze visualization for the live candidate\r\n      const lastPos = this.currentBest.result.path[\r\n        this.currentBest.result.path.length - 1\r\n      ];\r\n      const currentMazeVisualization = MazeVisualization.visualizeMaze(\r\n        currentMaze,\r\n        lastPos,\r\n        this.currentBest.result.path\r\n      );\r\n      const currentMazeLines = Array.isArray(currentMazeVisualization)\r\n        ? currentMazeVisualization\r\n        : currentMazeVisualization.split('\\n');\r\n      const centeredCurrentMaze = currentMazeLines\r\n        .map(\r\n          (line) =>\r\n            `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n              line,\r\n              DashboardManager.FRAME_INNER_WIDTH,\r\n              ' '\r\n            )}${colors.blueCore}\u2551`\r\n        )\r\n        .join('\\n');\r\n      this.logFunction(\r\n        `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n          ' ',\r\n          DashboardManager.FRAME_INNER_WIDTH,\r\n          ' '\r\n        )}${colors.blueCore}\u2551${colors.reset}`\r\n      );\r\n      this.logFunction(centeredCurrentMaze);\r\n      this.logFunction(\r\n        `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n          ' ',\r\n          DashboardManager.FRAME_INNER_WIDTH,\r\n          ' '\r\n        )}${colors.blueCore}\u2551${colors.reset}`\r\n      );\r\n\r\n      // Print stats for the current best solution (delegates to MazeVisualization)\r\n      this.logFunction(\r\n        `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n          ' ',\r\n          DashboardManager.FRAME_INNER_WIDTH,\r\n          ' '\r\n        )}${colors.blueCore}\u2551${colors.reset}`\r\n      );\r\n      MazeVisualization.printMazeStats(\r\n        this.currentBest,\r\n        currentMaze,\r\n        this.logFunction\r\n      );\r\n      this.logFunction(\r\n        `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n          ' ',\r\n          DashboardManager.FRAME_INNER_WIDTH,\r\n          ' '\r\n        )}${colors.blueCore}\u2551${colors.reset}`\r\n      );\r\n\r\n      // Progress bar for current candidate\r\n      this.logFunction(\r\n        `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n          ' ',\r\n          DashboardManager.FRAME_INNER_WIDTH,\r\n          ' '\r\n        )}${colors.blueCore}\u2551${colors.reset}`\r\n      );\r\n      this.logFunction(\r\n        (() => {\r\n          const bar = `Progress to exit: ${MazeVisualization.displayProgressBar(\r\n            this.currentBest.result.progress\r\n          )}`;\r\n          return `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n            ' ' + colors.neonSilver + bar + colors.reset,\r\n            DashboardManager.FRAME_INNER_WIDTH,\r\n            ' '\r\n          )}${colors.blueCore}\u2551${colors.reset}`;\r\n        })()\r\n      );\r\n      this.logFunction(\r\n        `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n          ' ',\r\n          DashboardManager.FRAME_INNER_WIDTH,\r\n          ' '\r\n        )}${colors.blueCore}\u2551${colors.reset}`\r\n      );\r\n    }\r\n\r\n    // General stats area (telemetry-derived values). These are defensive reads\r\n    // because telemetry may be missing early in the run.\r\n    const last = this._lastTelemetry;\r\n    const complexity = last?.complexity;\r\n    const perf = last?.perf;\r\n    const lineage = last?.lineage;\r\n    const fronts = Array.isArray(last?.fronts) ? last.fronts : null;\r\n    const objectives = last?.objectives;\r\n    const hyper = last?.hyper;\r\n    const diversity = last?.diversity;\r\n    const mutationStats = last?.mutationStats || last?.mutation?.stats;\r\n    const bestFitness = this.currentBest?.result?.fitness;\r\n\r\n    // Small helpers used below when building the stats list\r\n    const fmtNum = (v: any, digits = 2) =>\r\n      typeof v === 'number' && isFinite(v) ? v.toFixed(digits) : '-';\r\n    const deltaArrow = (curr?: number | null, prev?: number | null) => {\r\n      if (curr == null || prev == null) return '';\r\n      const diff = curr - prev;\r\n      if (Math.abs(diff) < 1e-9) return `${colors.neonSilver} (\u21940)`;\r\n      const color = diff > 0 ? colors.cyanNeon : colors.neonRed;\r\n      const arrow = diff > 0 ? '\u2191' : '\u2193';\r\n      return `${color} (${arrow}${diff.toFixed(2)})${colors.neonSilver}`;\r\n    };\r\n\r\n    // Derive some population-level stats if a NEAT instance is available\r\n    let popMean: any = '-';\r\n    let popMedian: any = '-';\r\n    let speciesCount: any = '-';\r\n    let enabledRatio: any = '-';\r\n    if (neat && Array.isArray(neat.population)) {\r\n      const scores: number[] = [];\r\n      let enabled = 0,\r\n        total = 0;\r\n      neat.population.forEach((g: any) => {\r\n        if (typeof g.score === 'number') scores.push(g.score);\r\n        if (Array.isArray(g.connections)) {\r\n          g.connections.forEach((c: any) => {\r\n            total++;\r\n            if (c.enabled !== false) enabled++;\r\n          });\r\n        }\r\n      });\r\n      if (scores.length) {\r\n        const sum = scores.reduce((a, b) => a + b, 0);\r\n        popMean = (sum / scores.length).toFixed(2);\r\n        const sorted = scores.slice().sort((a, b) => a - b);\r\n        const mid = Math.floor(sorted.length / 2);\r\n        popMedian = (sorted.length % 2 === 0\r\n          ? (sorted[mid - 1] + sorted[mid]) / 2\r\n          : sorted[mid]\r\n        ).toFixed(2);\r\n      }\r\n      if (total) enabledRatio = (enabled / total).toFixed(2);\r\n      speciesCount = Array.isArray(neat.species)\r\n        ? neat.species.length.toString()\r\n        : speciesCount;\r\n    }\r\n\r\n    // Build small sparklines used in the general stats area\r\n    const firstFrontSize = fronts?.[0]?.length || 0;\r\n    const SPARK_WIDTH = 64;\r\n    const spark = this.buildSparkline(this._bestFitnessHistory, SPARK_WIDTH);\r\n    const sparkComplexityNodes = this.buildSparkline(\r\n      this._complexityNodesHistory,\r\n      SPARK_WIDTH\r\n    );\r\n    const sparkComplexityConns = this.buildSparkline(\r\n      this._complexityConnsHistory,\r\n      SPARK_WIDTH\r\n    );\r\n    const sparkHyper = this.buildSparkline(\r\n      this._hypervolumeHistory,\r\n      SPARK_WIDTH\r\n    );\r\n    const sparkProgress = this.buildSparkline(\r\n      this._progressHistory,\r\n      SPARK_WIDTH\r\n    );\r\n    const sparkSpecies = this.buildSparkline(\r\n      this._speciesCountHistory,\r\n      SPARK_WIDTH\r\n    );\r\n\r\n    // Collect stat lines into an array then print via the logFunction so the\r\n    // ordering is explicit and easy to modify for learners exploring the code.\r\n    const statsLines: string[] = [];\r\n    statsLines.push(\r\n      this.formatStat(\r\n        'Current generation',\r\n        `${this.currentBest?.generation || 0}`\r\n      )\r\n    );\r\n    if (typeof bestFitness === 'number')\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Best fitness',\r\n          `${bestFitness.toFixed(2)}${deltaArrow(\r\n            bestFitness,\r\n            this._bestFitnessHistory.length > 1\r\n              ? this._bestFitnessHistory[this._bestFitnessHistory.length - 2]\r\n              : null\r\n          )}`\r\n        )\r\n      );\r\n    const satFrac = (this.currentBest as any)?.result?.saturationFraction;\r\n    if (typeof satFrac === 'number')\r\n      statsLines.push(\r\n        this.formatStat('Saturation fraction', satFrac.toFixed(3))\r\n      );\r\n    const actEnt = (this.currentBest as any)?.result?.actionEntropy;\r\n    if (typeof actEnt === 'number')\r\n      statsLines.push(\r\n        this.formatStat('Action entropy (path)', actEnt.toFixed(3))\r\n      );\r\n    if (popMean === '-' && typeof bestFitness === 'number')\r\n      popMean = bestFitness.toFixed(2);\r\n    if (popMedian === '-' && typeof bestFitness === 'number')\r\n      popMedian = bestFitness.toFixed(2);\r\n    statsLines.push(this.formatStat('Population mean', popMean));\r\n    statsLines.push(this.formatStat('Population median', popMedian));\r\n    if (complexity)\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Complexity mean n/c',\r\n          `${fmtNum(complexity.meanNodes, 2)}/${fmtNum(\r\n            complexity.meanConns,\r\n            2\r\n          )}  max ${fmtNum(complexity.maxNodes, 0)}/${fmtNum(\r\n            complexity.maxConns,\r\n            0\r\n          )}`,\r\n          colors.neonSilver,\r\n          colors.orangeNeon\r\n        )\r\n      );\r\n    if (\r\n      complexity &&\r\n      (complexity.growthNodes < 0 || complexity.growthConns < 0)\r\n    )\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Simplify phase',\r\n          'active',\r\n          colors.neonSilver,\r\n          colors.neonGreen\r\n        )\r\n      );\r\n    if (sparkComplexityNodes)\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Nodes trend',\r\n          sparkComplexityNodes,\r\n          colors.neonSilver,\r\n          colors.neonYellow\r\n        )\r\n      );\r\n    if (sparkComplexityConns)\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Conns trend',\r\n          sparkComplexityConns,\r\n          colors.neonSilver,\r\n          colors.neonYellow\r\n        )\r\n      );\r\n    statsLines.push(this.formatStat('Enabled conn ratio', enabledRatio));\r\n    if (perf && (perf.evalMs != null || perf.evolveMs != null))\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Perf eval/evolve ms',\r\n          `${fmtNum(perf.evalMs, 1)}/${fmtNum(perf.evolveMs, 1)}`\r\n        )\r\n      );\r\n    if (lineage)\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Lineage depth b/mean',\r\n          `${lineage.depthBest}/${fmtNum(lineage.meanDepth, 2)}`\r\n        )\r\n      );\r\n    if (lineage?.inbreeding != null)\r\n      statsLines.push(\r\n        this.formatStat('Inbreeding', fmtNum(lineage.inbreeding, 3))\r\n      );\r\n    if (speciesCount === '-' && typeof last?.species === 'number')\r\n      speciesCount = String(last.species);\r\n    statsLines.push(this.formatStat('Species count', speciesCount));\r\n    if (diversity?.structuralVar != null)\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Structural variance',\r\n          fmtNum(diversity.structuralVar, 3)\r\n        )\r\n      );\r\n    if (diversity?.objectiveSpread != null)\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Objective spread',\r\n          fmtNum(diversity.objectiveSpread, 3)\r\n        )\r\n      );\r\n    if (Array.isArray(neat?.species) && neat.species.length) {\r\n      const sizes = neat.species\r\n        .map((s: any) => s.members?.length || 0)\r\n        .sort((a: number, b: number) => b - a);\r\n      const top3 = sizes.slice(0, 3).join('/') || '-';\r\n      statsLines.push(this.formatStat('Top species sizes', top3));\r\n    }\r\n    if (fronts)\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Pareto fronts',\r\n          `${fronts.map((f: any) => f?.length || 0).join('/')}`\r\n        )\r\n      );\r\n    statsLines.push(\r\n      this.formatStat('First front size', firstFrontSize.toString())\r\n    );\r\n    if (objectives)\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Objectives',\r\n          objectives.join(', '),\r\n          colors.neonSilver,\r\n          colors.neonIndigo\r\n        )\r\n      );\r\n    if (hyper !== undefined)\r\n      statsLines.push(this.formatStat('Hypervolume', fmtNum(hyper, 4)));\r\n    if (sparkHyper)\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Hypervolume trend',\r\n          sparkHyper,\r\n          colors.neonSilver,\r\n          colors.neonGreen\r\n        )\r\n      );\r\n    if (spark)\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Fitness trend',\r\n          spark,\r\n          colors.neonSilver,\r\n          colors.neonYellow\r\n        )\r\n      );\r\n    if (sparkProgress)\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Progress trend',\r\n          sparkProgress,\r\n          colors.neonSilver,\r\n          colors.cyanNeon\r\n        )\r\n      );\r\n    if (sparkSpecies)\r\n      statsLines.push(\r\n        this.formatStat(\r\n          'Species trend',\r\n          sparkSpecies,\r\n          colors.neonSilver,\r\n          colors.neonIndigo\r\n        )\r\n      );\r\n    if (neat?.getNoveltyArchiveSize) {\r\n      try {\r\n        const nov = neat.getNoveltyArchiveSize();\r\n        statsLines.push(this.formatStat('Novelty archive', `${nov}`));\r\n      } catch {}\r\n    }\r\n    if (neat?.getOperatorStats) {\r\n      try {\r\n        const ops = neat.getOperatorStats();\r\n        if (Array.isArray(ops) && ops.length) {\r\n          const top = ops\r\n            .slice()\r\n            .sort(\r\n              (a: any, b: any) =>\r\n                b.success / Math.max(1, b.attempts) -\r\n                a.success / Math.max(1, a.attempts)\r\n            )\r\n            .slice(0, 4)\r\n            .map(\r\n              (o: any) =>\r\n                `${o.name}:${(\r\n                  (100 * o.success) /\r\n                  Math.max(1, o.attempts)\r\n                ).toFixed(0)}%`\r\n            )\r\n            .join(' ');\r\n          if (top)\r\n            statsLines.push(\r\n              this.formatStat(\r\n                'Op acceptance',\r\n                top,\r\n                colors.neonSilver,\r\n                colors.neonGreen\r\n              )\r\n            );\r\n        }\r\n      } catch {}\r\n    }\r\n    if (mutationStats && typeof mutationStats === 'object') {\r\n      const entries = Object.entries(mutationStats)\r\n        .filter(([k, v]) => typeof v === 'number')\r\n        .sort((a, b) => (b[1] as number) - (a[1] as number))\r\n        .slice(0, 5)\r\n        .map(([k, v]) => `${k}:${(v as number).toFixed(0)}`)\r\n        .join(' ');\r\n      if (entries)\r\n        statsLines.push(\r\n          this.formatStat(\r\n            'Top mutations',\r\n            entries,\r\n            colors.neonSilver,\r\n            colors.neonGreen\r\n          )\r\n        );\r\n    }\r\n\r\n    // Emit collected stat lines using the supplied log function\r\n    statsLines.forEach((ln) => this.logFunction(ln));\r\n    this.logFunction(\r\n      `${colors.blueCore}\u2551${NetworkVisualization.pad(\r\n        ' ',\r\n        DashboardManager.FRAME_INNER_WIDTH,\r\n        ' '\r\n      )}${colors.blueCore}\u2551${colors.reset}`\r\n    );\r\n  }\r\n\r\n  reset(): void {\r\n    this.solvedMazes = [];\r\n    this.solvedMazeKeys.clear();\r\n    this.currentBest = null;\r\n  }\r\n}\r\n", "export { default as Neat } from './neat';\r\nexport { default as Network } from './architecture/network';\r\nexport { default as Node } from './architecture/node';\r\nexport { default as Layer } from './architecture/layer';\r\nexport { default as Group } from './architecture/group';\r\nexport { default as Connection } from './architecture/connection';\r\nexport { default as Architect } from './architecture/architect';\r\nexport * as methods from './methods/methods';\r\nexport * as config from './config';\r\nexport * as multi from './multithreading/multi';\r\n", "import Node from './node';\r\nimport Layer from './layer';\r\nimport Group from './group';\r\nimport Network from './network';\r\nimport * as methods from '../methods/methods';\r\nimport Connection from './connection'; // Ensure Connection is imported for type checking\r\n\r\n/**\r\n * Provides static methods for constructing various predefined neural network architectures.\r\n *\r\n * The Architect class simplifies the creation of common network types like Multi-Layer Perceptrons (MLPs),\r\n * Long Short-Term Memory (LSTM) networks, Gated Recurrent Units (GRUs), and more complex structures\r\n * inspired by neuro-evolutionary algorithms. It leverages the underlying `Layer`, `Group`, and `Node`\r\n * components to build interconnected `Network` objects.\r\n *\r\n * Methods often utilize helper functions from `Layer` (e.g., `Layer.dense`, `Layer.lstm`) and\r\n * connection strategies from `methods.groupConnection`.\r\n *\r\n * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6#3-mutation Instinct Algorithm - Section 3 Mutation} - Some methods like `random` are inspired by concepts discussed here.\r\n */\r\nexport default class Architect {\r\n  /**\r\n   * Constructs a Network instance from an array of interconnected Layers, Groups, or Nodes.\r\n   *\r\n   * This method processes the input list, extracts all unique nodes, identifies connections,\r\n   * gates, and self-connections, and determines the network's input and output sizes based\r\n   * on the `type` property ('input' or 'output') set on the nodes. It uses Sets internally\r\n   * for efficient handling of unique elements during construction.\r\n   *\r\n   * @param {Array<Group | Layer | Node>} list - An array containing the building blocks (Nodes, Layers, Groups) of the network, assumed to be already interconnected.\r\n   * @returns {Network} A Network object representing the constructed architecture.\r\n   * @throws {Error} If the input/output nodes cannot be determined (e.g., no nodes are marked with type 'input' or 'output').\r\n   * @throws {Error} If the constructed network has zero input or output nodes after processing the list.\r\n   */\r\n  static construct(list: Array<Group | Layer | Node>): Network {\r\n    // Initialize a new Network with placeholder input/output sizes (0, 0).\r\n    // These will be determined during the construction process.\r\n    const network = new Network(0, 0);\r\n    // Use Sets for efficient storage and retrieval of unique nodes and connections.\r\n    const uniqueNodes = new Set<Node>();\r\n    const connections = new Set<Connection>(); // Regular forward connections\r\n    const gates = new Set<Connection>(); // Gating connections\r\n    const selfconns = new Set<Connection>(); // Self-connections (node to itself)\r\n    let inputSize = 0; // Counter for nodes identified as input nodes\r\n    let outputSize = 0; // Counter for nodes identified as output nodes\r\n    let foundTypes = false; // Flag to track if any node had its 'type' property set.\r\n\r\n    // Iterate through the provided list of Layers, Groups, or Nodes.\r\n    for (const item of list) {\r\n      let currentNodes: Node[] = [];\r\n      // Extract nodes based on the type of the item (Group, Layer, or Node).\r\n      if (item instanceof Group) {\r\n        currentNodes = item.nodes;\r\n      } else if (item instanceof Layer) {\r\n        // Layers can potentially contain Groups (though typically contain Nodes).\r\n        // Flatten the structure to get individual nodes.\r\n        for (const layerNode of item.nodes) {\r\n          if (layerNode instanceof Group) {\r\n            currentNodes.push(...layerNode.nodes);\r\n          } else if (layerNode instanceof Node) {\r\n            currentNodes.push(layerNode);\r\n          }\r\n        }\r\n      } else if (item instanceof Node) {\r\n        // If the item is already a Node, add it directly.\r\n        currentNodes = [item];\r\n      }\r\n\r\n      // Process each node extracted from the current item.\r\n      for (const node of currentNodes) {\r\n        // Add the node to the set of unique nodes if it hasn't been added yet.\r\n        if (!uniqueNodes.has(node)) {\r\n          uniqueNodes.add(node);\r\n\r\n          // Check the node's type to determine if it's an input or output node.\r\n          // The 'type' property must be explicitly set on the nodes beforehand.\r\n          if (node.type === 'input') {\r\n            inputSize++;\r\n            foundTypes = true; // Mark that we found at least one node with a type.\r\n          } else if (node.type === 'output') {\r\n            outputSize++;\r\n            foundTypes = true; // Mark that we found at least one node with a type.\r\n          }\r\n\r\n          // Collect all outgoing, gated, and self-connections associated with this node.\r\n          // Ensure connections are valid Connection objects before adding to Sets.\r\n          if (node.connections) {\r\n            if (Array.isArray(node.connections.out)) {\r\n              node.connections.out.forEach((conn) => {\r\n                if (conn instanceof Connection) connections.add(conn);\r\n              });\r\n            }\r\n            if (Array.isArray(node.connections.gated)) {\r\n              node.connections.gated.forEach((conn) => {\r\n                if (conn instanceof Connection) gates.add(conn);\r\n              });\r\n            }\r\n            // Add self-connection only if it exists (array is not empty) and has a non-zero weight.\r\n            if (\r\n              node.connections.self.length > 0 && // Check if array has elements\r\n              node.connections.self[0] instanceof Connection && // Check type of first element\r\n              node.connections.self[0].weight !== 0 // Access weight of first element\r\n            ) {\r\n              selfconns.add(node.connections.self[0]); // Add the Connection object\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // After processing all items, check if input and output sizes were determined.\r\n    if (inputSize > 0 && outputSize > 0) {\r\n      network.input = inputSize;\r\n      network.output = outputSize;\r\n    } else {\r\n      // If no nodes were explicitly typed as 'input' or 'output', or if either count is zero,\r\n      // the network structure is ambiguous or incomplete.\r\n      if (!foundTypes || inputSize === 0 || outputSize === 0) {\r\n        throw new Error(\r\n          'Could not determine input/output nodes. Ensure nodes have their `type` property set to \"input\" or \"output\".'\r\n        );\r\n      }\r\n      // Note: A previous fallback mechanism existed here but was removed for stricter type enforcement.\r\n      // Layers/Groups themselves don't inherently define network I/O; individual nodes must be typed.\r\n    }\r\n\r\n    // Populate the network object with the collected nodes and connections.\r\n    network.nodes = Array.from(uniqueNodes);\r\n    network.connections = Array.from(connections);\r\n    network.gates = Array.from(gates);\r\n    network.selfconns = Array.from(selfconns);\r\n\r\n    // Final validation to ensure the network is viable.\r\n    if (network.input === 0 || network.output === 0) {\r\n      // This check is somewhat redundant due to the earlier error throw, but serves as a safeguard.\r\n      throw new Error('Constructed network has zero input or output nodes.');\r\n    }\r\n\r\n    return network;\r\n  }\r\n\r\n  /**\r\n   * Creates a standard Multi-Layer Perceptron (MLP) network.\r\n   * An MLP consists of an input layer, one or more hidden layers, and an output layer,\r\n   * fully connected layer by layer.\r\n   *\r\n   * @param {...number} layers - A sequence of numbers representing the size (number of nodes) of each layer, starting with the input layer, followed by hidden layers, and ending with the output layer. Must include at least input, one hidden, and output layer sizes.\r\n   * @returns {Network} The constructed MLP network.\r\n   * @throws {Error} If fewer than 3 layer sizes (input, hidden, output) are provided.\r\n   */\r\n  static perceptron(...layers: number[]): Network {\r\n    if (layers.length < 3) {\r\n      throw new Error(\r\n        'Invalid MLP configuration: You must specify at least 3 layer sizes (input, hidden, output).'\r\n      );\r\n    }\r\n\r\n    // Compute minimum hidden size\r\n    const inputSize = layers[0];\r\n    const outputSize = layers[layers.length - 1];\r\n    const minHidden = Math.min(inputSize, outputSize) + 1;\r\n\r\n    // Create the input layer using Layer.dense for a standard fully connected layer.\r\n    const inputLayer = Layer.dense(inputSize);\r\n    // Mark nodes in this layer as network inputs.\r\n    inputLayer.set({ type: 'input' });\r\n\r\n    // Initialize the list of network components (layers/groups) and track the previous layer for connection.\r\n    const nodes: (Layer | Group)[] = [inputLayer];\r\n    let previousLayer: Layer | Group = inputLayer;\r\n\r\n    // Create hidden layers and the output layer.\r\n    for (let i = 1; i < layers.length; i++) {\r\n      // For hidden layers, enforce minimum size\r\n      let layerSize = layers[i];\r\n      if (i !== layers.length - 1 && layerSize < minHidden) {\r\n        layerSize = minHidden;\r\n      }\r\n      const currentLayer = Layer.dense(layerSize);\r\n      // Mark the final layer's nodes as network outputs.\r\n      if (i === layers.length - 1) {\r\n        currentLayer.set({ type: 'output' });\r\n      }\r\n      // Connect the previous layer to the current layer using a full mesh connection.\r\n      (previousLayer as Layer).connect(\r\n        currentLayer,\r\n        methods.groupConnection.ALL_TO_ALL // Every node in previousLayer connects to every node in currentLayer.\r\n      );\r\n      nodes.push(currentLayer); // Add the new layer to the list of network components.\r\n      previousLayer = currentLayer; // Update the reference to the previous layer.\r\n    }\r\n\r\n    // Construct the final Network object from the assembled layers.\r\n    const net = Architect.construct(nodes);\r\n    // Attach ordered Layer instances (excluding any Group) to enable layer-based features (e.g. stochastic depth)\r\n    (net as any).layers = nodes.filter((n) => n instanceof Layer);\r\n    return net;\r\n  }\r\n\r\n  /**\r\n   * Creates a randomly structured network based on specified node counts and connection options.\r\n   *\r\n   * This method allows for the generation of networks with a less rigid structure than MLPs.\r\n   * It initializes a network with input and output nodes and then iteratively adds hidden nodes\r\n   * and various types of connections (forward, backward, self) and gates using mutation methods.\r\n   * This approach is inspired by neuro-evolution techniques where network topology evolves.\r\n   *\r\n   * @see {@link https://medium.com/data-science/neuro-evolution-on-steroids-82bd14ddc2f6#3-mutation Instinct Algorithm - Section 3 Mutation}\r\n   *\r\n   * @param {number} input - The number of input nodes.\r\n   * @param {number} hidden - The number of hidden nodes to add.\r\n   * @param {number} output - The number of output nodes.\r\n   * @param {object} [options] - Optional configuration for the network structure.\r\n   * @param {number} [options.connections=hidden*2] - The target number of forward connections to add (in addition to initial hidden node connections). Defaults to `hidden * 2`.\r\n   * @param {number} [options.backconnections=0] - The target number of recurrent (backward) connections to add. Defaults to 0.\r\n   * @param {number} [options.selfconnections=0] - The target number of self-connections (node connecting to itself) to add. Defaults to 0.\r\n   * @param {number} [options.gates=0] - The target number of gating connections to add. Defaults to 0.\r\n   * @returns {Network} The constructed network with a randomized topology.\r\n   */\r\n  static random(\r\n    input: number,\r\n    hidden: number,\r\n    output: number,\r\n    options: {\r\n      connections?: number;\r\n      backconnections?: number;\r\n      selfconnections?: number;\r\n      gates?: number;\r\n    } = {}\r\n  ): Network {\r\n    // Set default values for optional parameters if not provided.\r\n    const {\r\n      connections = hidden * 2, // Default connections aim for reasonable density.\r\n      backconnections = 0,\r\n      selfconnections = 0,\r\n      gates = 0,\r\n    } = options;\r\n\r\n    // Initialize a base network with the specified input and output sizes.\r\n    // Input and output nodes are created automatically by the Network constructor.\r\n    const network = new Network(input, output);\r\n\r\n    // Add the specified number of hidden nodes using the ADD_NODE mutation.\r\n    // This mutation typically adds a node by splitting an existing connection.\r\n    for (let i = 0; i < hidden; i++) {\r\n      network.mutate(methods.mutation.ADD_NODE);\r\n    }\r\n\r\n    // Add forward connections using the ADD_CONN mutation.\r\n    // This mutation adds a connection between two previously unconnected nodes.\r\n    // Note: The initial hidden node additions also create connections, so we add `connections - hidden` more.\r\n    for (let i = 0; i < connections - hidden; i++) {\r\n      network.mutate(methods.mutation.ADD_CONN);\r\n    }\r\n\r\n    // Add recurrent (backward) connections using the ADD_BACK_CONN mutation.\r\n    for (let i = 0; i < backconnections; i++) {\r\n      network.mutate(methods.mutation.ADD_BACK_CONN);\r\n    }\r\n\r\n    // Add self-connections using the ADD_SELF_CONN mutation.\r\n    for (let i = 0; i < selfconnections; i++) {\r\n      network.mutate(methods.mutation.ADD_SELF_CONN);\r\n    }\r\n\r\n    // Add gating connections using the ADD_GATE mutation.\r\n    // This adds a connection where one node controls the flow through another connection.\r\n    for (let i = 0; i < gates; i++) {\r\n      network.mutate(methods.mutation.ADD_GATE);\r\n    }\r\n\r\n    // Return the network with the generated topology.\r\n    return network;\r\n  }\r\n\r\n  /**\r\n   * Creates a Long Short-Term Memory (LSTM) network.\r\n   * LSTMs are a type of recurrent neural network (RNN) capable of learning long-range dependencies.\r\n   * This constructor uses `Layer.lstm` to create the core LSTM blocks.\r\n   *\r\n   * @param {...(number | object)} layerArgs - A sequence of arguments defining the network structure:\r\n   *   - Numbers represent the size (number of units) of each layer: input layer size, hidden LSTM layer sizes..., output layer size.\r\n   *   - An optional configuration object can be provided as the last argument.\r\n   * @param {object} [options] - Configuration options (if passed as the last argument).\r\n   * @param {boolean} [options.inputToOutput=true] - If true, creates direct connections from the input layer to the output layer, bypassing the LSTM layers. Defaults to true.\r\n   * @returns {Network} The constructed LSTM network.\r\n   * @throws {Error} If fewer than 3 numerical layer sizes (input, hidden, output) are provided.\r\n   * @throws {Error} If any layer size argument is not a positive finite number.\r\n   */\r\n  static lstm(...layerArgs: (number | { inputToOutput?: boolean })[]): Network {\r\n    let options: { inputToOutput?: boolean } = {};\r\n    let layers: number[] = [];\r\n\r\n    // Check if the last argument is an options object.\r\n    if (\r\n      layerArgs.length > 0 &&\r\n      typeof layerArgs[layerArgs.length - 1] === 'object' &&\r\n      layerArgs[layerArgs.length - 1] !== null &&\r\n      !Array.isArray(layerArgs[layerArgs.length - 1])\r\n    ) {\r\n      // Pop the options object from the arguments array.\r\n      options = layerArgs.pop() as { inputToOutput?: boolean };\r\n    }\r\n\r\n    // Validate that the remaining arguments are positive numbers representing layer sizes.\r\n    if (\r\n      !layerArgs.every(\r\n        (arg): arg is number =>\r\n          typeof arg === 'number' && Number.isFinite(arg) && arg > 0\r\n      )\r\n    ) {\r\n      throw new Error(\r\n        'Invalid LSTM layer arguments: All layer sizes must be positive finite numbers.'\r\n      );\r\n    }\r\n    layers = layerArgs as number[]; // Type assertion is safe after validation.\r\n\r\n    // Ensure at least input, one hidden (LSTM), and output layers are specified.\r\n    if (layers.length < 3) {\r\n      throw new Error(\r\n        'Invalid LSTM configuration: You must specify at least 3 layer sizes (input, hidden..., output).'\r\n      );\r\n    }\r\n\r\n    // Apply default value for the inputToOutput option if not provided.\r\n    const { inputToOutput = true } = options;\r\n\r\n    // Extract input and output layer sizes. The remaining numbers in 'layers' are hidden layer sizes.\r\n    const inputLayerSize = layers.shift()!; // Non-null assertion is safe due to length check.\r\n    const outputLayerSize = layers.pop()!; // Non-null assertion is safe due to length check.\r\n\r\n    // Create the input layer.\r\n    const inputLayer = Layer.dense(inputLayerSize);\r\n    inputLayer.set({ type: 'input' }); // Mark nodes as network inputs.\r\n\r\n    // Create the output layer.\r\n    const outputLayer = Layer.dense(outputLayerSize);\r\n    outputLayer.set({ type: 'output' }); // Mark nodes as network outputs.\r\n\r\n    // Initialize the list of network components and track the previous layer.\r\n    const nodes: (Layer | Group)[] = [inputLayer];\r\n    let previousLayer: Layer | Group = inputLayer;\r\n\r\n    // Create the hidden LSTM layers.\r\n    for (const layerSize of layers) {\r\n      // Iterate through the specified hidden layer sizes.\r\n      // Create an LSTM layer (which is internally a Group of nodes: input, forget, output, memory cells).\r\n      const lstmLayer = Layer.lstm(layerSize);\r\n      // Connect the previous layer to the LSTM layer. The default connection typically targets the input gates.\r\n      (previousLayer as Layer).connect(lstmLayer);\r\n      nodes.push(lstmLayer); // Add the LSTM layer group to the network components.\r\n      previousLayer = lstmLayer; // Update the reference to the previous layer.\r\n    }\r\n\r\n    // Connect the last hidden/LSTM layer to the output layer.\r\n    (previousLayer as Layer).connect(outputLayer); // Default connection.\r\n    nodes.push(outputLayer); // Add the output layer to the list.\r\n\r\n    // Optionally, add direct connections from the input layer to the output layer.\r\n    if (inputToOutput) {\r\n      inputLayer.connect(outputLayer, methods.groupConnection.ALL_TO_ALL);\r\n    }\r\n\r\n    // Construct the final Network object from the assembled layers and groups.\r\n    const network = Architect.construct(nodes);\r\n\r\n    // Explicitly set the input and output sizes on the final Network object,\r\n    // as the construct method relies on node types which might not cover all cases perfectly,\r\n    // especially with complex groups like LSTMs.\r\n    network.input = inputLayerSize;\r\n    network.output = outputLayerSize;\r\n\r\n    return network;\r\n  }\r\n\r\n  /**\r\n   * Creates a Gated Recurrent Unit (GRU) network.\r\n   * GRUs are another type of recurrent neural network, similar to LSTMs but often simpler.\r\n   * This constructor uses `Layer.gru` to create the core GRU blocks.\r\n   *\r\n   * @param {...number} layers - A sequence of numbers representing the size (number of units) of each layer: input layer size, hidden GRU layer sizes..., output layer size. Must include at least input, one hidden, and output layer sizes.\r\n   * @returns {Network} The constructed GRU network.\r\n   * @throws {Error} If fewer than 3 layer sizes (input, hidden, output) are provided.\r\n   */\r\n  static gru(...layers: number[]): Network {\r\n    // Ensure at least input, one hidden (GRU), and output layers are specified.\r\n    if (layers.length < 3) {\r\n      throw new Error(\r\n        'Invalid GRU configuration: You must specify at least 3 layer sizes (input, hidden..., output).'\r\n      );\r\n    }\r\n\r\n    // Extract input and output layer sizes.\r\n    const inputLayerSize = layers.shift()!;\r\n    const outputLayerSize = layers.pop()!;\r\n    // 'layers' now contains only hidden GRU layer sizes.\r\n\r\n    // Create the input layer.\r\n    const inputLayer = Layer.dense(inputLayerSize);\r\n    inputLayer.set({ type: 'input' }); // Mark nodes as network inputs.\r\n\r\n    // Create the output layer.\r\n    const outputLayer = Layer.dense(outputLayerSize);\r\n    outputLayer.set({ type: 'output' }); // Mark nodes as network outputs.\r\n\r\n    // Initialize the list of network components and track the previous layer.\r\n    const nodes: (Layer | Group)[] = [inputLayer];\r\n    let previousLayer: Layer | Group = inputLayer;\r\n\r\n    // Create the hidden GRU layers.\r\n    for (const blockSize of layers) {\r\n      // Iterate through the specified hidden layer sizes.\r\n      // Create a GRU layer (internally a Group of nodes: update gate, reset gate, hidden state).\r\n      const gruLayer = Layer.gru(blockSize);\r\n      // Connect the previous layer to the GRU layer. Default connection targets appropriate gates.\r\n      (previousLayer as Layer).connect(gruLayer);\r\n      nodes.push(gruLayer); // Add the GRU layer group to the network components.\r\n      previousLayer = gruLayer; // Update the reference to the previous layer.\r\n    }\r\n\r\n    // Connect the last hidden/GRU layer to the output layer.\r\n    (previousLayer as Layer).connect(outputLayer);\r\n    nodes.push(outputLayer); // Add the output layer to the list.\r\n\r\n    // Construct the final Network object.\r\n    const network = Architect.construct(nodes);\r\n\r\n    // Explicitly set the input and output sizes on the final Network object for clarity and robustness.\r\n    network.input = inputLayerSize;\r\n    network.output = outputLayerSize;\r\n\r\n    return network;\r\n  }\r\n\r\n  /**\r\n   * Creates a Hopfield network.\r\n   * Hopfield networks are a form of recurrent neural network often used for associative memory tasks.\r\n   * This implementation creates a simple, fully connected structure.\r\n   *\r\n   * @param {number} size - The number of nodes in the network (input and output layers will have this size).\r\n   * @returns {Network} The constructed Hopfield network.\r\n   */\r\n  static hopfield(size: number): Network {\r\n    // Create input and output layers of the specified size.\r\n    const inputLayer = Layer.dense(size);\r\n    const outputLayer = Layer.dense(size);\r\n\r\n    // Create a full connection between the input and output layers.\r\n    // Note: Traditional Hopfield networks often have connections within a single layer,\r\n    // but this structure represents a common feedforward variant or interpretation.\r\n    // For a classic Hopfield, one might connect a layer to itself (ALL_TO_ALL excluding self).\r\n    inputLayer.connect(outputLayer, methods.groupConnection.ALL_TO_ALL);\r\n\r\n    // Mark the input layer nodes.\r\n    inputLayer.set({ type: 'input' });\r\n    // Mark the output layer nodes and set their activation function to a step function, typical for Hopfield networks.\r\n    outputLayer.set({ squash: methods.Activation.step, type: 'output' });\r\n\r\n    // Construct the network from the two layers.\r\n    return Architect.construct([inputLayer, outputLayer]);\r\n  }\r\n\r\n  /**\r\n   * Creates a Nonlinear AutoRegressive network with eXogenous inputs (NARX).\r\n   * NARX networks are recurrent networks often used for time series prediction.\r\n   * They predict the next value of a time series based on previous values of the series\r\n   * and previous values of external (exogenous) input series.\r\n   *\r\n   * @param {number} inputSize - The number of input nodes for the exogenous inputs at each time step.\r\n   * @param {number | number[]} hiddenLayers - The size of the hidden layer(s). Can be a single number for one hidden layer, or an array of numbers for multiple hidden layers. Use 0 or [] for no hidden layers.\r\n   * @param {number} outputSize - The number of output nodes (predicting the time series).\r\n   * @param {number} previousInput - The number of past time steps of the exogenous input to feed back into the network.\r\n   * @param {number} previousOutput - The number of past time steps of the network's own output to feed back into the network (autoregressive part).\r\n   * @returns {Network} The constructed NARX network.\r\n   */\r\n  static narx(\r\n    inputSize: number,\r\n    hiddenLayers: number | number[],\r\n    outputSize: number,\r\n    previousInput: number, // Input delay taps\r\n    previousOutput: number // Output delay taps\r\n  ): Network {\r\n    // Ensure hiddenLayers is an array, even if a single number or zero is provided.\r\n    if (!Array.isArray(hiddenLayers)) {\r\n      hiddenLayers = hiddenLayers > 0 ? [hiddenLayers] : []; // Convert number to array or empty array if 0.\r\n    }\r\n\r\n    // Create the main input layer for current exogenous inputs.\r\n    const input = Layer.dense(inputSize);\r\n    // Create a memory layer to hold 'previousInput' past values of the input.\r\n    const inputMemory = Layer.memory(inputSize, previousInput);\r\n    // Create the main output layer.\r\n    const output = Layer.dense(outputSize);\r\n    // Create a memory layer to hold 'previousOutput' past values of the output.\r\n    const outputMemory = Layer.memory(outputSize, previousOutput);\r\n\r\n    // Mark input and output layers appropriately.\r\n    input.set({ type: 'input' });\r\n    output.set({ type: 'output' });\r\n\r\n    // Connect the main input layer to its corresponding memory layer.\r\n    // A weight of 1 ensures the current input is stored for the next time step.\r\n    input.connect(inputMemory, methods.groupConnection.ONE_TO_ONE, 1);\r\n    // Connect the main output layer to its corresponding memory layer.\r\n    // A weight of 1 ensures the current output is stored for the next time step.\r\n    output.connect(outputMemory, methods.groupConnection.ONE_TO_ONE, 1);\r\n\r\n    const hidden: Layer[] = []; // Array to hold created hidden layers.\r\n    let previousLayer: Layer | Group = input; // Start connections from the input layer.\r\n    // Initialize the list of network components. Memory layers are included early.\r\n    const nodes: (Layer | Group)[] = [input, inputMemory, outputMemory];\r\n\r\n    // This layer will receive inputs from the main input AND the memory layers.\r\n    // It's either the first hidden layer or the output layer if no hidden layers exist.\r\n    let firstProcessingLayer: Layer | Group;\r\n\r\n    // Create hidden layers if specified.\r\n    if (hiddenLayers.length > 0) {\r\n      for (let i = 0; i < hiddenLayers.length; i++) {\r\n        const size = hiddenLayers[i];\r\n        const hiddenLayer = Layer.dense(size);\r\n        hidden.push(hiddenLayer);\r\n        nodes.push(hiddenLayer); // Add hidden layer to the network components.\r\n\r\n        // Connect the previous layer (input or preceding hidden layer) to the current hidden layer.\r\n        (previousLayer as Layer).connect(\r\n          hiddenLayer,\r\n          methods.groupConnection.ALL_TO_ALL\r\n        );\r\n        previousLayer = hiddenLayer; // Update previous layer for the next connection.\r\n\r\n        // Identify the first hidden layer as the target for memory inputs.\r\n        if (i === 0) {\r\n          firstProcessingLayer = hiddenLayer;\r\n        }\r\n      }\r\n      // Connect the last hidden layer to the output layer.\r\n      (previousLayer as Layer).connect(\r\n        output,\r\n        methods.groupConnection.ALL_TO_ALL\r\n      );\r\n    } else {\r\n      // No hidden layers: connect the main input layer directly to the output layer.\r\n      input.connect(output, methods.groupConnection.ALL_TO_ALL);\r\n      // In this case, the output layer is the first processing layer receiving memory inputs.\r\n      firstProcessingLayer = output;\r\n    }\r\n\r\n    nodes.push(output); // Add the output layer to the list of components.\r\n\r\n    // Connect the memory layers to the first processing layer (first hidden layer or output layer).\r\n    // These connections provide the historical context (past inputs and outputs).\r\n    // Use ALL_TO_ALL connection: every memory node connects to every node in the target layer.\r\n    inputMemory.connect(\r\n      firstProcessingLayer!,\r\n      methods.groupConnection.ALL_TO_ALL\r\n    ); // Non-null assertion safe due to logic above.\r\n    outputMemory.connect(\r\n      firstProcessingLayer!,\r\n      methods.groupConnection.ALL_TO_ALL\r\n    ); // Non-null assertion safe due to logic above.\r\n\r\n    // Construct the final Network object.\r\n    const network = Architect.construct(nodes);\r\n\r\n    // Explicitly set the input and output sizes for the final network object.\r\n    // Input size corresponds to the exogenous input dimension.\r\n    // Output size corresponds to the predicted time series dimension.\r\n    network.input = inputSize;\r\n    network.output = outputSize;\r\n\r\n    return network;\r\n  }\r\n\r\n  /**\r\n   * Enforces the minimum hidden layer size rule on a network.\r\n   *\r\n   * This ensures that all hidden layers have at least min(input, output) + 1 nodes,\r\n   * which is a common heuristic to ensure networks have adequate representation capacity.\r\n   *\r\n   * @param {Network} network - The network to enforce minimum hidden layer sizes on\r\n   * @returns {Network} The same network with properly sized hidden layers\r\n   */\r\n  static enforceMinimumHiddenLayerSizes(network: Network): Network {\r\n    if (!network.layers || network.layers.length <= 2) {\r\n      // No hidden layers to resize\r\n      return network;\r\n    }\r\n\r\n    // Calculate minimum size for hidden layers\r\n    const minSize = Math.min(network.input, network.output) + 1;\r\n\r\n    // Adjust all hidden layers (skip input and output layers)\r\n    for (let i = 1; i < network.layers.length - 1; i++) {\r\n      const hiddenLayer = network.layers[i];\r\n      const currentSize = hiddenLayer.nodes.length;\r\n\r\n      if (currentSize < minSize) {\r\n        // Create the additional nodes needed\r\n        for (let j = currentSize; j < minSize; j++) {\r\n          const newNode = new Node('hidden');\r\n          hiddenLayer.nodes.push(newNode);\r\n\r\n          // Add node to network's node list\r\n          network.nodes.push(newNode);\r\n\r\n          // Connect to previous layer\r\n          if (i > 0 && network.layers[i - 1].output) {\r\n            for (const prevNode of network.layers[i - 1].output.nodes) {\r\n              const connections = prevNode.connect(newNode);\r\n              // Fix: Spread the connections array into individual connections\r\n              network.connections.push(...connections);\r\n            }\r\n          }\r\n\r\n          // Connect to next layer\r\n          if (i < network.layers.length - 1 && network.layers[i + 1].output) {\r\n            for (const nextNode of network.layers[i + 1].output.nodes) {\r\n              const connections = newNode.connect(nextNode);\r\n              // Fix: Spread the connections array into individual connections\r\n              network.connections.push(...connections);\r\n            }\r\n          }\r\n\r\n          // If this layer has an output group, add the node to it\r\n          if (hiddenLayer.output && Array.isArray(hiddenLayer.output.nodes)) {\r\n            hiddenLayer.output.nodes.push(newNode);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return network;\r\n  }\r\n}\r\n", "/**\r\n * @file Implements the agent's \"vision\" system, which processes the maze environment into numerical inputs for the neural network.\r\n *\r\n * @description\r\n * This module defines the `MazeVision` class, responsible for creating the sensory input vector that the agent's neural network\r\n * uses to make decisions. The vision system is sophisticated, providing not just immediate surroundings but also long-range,\r\n * goal-oriented information. This rich sensory data is crucial for enabling the agent to learn complex navigation strategies.\r\n *\r\n * The vision system generates a 6-dimensional input vector:\r\n * 1.  **Compass Scalar**: A value in `{0, 0.25, 0.5, 0.75}` indicating the general direction of the exit (N, E, S, W).\r\n *     This acts as a global guide, always pointing towards the goal.\r\n * 2.  **Openness North**: A value from 0 to 1 representing the quality of the path starting with a move to the North.\r\n * 3.  **Openness East**: Path quality for East.\r\n * 4.  **Openness South**: Path quality for South.\r\n * 5.  **Openness West**: Path quality for West.\r\n * 6.  **Progress Delta**: A value indicating recent progress towards or away from the exit.\r\n *\r\n * The \"Openness\" values are calculated using a long-range lookahead based on a pre-computed `distanceMap`. A value of `1`\r\n * indicates the best possible path from the current location, while values less than `1` represent suboptimal but still viable paths.\r\n * A value of `0` signifies a wall, a dead end, or a path that moves away from the exit. This allows the network to make\r\n * informed decisions based on the long-term consequences of a move, rather than just immediate obstacles.\r\n */\r\nexport class MazeVision {\r\n  /**\r\n   * Constructs the 6-dimensional input vector for the neural network based on the agent's current state.\r\n   *\r\n   * @param encodedMaze - The 2D numerical representation of the maze.\r\n   * @param position - The agent's current `[x, y]` coordinates.\r\n   * @param exitPos - The coordinates of the maze exit.\r\n   * @param distanceMap - A pre-calculated map of distances from each cell to the exit.\r\n   * @param prevDistance - The agent's distance to the exit from the previous step.\r\n   * @param currentDistance - The agent's current distance to the exit.\r\n   * @param prevAction - The last action taken by the agent (0:N, 1:E, 2:S, 3:W).\r\n   * @returns A 6-element array of numbers representing the network inputs.\r\n   */\r\n  static buildInputs6(\r\n    encodedMaze: number[][],\r\n    agentPosition: [number, number],\r\n    exitPosition: [number, number],\r\n    distanceToExitMap: number[][] | undefined,\r\n    previousStepDistance: number | undefined,\r\n    currentStepDistance: number,\r\n    previousAction: number | undefined\r\n  ): number[] {\r\n    // --- Initialization ---\r\n    /**\r\n     * Agent's current X and Y coordinates\r\n     */\r\n    const [agentX, agentY] = agentPosition;\r\n    /**\r\n     * Number of rows in the maze\r\n     */\r\n    const mazeHeight = encodedMaze.length;\r\n    /**\r\n     * Number of columns in the maze\r\n     */\r\n    const mazeWidth = encodedMaze[0].length;\r\n    /**\r\n     * Checks if a coordinate is within maze bounds\r\n     */\r\n    const isWithinBounds = (col: number, row: number) =>\r\n      row >= 0 && row < mazeHeight && col >= 0 && col < mazeWidth;\r\n    /**\r\n     * Checks if a cell is not a wall and within bounds\r\n     */\r\n    const isCellOpen = (col: number, row: number) =>\r\n      isWithinBounds(col, row) && encodedMaze[row][col] !== -1;\r\n\r\n    /**\r\n     * Maximum path length considered viable for openness calculation\r\n     */\r\n    const opennessHorizon = 1000;\r\n    /**\r\n     * Maximum path length for compass guidance\r\n     */\r\n    const compassHorizon = 5000;\r\n\r\n    // --- Neighbor Analysis ---\r\n    /**\r\n     * Array to store detailed information about each of the four adjacent cells\r\n     */\r\n    const neighborCells: {\r\n      directionIndex: number;\r\n      neighborX: number;\r\n      neighborY: number;\r\n      pathLength: number;\r\n      isReachable: boolean;\r\n      opennessValue: number;\r\n    }[] = [];\r\n    /**\r\n     * Direction vectors and their indices: [dx, dy, dirIndex]\r\n     * 0: North, 1: East, 2: South, 3: West\r\n     */\r\n    const DIRECTION_VECTORS: [number, number, number][] = [\r\n      [0, -1, 0], // North\r\n      [1, 0, 1], // East\r\n      [0, 1, 2], // South\r\n      [-1, 0, 3], // West\r\n    ];\r\n\r\n    /**\r\n     * Current cell's distance to exit (from distance map, if available)\r\n     */\r\n    const currentCellDistanceToExit =\r\n      distanceToExitMap && Number.isFinite(distanceToExitMap[agentY]?.[agentX])\r\n        ? distanceToExitMap[agentY][agentX]\r\n        : undefined;\r\n\r\n    // Step 1: Gather information about each neighboring cell.\r\n    for (const [dx, dy, directionIndex] of DIRECTION_VECTORS) {\r\n      /**\r\n       * Neighbor's coordinates\r\n       */\r\n      const neighborX = agentX + dx;\r\n      const neighborY = agentY + dy;\r\n\r\n      // If the neighbor is a wall, it's unreachable with a value of 0.\r\n      if (!isCellOpen(neighborX, neighborY)) {\r\n        neighborCells.push({\r\n          directionIndex,\r\n          neighborX,\r\n          neighborY,\r\n          pathLength: Infinity,\r\n          isReachable: false,\r\n          opennessValue: 0,\r\n        });\r\n        continue;\r\n      }\r\n\r\n      /**\r\n       * Neighbor's distance to exit (from distance map, if available)\r\n       */\r\n      const neighborDistanceToExit = distanceToExitMap\r\n        ? distanceToExitMap[neighborY]?.[neighborX]\r\n        : undefined;\r\n\r\n      // If the neighbor's distance to the exit is known and it's an improvement...\r\n      if (\r\n        neighborDistanceToExit != null &&\r\n        Number.isFinite(neighborDistanceToExit) &&\r\n        currentCellDistanceToExit != null &&\r\n        Number.isFinite(currentCellDistanceToExit)\r\n      ) {\r\n        if (neighborDistanceToExit < currentCellDistanceToExit) {\r\n          /**\r\n           * Path length to exit if moving in this direction\r\n           */\r\n          const pathLength = 1 + neighborDistanceToExit;\r\n          // If it's within the horizon, record its distance.\r\n          if (pathLength <= opennessHorizon)\r\n            neighborCells.push({\r\n              directionIndex,\r\n              neighborX,\r\n              neighborY,\r\n              pathLength,\r\n              isReachable: true,\r\n              opennessValue: 0,\r\n            });\r\n          // Otherwise, treat it as unreachable.\r\n          else\r\n            neighborCells.push({\r\n              directionIndex,\r\n              neighborX,\r\n              neighborY,\r\n              pathLength: Infinity,\r\n              isReachable: true,\r\n              opennessValue: 0,\r\n            });\r\n        } else {\r\n          // Non-improving moves are treated as dead ends (value 0).\r\n          neighborCells.push({\r\n            directionIndex,\r\n            neighborX,\r\n            neighborY,\r\n            pathLength: Infinity,\r\n            isReachable: true,\r\n            opennessValue: 0,\r\n          });\r\n        }\r\n      } else {\r\n        // If distances are unknown, treat as unreachable for now.\r\n        neighborCells.push({\r\n          directionIndex,\r\n          neighborX,\r\n          neighborY,\r\n          pathLength: Infinity,\r\n          isReachable: true,\r\n          opennessValue: 0,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Step 2: Calculate the \"openness\" values based on the best path.\r\n    /**\r\n     * All reachable neighbors with finite distance\r\n     */\r\n    const reachableNeighbors = neighborCells.filter(\r\n      (neighbor) => neighbor.isReachable && Number.isFinite(neighbor.pathLength)\r\n    );\r\n    /**\r\n     * Minimum path length among all neighbors\r\n     */\r\n    let minPathLength = Infinity;\r\n    for (const neighbor of reachableNeighbors)\r\n      if (neighbor.pathLength < minPathLength)\r\n        minPathLength = neighbor.pathLength;\r\n\r\n    // If there's at least one viable path forward...\r\n    if (reachableNeighbors.length && minPathLength < Infinity) {\r\n      for (const neighbor of reachableNeighbors) {\r\n        // The best path(s) get a value of 1.\r\n        if (neighbor.pathLength === minPathLength) neighbor.opennessValue = 1;\r\n        // Other viable paths get a value proportional to how good they are.\r\n        else neighbor.opennessValue = minPathLength / neighbor.pathLength;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Openness values for each direction (N, E, S, W)\r\n     */\r\n    let opennessNorth = neighborCells.find((n) => n.directionIndex === 0)!\r\n      .opennessValue;\r\n    let opennessEast = neighborCells.find((n) => n.directionIndex === 1)!\r\n      .opennessValue;\r\n    let opennessSouth = neighborCells.find((n) => n.directionIndex === 2)!\r\n      .opennessValue;\r\n    let opennessWest = neighborCells.find((n) => n.directionIndex === 3)!\r\n      .opennessValue;\r\n\r\n    // Step 3: Handle the \"dead end\" scenario.\r\n    // If all forward paths are blocked, provide a small signal for the reverse direction\r\n    // to encourage the agent to backtrack.\r\n    if (\r\n      opennessNorth === 0 &&\r\n      opennessEast === 0 &&\r\n      opennessSouth === 0 &&\r\n      opennessWest === 0 &&\r\n      previousAction != null &&\r\n      previousAction >= 0\r\n    ) {\r\n      /**\r\n       * Opposite direction to previous action\r\n       */\r\n      const oppositeDirection = (previousAction + 2) % 4;\r\n      switch (oppositeDirection) {\r\n        case 0:\r\n          if (isCellOpen(agentX, agentY - 1)) opennessNorth = 0.001;\r\n          break;\r\n        case 1:\r\n          if (isCellOpen(agentX + 1, agentY)) opennessEast = 0.001;\r\n          break;\r\n        case 2:\r\n          if (isCellOpen(agentX, agentY + 1)) opennessSouth = 0.001;\r\n          break;\r\n        case 3:\r\n          if (isCellOpen(agentX - 1, agentY)) opennessWest = 0.001;\r\n          break;\r\n      }\r\n    }\r\n\r\n    // Step 4: Calculate the compass scalar.\r\n    // This points in the direction of the cell with the absolute shortest path to the exit,\r\n    // even if it's very far away (using the extended compass horizon).\r\n    /**\r\n     * Best direction to the exit (0=N, 1=E, 2=S, 3=W)\r\n     */\r\n    let bestDirectionToExit = 0;\r\n    if (distanceToExitMap) {\r\n      /**\r\n       * Minimum path length found for compass\r\n       */\r\n      let minCompassPathLength = Infinity;\r\n      /**\r\n       * Whether a valid path was found for compass\r\n       */\r\n      let foundCompassPath = false;\r\n      for (const neighbor of neighborCells) {\r\n        /**\r\n         * Raw distance to exit for neighbor\r\n         */\r\n        const neighborRawDistance =\r\n          distanceToExitMap[neighbor.neighborY]?.[neighbor.neighborX];\r\n        if (\r\n          neighborRawDistance != null &&\r\n          Number.isFinite(neighborRawDistance)\r\n        ) {\r\n          const pathLength = neighborRawDistance + 1;\r\n          if (\r\n            pathLength < minCompassPathLength &&\r\n            pathLength <= compassHorizon\r\n          ) {\r\n            minCompassPathLength = pathLength;\r\n            bestDirectionToExit = neighbor.directionIndex;\r\n            foundCompassPath = true;\r\n          }\r\n        }\r\n      }\r\n      // If no path is found via distance map, fall back to a simple geometric heuristic.\r\n      if (!foundCompassPath) {\r\n        /**\r\n         * X and Y deltas to goal\r\n         */\r\n        const deltaXToGoal = exitPosition[0] - agentX;\r\n        const deltaYToGoal = exitPosition[1] - agentY;\r\n        if (Math.abs(deltaXToGoal) > Math.abs(deltaYToGoal))\r\n          bestDirectionToExit = deltaXToGoal > 0 ? 1 : 3;\r\n        else bestDirectionToExit = deltaYToGoal > 0 ? 2 : 0;\r\n      }\r\n    } else {\r\n      // Fallback if no distance map is available.\r\n      /**\r\n       * X and Y deltas to goal\r\n       */\r\n      const deltaXToGoal = exitPosition[0] - agentX;\r\n      const deltaYToGoal = exitPosition[1] - agentY;\r\n      if (Math.abs(deltaXToGoal) > Math.abs(deltaYToGoal))\r\n        bestDirectionToExit = deltaXToGoal > 0 ? 1 : 3;\r\n      else bestDirectionToExit = deltaYToGoal > 0 ? 2 : 0;\r\n    }\r\n    /**\r\n     * Compass scalar (0=N, 0.25=E, 0.5=S, 0.75=W)\r\n     */\r\n    const compassScalar = bestDirectionToExit * 0.25;\r\n\r\n    // Step 5: Calculate the progress delta.\r\n    // This value is > 0.5 if the agent moved closer to the exit, < 0.5 if it moved further away,\r\n    // and 0.5 for no change.\r\n    /**\r\n     * Progress delta (recent progress toward/away from exit)\r\n     */\r\n    let progressDelta = 0.5;\r\n    if (previousStepDistance != null && Number.isFinite(previousStepDistance)) {\r\n      /**\r\n       * Change in distance to exit since last step (clipped)\r\n       */\r\n      const distanceDelta = previousStepDistance - currentStepDistance;\r\n      const clippedDelta = Math.max(-2, Math.min(2, distanceDelta)); // Clip to prevent extreme values.\r\n      progressDelta = 0.5 + clippedDelta / 4;\r\n    }\r\n\r\n    // Step 6: Assemble and return the final input vector.\r\n    /**\r\n     * Final input vector for the neural network\r\n     * [compassScalar, openN, openE, openS, openW, progressDelta]\r\n     */\r\n    const inputVector = [\r\n      compassScalar,\r\n      opennessNorth,\r\n      opennessEast,\r\n      opennessSouth,\r\n      opennessWest,\r\n      progressDelta,\r\n    ];\r\n\r\n    // Optional debug logging for educational/diagnostic purposes.\r\n    // Prints a summary of the agent's vision and neighbor analysis every 5 calls if the environment variable is set.\r\n    if (\r\n      typeof process !== 'undefined' &&\r\n      typeof process.env !== 'undefined' &&\r\n      process.env.ASCII_VISION_DEBUG === '1'\r\n    ) {\r\n      try {\r\n        /**\r\n         * String summary of neighbor info for debugging, showing direction, coordinates, path length, and openness value.\r\n         */\r\n        const neighborSummary = neighborCells\r\n          .map(\r\n            (neighbor) =>\r\n              `{dir:${neighbor.directionIndex} x:${neighbor.neighborX} y:${\r\n                neighbor.neighborY\r\n              } path:${\r\n                Number.isFinite(neighbor.pathLength)\r\n                  ? neighbor.pathLength.toFixed(2)\r\n                  : 'Inf'\r\n              } open:${neighbor.opennessValue.toFixed(4)}}`\r\n          )\r\n          .join(' ');\r\n        // Internal debug counter to throttle log output\r\n        (MazeVision as any)._dbgCounter =\r\n          ((MazeVision as any)._dbgCounter || 0) + 1;\r\n        if ((MazeVision as any)._dbgCounter % 5 === 0) {\r\n          // Print a detailed summary of the agent's current vision state\r\n          console.log(\r\n            `[VISION] pos=${agentX},${agentY} comp=${compassScalar.toFixed(\r\n              2\r\n            )} inputs=${JSON.stringify(\r\n              inputVector.map((v) => +v.toFixed(6))\r\n            )} neighbors=${neighborSummary}`\r\n          );\r\n        }\r\n      } catch {\r\n        // Fail silently if any debug logic throws\r\n      }\r\n    }\r\n    /**\r\n     * Returns the 6-dimensional input vector for the agent's neural network:\r\n     * [compassScalar, opennessNorth, opennessEast, opennessSouth, opennessWest, progressDelta]\r\n     */\r\n    return inputVector;\r\n  }\r\n}\r\nexport default MazeVision;\r\n", "/**\r\n * Maze Movement - Handles agent movement and simulation logic (Simplified)\r\n *\r\n * This module contains functions for agent movement and simulation in the maze environment,\r\n * focusing on simple navigation based primarily on neural network decisions.\r\n *\r\n * The agent movement system demonstrates:\r\n * - Decision making based on neural network outputs\r\n * - Basic reward calculations for reinforcement learning\r\n * - Simple goal-seeking behavior\r\n * - Simulation of movement with collision detection\r\n */\r\n\r\nimport { INetwork } from './interfaces';\r\nimport { MazeUtils } from './mazeUtils';\r\nimport { MazeVision } from './mazeVision';\r\n\r\n/**\r\n * MazeMovement provides static methods for agent movement and simulation.\r\n */\r\nexport class MazeMovement {\r\n  /**\r\n   * Checks if a move is valid (within bounds and not a wall).\r\n   *\r\n   * @param encodedMaze - 2D array representation of the maze.\r\n   * @param [x, y] - Coordinates to check.\r\n   * @returns Boolean indicating if the position is valid for movement.\r\n   */\r\n  /**\r\n   * Checks if a move is valid (within maze bounds and not a wall cell).\r\n   *\r\n   * @param encodedMaze - 2D array representation of the maze (cells: -1=wall, 0+=open).\r\n   * @param coords - [x, y] coordinates to check for validity.\r\n   * @returns {boolean} True if the position is within bounds and not a wall.\r\n   */\r\n  static isValidMove(\r\n    encodedMaze: number[][],\r\n    [x, y]: [number, number]\r\n  ): boolean {\r\n    // Check boundaries and wall status\r\n    return (\r\n      x >= 0 &&\r\n      y >= 0 &&\r\n      y < encodedMaze.length &&\r\n      x < encodedMaze[0].length &&\r\n      encodedMaze[y][x] !== -1\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Moves the agent in the given direction if possible, otherwise stays in place.\r\n   *\r\n   * Handles collision detection with walls and maze boundaries,\r\n   * preventing the agent from making invalid moves.\r\n   *\r\n   * @param encodedMaze - 2D array representation of the maze.\r\n   * @param position - Current [x,y] position of the agent.\r\n   * @param direction - Direction index (0=North, 1=East, 2=South, 3=West).\r\n   * @returns New position after movement, or original position if move was invalid.\r\n   */\r\n  /**\r\n   * Moves the agent in the specified direction if the move is valid.\r\n   *\r\n   * Handles collision detection with walls and maze boundaries,\r\n   * preventing the agent from making invalid moves.\r\n   *\r\n   * @param encodedMaze - 2D array representation of the maze.\r\n   * @param position - Current [x, y] position of the agent.\r\n   * @param direction - Direction index (0=North, 1=East, 2=South, 3=West, -1=No move).\r\n   * @returns { [number, number] } New position after movement, or original position if move was invalid.\r\n   */\r\n  static moveAgent(\r\n    encodedMaze: number[][],\r\n    position: [number, number],\r\n    direction: number\r\n  ): [number, number] {\r\n    // If direction is -1, do not move\r\n    if (direction === -1) {\r\n      return [...position] as [number, number];\r\n    }\r\n    // Copy current position\r\n    /**\r\n     * Next position candidate for the agent after moving\r\n     */\r\n    const nextPosition: [number, number] = [...position] as [number, number];\r\n    // Update position based on direction\r\n    switch (direction) {\r\n      case 0: // North\r\n        nextPosition[1] -= 1;\r\n        break;\r\n      case 1: // East\r\n        nextPosition[0] += 1;\r\n        break;\r\n      case 2: // South\r\n        nextPosition[1] += 1;\r\n        break;\r\n      case 3: // West\r\n        nextPosition[0] -= 1;\r\n        break;\r\n    }\r\n    // Check if the new position is valid\r\n    if (MazeMovement.isValidMove(encodedMaze, nextPosition)) {\r\n      return nextPosition;\r\n    } else {\r\n      // If invalid, stay in place\r\n      return position;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Selects the direction with the highest output value from the neural network.\r\n   * Applies softmax to interpret outputs as probabilities, then uses argmax.\r\n   *\r\n   * @param outputs - Array of output values from the neural network (length 4).\r\n   * @returns Index of the highest output value (0=N, 1=E, 2=S, 3=W), or -1 for no movement.\r\n   */\r\n  /**\r\n   * Selects the direction with the highest output value from the neural network.\r\n   * Applies softmax to interpret outputs as probabilities, then uses argmax.\r\n   * Also computes entropy and confidence statistics for analysis.\r\n   *\r\n   * @param outputs - Array of output values from the neural network (length 4).\r\n   * @returns {object} Direction index, softmax probabilities, entropy, and confidence stats.\r\n   */\r\n  static selectDirection(\r\n    outputs: number[]\r\n  ): {\r\n    direction: number;\r\n    softmax: number[];\r\n    entropy: number;\r\n    maxProb: number;\r\n    secondProb: number;\r\n  } {\r\n    // Handle invalid or missing outputs\r\n    if (!outputs || outputs.length !== 4) {\r\n      return {\r\n        direction: -1,\r\n        softmax: [0, 0, 0, 0],\r\n        entropy: 0,\r\n        maxProb: 0,\r\n        secondProb: 0,\r\n      };\r\n    }\r\n    // Center logits to prevent mean bias drift\r\n    /**\r\n     * Mean of the output logits\r\n     */\r\n    const mean = (outputs[0] + outputs[1] + outputs[2] + outputs[3]) / 4;\r\n    /**\r\n     * Variance of the outputs (for adaptive temperature)\r\n     * @type {number}\r\n     */\r\n    let variance = 0;\r\n    for (const o of outputs) variance += (o - mean) * (o - mean);\r\n    variance /= 4;\r\n    /**\r\n     * Standard deviation of the outputs\r\n     * @type {number}\r\n     */\r\n    let std = Math.sqrt(variance);\r\n    if (!Number.isFinite(std) || std < 1e-6) std = 1e-6;\r\n    // Centered logits (preserve scale for evolutionary signals)\r\n    /**\r\n     * Centered logits (mean subtracted)\r\n     */\r\n    const centered = outputs.map((o) => o - mean);\r\n    // Adaptive temperature: higher if variance is tiny\r\n    /**\r\n     * Ratio for adaptive temperature (higher if variance is tiny)\r\n     */\r\n    const collapseRatio = std < 0.01 ? 1 : std < 0.03 ? 0.5 : 0;\r\n    /**\r\n     * Softmax temperature (adaptive)\r\n     */\r\n    const temperature = 1 + 1.2 * collapseRatio; // max 2.2\r\n    // Softmax calculation\r\n    /**\r\n     * Maximum centered logit value\r\n     */\r\n    const max = Math.max(...centered);\r\n    /**\r\n     * Exponentiated logits for softmax\r\n     */\r\n    const exps = centered.map((v) => Math.exp((v - max) / temperature));\r\n    /**\r\n     * Sum of exponentiated logits (softmax denominator)\r\n     */\r\n    const sum = exps.reduce((a, b) => a + b, 0) || 1;\r\n    /**\r\n     * Softmax probability vector\r\n     */\r\n    const softmax = exps.map((e) => e / sum);\r\n    // Find direction with highest probability\r\n    let direction = 0;\r\n    let maxProb = -Infinity;\r\n    let secondProb = 0;\r\n    softmax.forEach((p, i) => {\r\n      if (p > maxProb) {\r\n        secondProb = maxProb;\r\n        maxProb = p;\r\n        direction = i;\r\n      } else if (p > secondProb) secondProb = p;\r\n    });\r\n    // Compute entropy (uncertainty measure)\r\n    let entropy = 0;\r\n    softmax.forEach((p) => {\r\n      if (p > 0) entropy += -p * Math.log(p);\r\n    });\r\n    entropy /= Math.log(4); // Normalize to [0,1]\r\n    return { direction, softmax, entropy, maxProb, secondProb };\r\n  }\r\n\r\n  /**\r\n   * Simulates the agent navigating the maze using its neural network.\r\n   *\r\n   * Runs a complete simulation of an agent traversing a maze,\r\n   * using its neural network for decision making. This implementation focuses\r\n   * on a minimalist approach, putting more responsibility on the neural network.\r\n   *\r\n   * @param network - Neural network controlling the agent.\r\n   * @param encodedMaze - 2D array representation of the maze.\r\n   * @param startPos - Starting position [x,y] of the agent.\r\n   * @param exitPos - Exit/goal position [x,y] of the maze.\r\n   * @param maxSteps - Maximum steps allowed before terminating (default 3000).\r\n   * @returns Object containing:\r\n   *   - success: Boolean indicating if exit was reached.\r\n   *   - steps: Number of steps taken.\r\n   *   - path: Array of positions visited.\r\n   *   - fitness: Calculated fitness score for evolution.\r\n   *   - progress: Percentage progress toward exit (0-100).\r\n   */\r\n  static simulateAgent(\r\n    network: INetwork,\r\n    encodedMaze: number[][],\r\n    startPos: [number, number],\r\n    exitPos: [number, number],\r\n    distanceMap?: number[][],\r\n    maxSteps = 3000\r\n  ): {\r\n    success: boolean;\r\n    steps: number;\r\n    path: [number, number][];\r\n    fitness: number;\r\n    progress: number;\r\n    saturationFraction?: number;\r\n    actionEntropy?: number;\r\n  } {\r\n    /**\r\n     * Current position of the agent [x, y]\r\n     * @type {[number, number]}\r\n     */\r\n    let position = [...startPos] as [number, number];\r\n    /**\r\n     * Number of steps taken so far\r\n     * @type {number}\r\n     */\r\n    let steps = 0;\r\n    /**\r\n     * Path of positions visited by the agent\r\n     * @type {Array<[number, number]>}\r\n     */\r\n    let path = [position.slice() as [number, number]];\r\n    /**\r\n     * Set of visited positions (as string keys)\r\n     * @type {Set<string>}\r\n     */\r\n    let visitedPositions = new Set<string>();\r\n    /**\r\n     * Map of visit counts per cell\r\n     * @type {Map<string, number>}\r\n     */\r\n    let visitCounts = new Map<string, number>();\r\n    /**\r\n     * Short-term memory for last N positions (for loop/oscillation detection)\r\n     * @type {string[]}\r\n     */\r\n    let moveHistory: string[] = [];\r\n    /**\r\n     * Number of positions to keep in moveHistory\r\n     * @type {number}\r\n     */\r\n    const MOVE_HISTORY_LENGTH = 6;\r\n    /**\r\n     * Closest distance to exit found so far\r\n     * @type {number}\r\n     */\r\n    let minDistanceToExit = distanceMap\r\n      ? distanceMap[position[1]]?.[position[0]] ?? Infinity\r\n      : MazeUtils.bfsDistance(encodedMaze, position, exitPos);\r\n\r\n    /**\r\n     * Reward scaling factor for all reward/penalty calculations\r\n     * @type {number}\r\n     */\r\n    const rewardScale = 0.5;\r\n\r\n    // Reward tracking variables\r\n    /**\r\n     * Accumulated reward for progress toward exit\r\n     * @type {number}\r\n     */\r\n    let progressReward = 0;\r\n    /**\r\n     * Bonus for exploring new cells\r\n     * @type {number}\r\n     */\r\n    let newCellExplorationBonus = 0;\r\n    /**\r\n     * Penalty for invalid moves or stagnation\r\n     * @type {number}\r\n     */\r\n    let invalidMovePenalty = 0;\r\n\r\n    // Memory and stagnation tracking\r\n    /**\r\n     * Last direction taken (0-3 or -1)\r\n     * @type {number}\r\n     */\r\n    let prevAction = -1;\r\n    /**\r\n     * Steps since last improvement in distance to exit\r\n     * @type {number}\r\n     */\r\n    let stepsSinceImprovement = 0;\r\n    /**\r\n     * Initial global distance to exit\r\n     * @type {number}\r\n     */\r\n    const startDistanceGlobal = distanceMap\r\n      ? distanceMap[position[1]]?.[position[0]] ?? Infinity\r\n      : MazeUtils.bfsDistance(encodedMaze, position, exitPos);\r\n    /**\r\n     * Last global distance to exit\r\n     * @type {number}\r\n     */\r\n    let lastDistanceGlobal = startDistanceGlobal;\r\n    /**\r\n     * Number of saturated steps (output collapse or overconfidence)\r\n     * @type {number}\r\n     */\r\n    let saturatedSteps = 0;\r\n    /**\r\n     * Window size for local area stagnation detection\r\n     * @type {number}\r\n     */\r\n    const LOCAL_WINDOW = 30;\r\n    /**\r\n     * Recent positions for local area stagnation\r\n     * @type {Array<[number, number]>}\r\n     */\r\n    const recentPositions: [number, number][] = [];\r\n    /**\r\n     * Penalty for local area stagnation\r\n     * @type {number}\r\n     */\r\n    let localAreaPenalty = 0;\r\n\r\n    // Main simulation loop: agent moves until maxSteps or exit is reached\r\n    let lastProgressRatio = 0;\r\n    while (steps < maxSteps) {\r\n      steps++;\r\n\r\n      // --- Step 1: Record current position as visited ---\r\n      /**\r\n       * String key for the agent's current position\r\n       */\r\n      const currentPosKey = `${position[0]},${position[1]}`;\r\n      visitedPositions.add(currentPosKey);\r\n      visitCounts.set(currentPosKey, (visitCounts.get(currentPosKey) || 0) + 1);\r\n      moveHistory.push(currentPosKey);\r\n      if (moveHistory.length > MOVE_HISTORY_LENGTH) moveHistory.shift();\r\n\r\n      // --- Step 2: Calculate percent of maze explored so far ---\r\n      /**\r\n       * Percent of maze explored so far\r\n       */\r\n      const percentExplored =\r\n        visitedPositions.size / (encodedMaze.length * encodedMaze[0].length);\r\n\r\n      // --- Step 3: Oscillation/loop detection (A->B->A->B) ---\r\n      /**\r\n       * Penalty for oscillation/looping\r\n       */\r\n      let loopPenalty = 0;\r\n      if (\r\n        moveHistory.length >= 4 &&\r\n        moveHistory[moveHistory.length - 1] ===\r\n          moveHistory[moveHistory.length - 3] &&\r\n        moveHistory[moveHistory.length - 2] ===\r\n          moveHistory[moveHistory.length - 4]\r\n      ) {\r\n        loopPenalty -= 10 * rewardScale; // Strong penalty for 2-step loop\r\n      }\r\n      /**\r\n       * Memory loop indicator input (1 if loop detected, else 0)\r\n       */\r\n      const loopFlag = loopPenalty < 0 ? 1 : 0;\r\n\r\n      // --- Step 4: Penalty for returning to any cell in recent history ---\r\n      /**\r\n       * Penalty for returning to a cell in recent history\r\n       */\r\n      let memoryPenalty = 0;\r\n      if (\r\n        moveHistory.length > 1 &&\r\n        moveHistory.slice(0, -1).includes(currentPosKey)\r\n      ) {\r\n        memoryPenalty -= 2 * rewardScale;\r\n      }\r\n\r\n      // --- Step 5: Dynamic penalty for multiple visits ---\r\n      /**\r\n       * Penalty for revisiting cells\r\n       */\r\n      let revisitPenalty = 0;\r\n      /**\r\n       * Number of times the current cell has been visited\r\n       */\r\n      const visits = visitCounts.get(currentPosKey) || 1;\r\n      if (visits > 1) {\r\n        revisitPenalty -= 0.2 * (visits - 1) * rewardScale; // Penalty increases with each revisit\r\n      }\r\n\r\n      // --- Step 6: Early termination if a cell is visited too many times ---\r\n      if (visits > 10) {\r\n        invalidMovePenalty -= 1000 * rewardScale;\r\n        break;\r\n      }\r\n\r\n      // --- Step 7: Build agent's perception (vision inputs) ---\r\n      /**\r\n       * Previous local distance to exit\r\n       */\r\n      const prevDistLocal = distanceMap\r\n        ? distanceMap[position[1]]?.[position[0]] ?? undefined\r\n        : MazeUtils.bfsDistance(encodedMaze, position, exitPos);\r\n      /**\r\n       * Current local distance to exit (same as prev before move)\r\n       */\r\n      const distCurrentLocal = prevDistLocal;\r\n      /**\r\n       * Vision input vector for the agent\r\n       */\r\n      const vision = MazeVision.buildInputs6(\r\n        encodedMaze,\r\n        position,\r\n        exitPos,\r\n        distanceMap,\r\n        (MazeMovement as any)._prevDistanceStep,\r\n        distCurrentLocal,\r\n        prevAction\r\n      );\r\n      (MazeMovement as any)._prevDistanceStep = distCurrentLocal;\r\n\r\n      // --- Step 8: Get distance at current location (for proximity logic) ---\r\n      /**\r\n       * Distance at current location (pre-action) for proximity exploitation logic\r\n       */\r\n      const distHere = distanceMap\r\n        ? distanceMap[position[1]]?.[position[0]] ?? Infinity\r\n        : MazeUtils.bfsDistance(encodedMaze, position, exitPos);\r\n\r\n      // --- Step 9: Neural network decision making ---\r\n      /**\r\n       * Chosen direction for this step\r\n       */\r\n      let direction;\r\n      /**\r\n       * Action statistics (softmax, entropy, etc.)\r\n       */\r\n      let actionStats: any = null;\r\n      try {\r\n        // Activate the network with vision inputs\r\n        /**\r\n         * Output vector from the neural network\r\n         */\r\n        const outputs = network.activate(vision) as number[];\r\n        // Track outputs for variance diagnostics (sliding window)\r\n        (network as any)._lastStepOutputs =\r\n          (network as any)._lastStepOutputs || [];\r\n        /**\r\n         * Sliding window of last step outputs for variance diagnostics\r\n         */\r\n        const _ls = (network as any)._lastStepOutputs;\r\n        _ls.push(outputs.slice());\r\n        if (_ls.length > 80) _ls.shift();\r\n        // Select direction and compute stats\r\n        actionStats = MazeMovement.selectDirection(outputs);\r\n        // Detect output saturation (overconfidence or flat collapse)\r\n        (MazeMovement as any)._saturations =\r\n          (MazeMovement as any)._saturations || 0;\r\n        const overConfident =\r\n          actionStats.maxProb > 0.985 && actionStats.secondProb < 0.01;\r\n        // Recompute std on centered logits\r\n        const logitsMean =\r\n          (outputs[0] + outputs[1] + outputs[2] + outputs[3]) / 4;\r\n        let logVar = 0;\r\n        for (const o of outputs) logVar += Math.pow(o - logitsMean, 2);\r\n        logVar /= 4;\r\n        const logStd = Math.sqrt(logVar);\r\n        const flatCollapsed = logStd < 0.01;\r\n        const saturatedNow = overConfident || flatCollapsed;\r\n        if (saturatedNow) {\r\n          (MazeMovement as any)._saturations++;\r\n          saturatedSteps++;\r\n        } else {\r\n          (MazeMovement as any)._saturations = Math.max(\r\n            0,\r\n            (MazeMovement as any)._saturations - 1\r\n          );\r\n        }\r\n        // Penalties for saturation\r\n        if (overConfident) invalidMovePenalty -= 0.25 * rewardScale;\r\n        if (flatCollapsed) invalidMovePenalty -= 0.35 * rewardScale;\r\n        // Adaptive bias anti-saturation: gently reduce output biases if chronic\r\n        try {\r\n          if ((MazeMovement as any)._saturations > 6 && steps % 5 === 0) {\r\n            const outs = (network as any).nodes?.filter(\r\n              (n: any) => n.type === 'output'\r\n            );\r\n            if (outs?.length) {\r\n              const mean =\r\n                outs.reduce((a: number, n: any) => a + n.bias, 0) / outs.length;\r\n              outs.forEach((n: any) => {\r\n                n.bias = Math.max(-5, Math.min(5, n.bias - mean * 0.5));\r\n              });\r\n            }\r\n          }\r\n        } catch {\r\n          /* ignore */\r\n        }\r\n        direction = actionStats.direction;\r\n      } catch (error) {\r\n        console.error('Error activating network:', error);\r\n        direction = -1; // Fallback: don't move\r\n      }\r\n\r\n      // --- Step 10: Proximity exploitation (greedy move if near exit) ---\r\n      if (distHere <= 2) {\r\n        /**\r\n         * Best direction found (minimizing distance to exit)\r\n         */\r\n        let bestDir = direction;\r\n        /**\r\n         * Best distance found\r\n         */\r\n        let bestDist = Infinity;\r\n        for (let d = 0; d < 4; d++) {\r\n          const testPos = MazeMovement.moveAgent(encodedMaze, position, d);\r\n          if (testPos[0] === position[0] && testPos[1] === position[1])\r\n            continue; // invalid\r\n          /**\r\n           * Distance value for candidate direction\r\n           */\r\n          const dVal = distanceMap\r\n            ? distanceMap[testPos[1]]?.[testPos[0]] ?? Infinity\r\n            : MazeUtils.bfsDistance(encodedMaze, testPos, exitPos);\r\n          if (dVal < bestDist) {\r\n            bestDist = dVal;\r\n            bestDir = d;\r\n          }\r\n        }\r\n        if (bestDir != null) direction = bestDir;\r\n      }\r\n\r\n      // Epsilon-greedy exploration: encourage divergence early & when stagnant\r\n      const stepsStagnant = stepsSinceImprovement;\r\n      let epsilon = 0;\r\n      if (steps < 10) epsilon = 0.35;\r\n      else if (stepsStagnant > 12) epsilon = 0.5;\r\n      else if (stepsStagnant > 6) epsilon = 0.25;\r\n      else if ((MazeMovement as any)._saturations > 3) epsilon = 0.3;\r\n      // Suppress exploration when near goal to encourage completion\r\n      if (distHere <= 5) epsilon = Math.min(epsilon, 0.05);\r\n      if (Math.random() < epsilon) {\r\n        // pick a random valid direction differing from previous when possible\r\n        /**\r\n         * Candidate directions for random exploration\r\n         */\r\n        const candidates = [0, 1, 2, 3].filter((d) => d !== prevAction);\r\n        while (candidates.length) {\r\n          /**\r\n           * Index of candidate direction\r\n           */\r\n          const idx = Math.floor(Math.random() * candidates.length);\r\n          /**\r\n           * Candidate direction value\r\n           */\r\n          const cand = candidates.splice(idx, 1)[0];\r\n          /**\r\n           * Test position for candidate direction\r\n           */\r\n          const testPos = MazeMovement.moveAgent(encodedMaze, position, cand);\r\n          if (testPos[0] !== position[0] || testPos[1] !== position[1]) {\r\n            direction = cand;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // --- Anti-stagnation: if we haven't moved in several attempts, force exploratory move\r\n      // Track consecutive failed moves\r\n      (MazeMovement as any)._noMoveStreak =\r\n        (MazeMovement as any)._noMoveStreak || 0;\r\n      if (direction === -1) (MazeMovement as any)._noMoveStreak++;\r\n      if ((MazeMovement as any)._noMoveStreak >= 5) {\r\n        // pick a random cardinal direction until a valid move found (epsilon-greedy style)\r\n        for (let tries = 0; tries < 4; tries++) {\r\n          /**\r\n           * Candidate direction for forced exploration\r\n           */\r\n          const cand = Math.floor(Math.random() * 4);\r\n          /**\r\n           * Test position for candidate direction\r\n           */\r\n          const testPos = MazeMovement.moveAgent(encodedMaze, position, cand);\r\n          if (testPos[0] !== position[0] || testPos[1] !== position[1]) {\r\n            direction = cand;\r\n            break;\r\n          }\r\n        }\r\n        (MazeMovement as any)._noMoveStreak = 0;\r\n      }\r\n\r\n      // Save previous state for reward calculation\r\n      /**\r\n       * Previous position before move\r\n       */\r\n      const prevPosition = [...position] as [number, number];\r\n      /**\r\n       * Previous distance to exit before move\r\n       */\r\n      const prevDistance = distanceMap\r\n        ? distanceMap[position[1]]?.[position[0]] ?? Infinity\r\n        : MazeUtils.bfsDistance(encodedMaze, position, exitPos);\r\n\r\n      // --- ACTION: Move based on network decision\r\n      position = MazeMovement.moveAgent(encodedMaze, position, direction);\r\n      /**\r\n       * Whether the agent actually moved this step\r\n       */\r\n      const moved =\r\n        prevPosition[0] !== position[0] || prevPosition[1] !== position[1];\r\n\r\n      // Record movement and update rewards/penalties\r\n      if (moved) {\r\n        path.push(position.slice() as [number, number]);\r\n        recentPositions.push(position.slice() as [number, number]);\r\n        if (recentPositions.length > LOCAL_WINDOW) recentPositions.shift();\r\n        if (recentPositions.length === LOCAL_WINDOW) {\r\n          /**\r\n           * Minimum and maximum X/Y in recent positions\r\n           */\r\n          let minX = Infinity,\r\n            maxX = -Infinity,\r\n            minY = Infinity,\r\n            maxY = -Infinity;\r\n          for (const [rx, ry] of recentPositions) {\r\n            if (rx < minX) minX = rx;\r\n            if (rx > maxX) maxX = rx;\r\n            if (ry < minY) minY = ry;\r\n            if (ry > maxY) maxY = ry;\r\n          }\r\n          /**\r\n           * Span of recent positions (for local oscillation detection)\r\n           */\r\n          const span = maxX - minX + (maxY - minY);\r\n          // Penalize tight oscillation in a small neighborhood when no improvements recently\r\n          if (span <= 5 && stepsSinceImprovement > 8) {\r\n            localAreaPenalty -= 0.05 * rewardScale; // accumulate gradually\r\n          }\r\n        }\r\n\r\n        // Calculate current distance to exit\r\n        /**\r\n         * Current distance to exit after move\r\n         */\r\n        const currentDistance = distanceMap\r\n          ? distanceMap[position[1]]?.[position[0]] ?? Infinity\r\n          : MazeUtils.bfsDistance(encodedMaze, position, exitPos);\r\n\r\n        // Reward for getting closer to exit, penalty for moving away\r\n        /**\r\n         * Change in distance to exit (positive if improved)\r\n         */\r\n        const distanceDelta = prevDistance - currentDistance; // positive if improved\r\n        if (distanceDelta > 0) {\r\n          // Confidence shaping if available\r\n          const conf = actionStats?.maxProb ?? 1;\r\n          progressReward += (0.3 + 0.7 * conf) * rewardScale;\r\n          if (stepsSinceImprovement > 0)\r\n            progressReward += Math.min(\r\n              stepsSinceImprovement * 0.02 * rewardScale,\r\n              0.5 * rewardScale\r\n            );\r\n          stepsSinceImprovement = 0;\r\n          // Additional proportional reward to create gradient\r\n          progressReward += distanceDelta * 2.0 * (0.4 + 0.6 * conf); // scale by confidence\r\n        } else if (currentDistance > prevDistance) {\r\n          const conf = actionStats?.maxProb ?? 0.5;\r\n          progressReward -= (0.05 + 0.15 * conf) * rewardScale;\r\n          stepsSinceImprovement++;\r\n        } else {\r\n          stepsSinceImprovement++;\r\n        }\r\n\r\n        // Bonus for exploring new cells, penalty for revisiting\r\n        if (visits === 1) {\r\n          newCellExplorationBonus += 0.3 * rewardScale;\r\n        } else {\r\n          newCellExplorationBonus -= 0.5 * rewardScale; // Stronger penalty for revisiting\r\n        }\r\n\r\n        // Track closest approach to exit\r\n        minDistanceToExit = Math.min(minDistanceToExit, currentDistance);\r\n      } else {\r\n        // Penalty for invalid move (collision or out of bounds)\r\n        // Previously this was extremely punitive (-1000 * scale) causing all genomes to bottom-out at the clamp\r\n        // which destroyed selection pressure. Keep it mild so progress/exploration dominate.\r\n        invalidMovePenalty -= 10 * rewardScale; // mild penalty now\r\n        // No tolerance for invalid moves; break if needed\r\n        steps === maxSteps;\r\n      }\r\n      // Update global distance improvement memory\r\n      /**\r\n       * Current global distance to exit\r\n       */\r\n      const currentDistanceGlobal = distanceMap\r\n        ? distanceMap[position[1]]?.[position[0]] ?? Infinity\r\n        : MazeUtils.bfsDistance(encodedMaze, position, exitPos);\r\n      if (currentDistanceGlobal < lastDistanceGlobal) {\r\n        // bonus for breaking a long stagnation globally\r\n        if (stepsSinceImprovement > 10)\r\n          progressReward += Math.min(\r\n            (stepsSinceImprovement - 10) * 0.01 * rewardScale,\r\n            0.5 * rewardScale\r\n          );\r\n        stepsSinceImprovement = 0;\r\n      }\r\n      lastDistanceGlobal = currentDistanceGlobal;\r\n      // Repetition penalty: if repeating same action without improvement\r\n      if (prevAction === direction && stepsSinceImprovement > 4) {\r\n        invalidMovePenalty -= 0.05 * (stepsSinceImprovement - 4) * rewardScale;\r\n      }\r\n      // Penalize backward (opposite) moves strongly if they do not improve\r\n      if (prevAction >= 0 && direction >= 0) {\r\n        /**\r\n         * Opposite direction to previous action\r\n         */\r\n        const opposite = (prevAction + 2) % 4;\r\n        if (direction === opposite && stepsSinceImprovement > 0) {\r\n          invalidMovePenalty -= 0.2 * rewardScale;\r\n        }\r\n      }\r\n      // Only record previous action if movement succeeded to avoid mismatches\r\n      if (moved) {\r\n        prevAction = direction; // record last successful move for back-direction suppression\r\n        prevAction = direction;\r\n      }\r\n\r\n      // Encourage decisiveness: slight penalty for very high entropy (uniform outputs),\r\n      // slight bonus for confident low-entropy when some guidance signal (gradient or LOS) exists.\r\n      if (actionStats) {\r\n        const { entropy, maxProb, secondProb } = actionStats;\r\n        // Compute presence of directional guidance (any non-zero gradient or LOS)\r\n        const hasGuidance =\r\n          vision[8] + vision[9] + vision[10] + vision[11] > 0 || // LOS group\r\n          vision[12] + vision[13] + vision[14] + vision[15] > 0; // Gradient group\r\n        if (entropy > 0.95) {\r\n          invalidMovePenalty -= 0.03 * rewardScale; // discourage persistent ambiguity\r\n        } else if (\r\n          hasGuidance &&\r\n          entropy < 0.55 &&\r\n          maxProb - secondProb > 0.25\r\n        ) {\r\n          newCellExplorationBonus += 0.015 * rewardScale; // tiny shaping bonus for clear decision\r\n        }\r\n        // Penalty for prolonged saturation (uninformative all-ones behavior)\r\n        if ((MazeMovement as any)._saturations >= 5) {\r\n          invalidMovePenalty -= 0.05 * rewardScale;\r\n          if ((MazeMovement as any)._saturations % 10 === 0) {\r\n            invalidMovePenalty -= 0.1 * rewardScale; // escalating every 10 steps saturated\r\n          }\r\n        }\r\n      }\r\n\r\n      // Early termination on deep stagnation (no improvement & limited exploration)\r\n      if (stepsSinceImprovement > 40) {\r\n        // discourage bloating while stuck\r\n        invalidMovePenalty -= 2 * rewardScale;\r\n        break;\r\n      }\r\n\r\n      // Apply oscillation/loop/memory/revisit penalties\r\n      invalidMovePenalty += loopPenalty + memoryPenalty + revisitPenalty;\r\n\r\n      // --- SUCCESS CHECK: Exit reached\r\n      if (position[0] === exitPos[0] && position[1] === exitPos[1]) {\r\n        // Calculate fitness for successful completion\r\n        /**\r\n         * Step efficiency (remaining steps)\r\n         */\r\n        const stepEfficiency = maxSteps - steps;\r\n        // Action entropy bonus for successful runs (promote balanced yet decisive policies)\r\n        /**\r\n         * Action entropy for the successful path\r\n         */\r\n        const { actionEntropy } = MazeMovement.computeActionEntropy(path);\r\n        /**\r\n         * Fitness score for successful completion\r\n         */\r\n        const fitness =\r\n          650 +\r\n          stepEfficiency * 0.2 +\r\n          progressReward +\r\n          newCellExplorationBonus +\r\n          invalidMovePenalty +\r\n          actionEntropy * 5;\r\n\r\n        return {\r\n          success: true,\r\n          steps,\r\n          path,\r\n          fitness: Math.max(150, fitness),\r\n          progress: 100,\r\n          saturationFraction: steps ? saturatedSteps / steps : 0,\r\n          actionEntropy,\r\n        };\r\n      }\r\n    }\r\n\r\n    // --- FAILURE CASE: Did not reach exit\r\n    /**\r\n     * Progress percentage toward exit (0-100)\r\n     */\r\n    const progress = distanceMap\r\n      ? MazeUtils.calculateProgressFromDistanceMap(\r\n          distanceMap,\r\n          path[path.length - 1],\r\n          startPos\r\n        )\r\n      : MazeUtils.calculateProgress(\r\n          encodedMaze,\r\n          path[path.length - 1],\r\n          startPos,\r\n          exitPos\r\n        );\r\n\r\n    // Fitness for unsuccessful attempts: emphasize progress & exploration with moderated penalties\r\n    /**\r\n     * Fractional progress toward exit (0..1)\r\n     */\r\n    const progressFrac = progress / 100;\r\n    /**\r\n     * Shaped progress score (concave for early gradient)\r\n     */\r\n    const shapedProgress = Math.pow(progressFrac, 1.3) * 500;\r\n    /**\r\n     * Exploration score (number of unique cells visited)\r\n     */\r\n    const explorationScore = visitedPositions.size * 1.0; // increase weight so exploration differentiates genomes\r\n    /**\r\n     * Aggregated penalty\r\n     */\r\n    const penalty = invalidMovePenalty; // already aggregated\r\n    // Action entropy based on path\r\n    /**\r\n     * Action entropy for the failed path\r\n     */\r\n    const { actionEntropy } = MazeMovement.computeActionEntropy(path);\r\n    /**\r\n     * Bonus for action entropy\r\n     */\r\n    const entropyBonus = actionEntropy * 4; // weight\r\n    /**\r\n     * Fraction of steps that were saturated\r\n     */\r\n    const satFrac = steps ? saturatedSteps / steps : 0;\r\n    /**\r\n     * Penalty for output saturation\r\n     */\r\n    const saturationPenalty =\r\n      satFrac > 0.35\r\n        ? -(satFrac - 0.35) * 40 // linear scale beyond threshold\r\n        : 0;\r\n    // Penalize persistently near-constant output vectors across steps (low std)\r\n    /**\r\n     * Penalty for low output variance\r\n     */\r\n    let outputVarPenalty = 0;\r\n    try {\r\n      /**\r\n       * History of last step outputs\r\n       */\r\n      const hist: number[][] = (network as any)._lastStepOutputs || [];\r\n      if (hist.length >= 15) {\r\n        const recent = hist.slice(-30);\r\n        let lowVar = 0;\r\n        for (const o of recent) {\r\n          const m = (o[0] + o[1] + o[2] + o[3]) / 4;\r\n          let v = 0;\r\n          for (const x of o) v += (x - m) * (x - m);\r\n          v /= 4;\r\n          if (Math.sqrt(v) < 0.01) lowVar++;\r\n        }\r\n        if (lowVar > 4) outputVarPenalty -= (lowVar - 4) * 0.3; // escalate with count beyond small tolerance\r\n      }\r\n    } catch {}\r\n    // Near-miss penalty: strongly encourage finishing if within 1 step at any point\r\n    /**\r\n     * Penalty for being within 1 step of exit but not finishing\r\n     */\r\n    let nearMissPenalty = 0;\r\n    if (minDistanceToExit === 1) nearMissPenalty -= 30 * rewardScale;\r\n    /**\r\n     * Base fitness score before final adjustment\r\n     */\r\n    const base =\r\n      shapedProgress +\r\n      explorationScore +\r\n      progressReward +\r\n      newCellExplorationBonus +\r\n      penalty +\r\n      entropyBonus +\r\n      localAreaPenalty +\r\n      saturationPenalty +\r\n      outputVarPenalty +\r\n      nearMissPenalty;\r\n    // Remove tight clamp that caused saturation; apply gentle floor far lower so relative differences remain\r\n    // Add tiny stochastic tie-breaker noise so identical behaviors diverge slightly for selection pressure\r\n    // Replace static floor with softer nonlinear squash so early differentials aren't erased\r\n    // and prevent population collapse at a shared floor.\r\n    /**\r\n     * Raw fitness score (with noise)\r\n     */\r\n    const raw = base + Math.random() * 0.01;\r\n    /**\r\n     * Final fitness score (nonlinear squash for negatives)\r\n     */\r\n    const fitness = raw >= 0 ? raw : -Math.log1p(1 - raw);\r\n    return {\r\n      success: false,\r\n      steps,\r\n      path,\r\n      fitness,\r\n      progress,\r\n      saturationFraction: satFrac,\r\n      actionEntropy,\r\n    };\r\n  }\r\n}\r\n/**\r\n * Computes the entropy of the agent's action distribution from its path.\r\n * Higher entropy means more diverse movement; lower means repetitive.\r\n *\r\n * @param path - Array of [x, y] positions visited by the agent.\r\n * @returns {object} actionEntropy (0..1)\r\n */\r\nexport namespace MazeMovement {\r\n  export function computeActionEntropy(path: [number, number][]) {\r\n    if (!path || path.length < 2) return { actionEntropy: 0 };\r\n    /**\r\n     * Counts of each direction taken (N, E, S, W)\r\n     * @type {number[]}\r\n     */\r\n    const counts = [0, 0, 0, 0];\r\n    for (let i = 1; i < path.length; i++) {\r\n      const dx = path[i][0] - path[i - 1][0];\r\n      const dy = path[i][1] - path[i - 1][1];\r\n      if (dx === 0 && dy === -1) counts[0]++;\r\n      // North\r\n      else if (dx === 1 && dy === 0) counts[1]++;\r\n      // East\r\n      else if (dx === 0 && dy === 1) counts[2]++;\r\n      // South\r\n      else if (dx === -1 && dy === 0) counts[3]++; // West\r\n    }\r\n    /**\r\n     * Total number of actions taken\r\n     */\r\n    const total = counts.reduce((a, b) => a + b, 0) || 1;\r\n    let ent = 0;\r\n    counts.forEach((c) => {\r\n      if (c > 0) {\r\n        const p = c / total;\r\n        ent += -p * Math.log(p);\r\n      }\r\n    });\r\n    /**\r\n     * Normalized entropy of the action distribution (0=deterministic, 1=uniform)\r\n     * @type {number}\r\n     */\r\n    const actionEntropy = ent / Math.log(4);\r\n    return { actionEntropy };\r\n  }\r\n}\r\n", "// Fitness evaluation logic for maze solving\r\n// Exports: FitnessEvaluator class with static methods\r\n\r\nimport { INetwork } from './interfaces'; // Added INetwork import\r\nimport { MazeUtils } from './mazeUtils';\r\nimport { MazeMovement } from './mazeMovement';\r\nimport { IFitnessEvaluationContext } from './interfaces';\r\n\r\n/**\r\n * The `FitnessEvaluator` class is responsible for calculating the fitness of a neural network\r\n * in the context of solving a maze. Fitness is a numerical score that quantifies how \"good\" a\r\n * particular network is at the task. The NEAT algorithm uses this score to select the best\r\n * networks for reproduction. This class provides static methods, so it doesn't need to be instantiated.\r\n */\r\nexport class FitnessEvaluator {\r\n  /**\r\n   * Evaluates the fitness of a single neural network based on its performance in a maze simulation.\r\n   *\r\n   * This is the core of the fitness calculation. It runs a simulation of the agent controlled\r\n   * by the given network and then calculates a score based on a combination of factors.\r\n   * A well-designed fitness function is crucial for guiding the evolution towards the desired behavior.\r\n   *\r\n   * The fitness function rewards several key behaviors:\r\n   * - **Progress**: How close did the agent get to the exit? This is the primary driver.\r\n   * - **Success**: A large, fixed bonus is awarded for successfully reaching the exit.\r\n   * - **Efficiency**: If the exit is reached, an additional bonus is given for shorter paths.\r\n   *   This encourages the agent to find the most direct route.\r\n   * - **Exploration**: A bonus is given for each unique cell the agent visits. This encourages\r\n   *   the agent to explore the maze rather than getting stuck in a small area. The exploration\r\n   *   bonus is weighted by the cell's proximity to the exit, rewarding exploration in promising areas.\r\n   *\r\n   * @param network - The neural network to be evaluated.\r\n   * @param encodedMaze - A 2D array representing the maze layout.\r\n   * @param startPosition - The agent's starting coordinates `[x, y]`.\r\n   * @param exitPosition - The maze's exit coordinates `[x, y]`.\r\n   * @param distanceMap - A pre-calculated map of distances from each cell to the exit, for performance.\r\n   * @param maxSteps - The maximum number of steps the agent is allowed to take in the simulation.\r\n   * @returns The final computed fitness score for the network.\r\n   */\r\n  static evaluateNetworkFitness(\r\n    network: INetwork,\r\n    encodedMaze: number[][],\r\n    startPosition: [number, number],\r\n    exitPosition: [number, number],\r\n    distanceMap: number[][] | undefined,\r\n    maxSteps: number\r\n  ): number {\r\n    // Step 1: Simulate the agent's journey through the maze using its network \"brain\".\r\n    // The result object contains detailed statistics about the run, like the path taken,\r\n    // whether the exit was reached, and a base fitness score.\r\n    const result = MazeMovement.simulateAgent(\r\n      network,\r\n      encodedMaze,\r\n      startPosition,\r\n      exitPosition,\r\n      distanceMap,\r\n      maxSteps\r\n    );\r\n\r\n    /**\r\n     * @var {number} explorationBonus - A bonus rewarding the agent for exploring new territory.\r\n     */\r\n    let explorationBonus = 0;\r\n\r\n    // Step 2: Calculate the exploration bonus.\r\n    // Iterate over each unique cell visited by the agent.\r\n    for (const [x, y] of result.path) {\r\n      // Determine the distance of the current cell from the exit.\r\n      const distToExit = distanceMap\r\n        ? distanceMap[y]?.[x] ?? Infinity\r\n        : MazeUtils.bfsDistance(encodedMaze, [x, y], exitPosition);\r\n\r\n      // Calculate a multiplier based on proximity to the exit.\r\n      // Cells closer to the exit are more valuable to explore.\r\n      const proximityMultiplier =\r\n        1.5 - 0.5 * (distToExit / (encodedMaze.length + encodedMaze[0].length));\r\n\r\n      // Reward the agent only for the *first* time it visits a cell.\r\n      // This prevents the agent from getting rewarded for running in circles.\r\n      if (\r\n        result.path.filter(([px, py]: [number, number]) => px === x && py === y)\r\n          .length === 1\r\n      ) {\r\n        explorationBonus += 200 * proximityMultiplier;\r\n      }\r\n    }\r\n\r\n    // Step 3: Combine the base fitness with the exploration bonus.\r\n    let fitness = result.fitness + explorationBonus;\r\n\r\n    // Step 4: Apply large bonuses for success and efficiency.\r\n    if (result.success) {\r\n      // A significant, constant bonus for reaching the exit.\r\n      fitness += 5000;\r\n\r\n      // An additional bonus for path efficiency.\r\n      // The closer the agent's path length is to the optimal path length, the higher the bonus.\r\n      const optimal = distanceMap\r\n        ? distanceMap[startPosition[1]]?.[startPosition[0]] ?? Infinity\r\n        : MazeUtils.bfsDistance(encodedMaze, startPosition, exitPosition);\r\n      const pathOverhead = ((result.path.length - 1) / optimal) * 100 - 100;\r\n      fitness += Math.max(0, 8000 - pathOverhead * 80);\r\n    }\r\n\r\n    // Step 5: Return the final, comprehensive fitness score.\r\n    return fitness;\r\n  }\r\n\r\n  /**\r\n   * A wrapper function that serves as the default fitness evaluator for the NEAT evolution process.\r\n   *\r\n   * This function acts as an adapter. The main evolution engine (`EvolutionEngine`) works with a\r\n   * standardized `context` object that bundles all the necessary information for an evaluation.\r\n   * This method simply unpacks that context object and passes the individual parameters to the\r\n   * core `evaluateNetworkFitness` function.\r\n   *\r\n   * @param network - The neural network to be evaluated.\r\n   * @param context - An object containing all the necessary data for the fitness evaluation,\r\n   *                  such as the maze, start/exit positions, and simulation configuration.\r\n   * @returns The computed fitness score for the network.\r\n   */\r\n  static defaultFitnessEvaluator(\r\n    network: INetwork,\r\n    context: IFitnessEvaluationContext\r\n  ): number {\r\n    // Call the main fitness evaluation function with the parameters unpacked from the context object.\r\n    return FitnessEvaluator.evaluateNetworkFitness(\r\n      network,\r\n      context.encodedMaze,\r\n      context.startPosition,\r\n      context.exitPosition,\r\n      context.distanceMap,\r\n      context.agentSimConfig.maxSteps\r\n    );\r\n  }\r\n}\r\n", "// Handles the main NEAT evolution loop for maze solving\r\n// Exports: EvolutionEngine class with static methods\r\n\r\nimport { Neat, Network, methods } from '../../../src/neataptic';\r\nimport seedrandom from 'seedrandom';\r\nimport { MazeUtils } from './mazeUtils';\r\nimport { MazeMovement } from './mazeMovement';\r\nimport { FitnessEvaluator } from './fitness';\r\nimport {\r\n  INetwork,\r\n  IFitnessEvaluationContext,\r\n  IRunMazeEvolutionOptions,\r\n} from './interfaces';\r\n\r\n/**\r\n * The `EvolutionEngine` class encapsulates the entire neuro-evolution process for training agents to solve mazes.\r\n * It leverages the NEAT (Neuro-Evolution of Augmenting Topologies) algorithm to evolve neural networks.\r\n * This class is designed as a static utility, meaning you don't need to instantiate it to use its methods.\r\n *\r\n * Key Responsibilities:\r\n * - Orchestrating the main evolution loop (generations, evaluation, selection, reproduction).\r\n * - Configuring and initializing the NEAT algorithm with appropriate parameters.\r\n * - Managing a hybrid evolution strategy that combines genetic exploration (NEAT) with local optimization (backpropagation).\r\n * - Handling curriculum learning, where agents can be trained on a sequence of increasingly difficult mazes.\r\n * - Providing utilities for logging, visualization, and debugging the evolutionary process.\r\n */\r\nexport class EvolutionEngine {\r\n  /**\r\n   * Runs the NEAT neuro-evolution process for an agent to solve a given ASCII maze.\r\n   *\r\n   * This is the core function of the `EvolutionEngine`. It sets up and runs the evolutionary\r\n   * algorithm to train a population of neural networks. Each network acts as the \"brain\" for an\r\n   * agent, controlling its movement through the maze from a start point 'S' to an exit 'E'.\r\n   *\r\n   * The process involves several key steps:\r\n   * 1.  **Initialization**: Sets up the maze, NEAT parameters, and the initial population of networks.\r\n   * 2.  **Generational Loop**: Iterates through generations, performing the following for each:\r\n   *     a. **Evaluation**: Each network's performance (fitness) is measured by how well its agent navigates the maze.\r\n   *        Fitness is typically based on progress towards the exit, speed, and efficiency.\r\n   *     b. **Lamarckian Refinement**: Each individual in the population undergoes a brief period of supervised training\r\n   *        (backpropagation) on a set of ideal sensory-action pairs. This helps to fine-tune promising behaviors.\r\n   *     c. **Selection & Reproduction**: The NEAT algorithm selects the fittest individuals to become parents for the\r\n   *        next generation. It uses genetic operators (crossover and mutation) to create offspring.\r\n   * 3.  **Termination**: The loop continues until a solution is found (an agent successfully reaches the exit) or other\r\n   *     stopping criteria are met (e.g., maximum generations, stagnation).\r\n   *\r\n   * This hybrid approach, combining the global search of evolution with the local search of backpropagation,\r\n   * can significantly accelerate learning and lead to more robust solutions.\r\n   *\r\n   * @param options - A comprehensive configuration object for the maze evolution process.\r\n   * @returns A Promise that resolves with an object containing the best network found, its simulation result, and the final NEAT instance.\r\n   */\r\n  static async runMazeEvolution(options: IRunMazeEvolutionOptions) {\r\n    // --- Step 1: Destructure and Default Configuration ---\r\n    // Extract all the necessary configuration objects from the main options parameter.\r\n    const {\r\n      mazeConfig,\r\n      agentSimConfig,\r\n      evolutionAlgorithmConfig,\r\n      reportingConfig,\r\n      fitnessEvaluator,\r\n    } = options;\r\n    const { maze } = mazeConfig;\r\n    const { logEvery = 10, dashboardManager } = reportingConfig;\r\n\r\n    // Extract evolution parameters, providing sensible defaults for any that are not specified.\r\n    const {\r\n      allowRecurrent = true, // Allow networks to have connections that loop back, enabling memory.\r\n      popSize = 500, // The number of neural networks in each generation.\r\n      maxStagnantGenerations = 500, // Stop evolution if the best fitness doesn't improve for this many generations.\r\n      minProgressToPass = 95, // The percentage of progress required to consider the maze \"solved\".\r\n      maxGenerations = Infinity, // A safety cap on the total number of generations to prevent infinite loops.\r\n      randomSeed, // An optional seed for the random number generator to ensure reproducible results.\r\n      initialPopulation, // An optional population of networks to start with.\r\n      initialBestNetwork, // An optional pre-trained network to seed the population.\r\n      lamarckianIterations = 10, // The number of backpropagation steps for each individual per generation.\r\n      lamarckianSampleSize, // If set, use a random subset of the training data for Lamarckian learning.\r\n      plateauGenerations = 40, // Number of generations to wait for improvement before considering the population to be on a plateau.\r\n      plateauImprovementThreshold = 1e-6, // The minimum fitness improvement required to reset the plateau counter.\r\n      simplifyDuration = 30, // The number of generations to run the network simplification process.\r\n      simplifyPruneFraction = 0.05, // The fraction of weak connections to prune during simplification.\r\n      simplifyStrategy = 'weakWeight', // The strategy for choosing which connections to prune.\r\n      persistEvery = 25, // Save a snapshot of the best networks every N generations.\r\n      persistDir = './ascii_maze_snapshots', // The directory to save snapshots in.\r\n      persistTopK = 3, // The number of top-performing networks to save in each snapshot.\r\n      dynamicPopEnabled = true, // Enable dynamic adjustment of the population size.\r\n      dynamicPopMax: dynamicPopMaxCfg, // The maximum population size for dynamic adjustments.\r\n      dynamicPopExpandInterval = 25, // The number of generations between population size expansions.\r\n      dynamicPopExpandFactor = 0.15, // The factor by which to expand the population size.\r\n      dynamicPopPlateauSlack = 0.6, // A slack factor for plateau detection when dynamic population is enabled.\r\n    } = evolutionAlgorithmConfig;\r\n\r\n    // Determine the maximum population size, with a fallback if not explicitly configured.\r\n    const dynamicPopMax =\r\n      typeof dynamicPopMaxCfg === 'number'\r\n        ? dynamicPopMaxCfg\r\n        : Math.max(popSize, 120);\r\n\r\n    // --- Step 2: Maze and Environment Setup ---\r\n    // Encode the maze into a numerical format (0 for walls, 1 for paths) for efficient processing.\r\n    const encodedMaze = MazeUtils.encodeMaze(maze);\r\n    // Locate the starting 'S' and exit 'E' positions within the maze.\r\n    const startPosition = MazeUtils.findPosition(maze, 'S');\r\n    const exitPosition = MazeUtils.findPosition(maze, 'E');\r\n    // Pre-calculate the distance from every point in the maze to the exit. This is a crucial\r\n    // optimization and provides a rich source of information for the fitness function.\r\n    const distanceMap = MazeUtils.buildDistanceMap(encodedMaze, exitPosition);\r\n\r\n    // Define the structure of the neural network: 6 inputs and 4 outputs.\r\n    // Inputs: [compassScalar, openN, openE, openS, openW, progressDelta]\r\n    // Outputs: [moveN, moveE, moveS, moveW]\r\n    const inputSize = 6;\r\n    const outputSize = 4;\r\n\r\n    // Select the fitness evaluator function. Use the provided one or a default.\r\n    const currentFitnessEvaluator =\r\n      fitnessEvaluator || FitnessEvaluator.defaultFitnessEvaluator;\r\n\r\n    // --- Step 3: Fitness Evaluation Context ---\r\n    // Bundle all the necessary environmental data into a context object. This object will be\r\n    // passed to the fitness function, so it has all the information it needs to evaluate a network.\r\n    const fitnessContext: IFitnessEvaluationContext = {\r\n      encodedMaze,\r\n      startPosition,\r\n      exitPosition,\r\n      agentSimConfig,\r\n      distanceMap,\r\n    };\r\n\r\n    // Create the fitness callback function that NEAT will use. This function takes a network,\r\n    // runs the simulation, and returns a single numerical score representing its fitness.\r\n    const neatFitnessCallback = (network: Network): number => {\r\n      return currentFitnessEvaluator(network, fitnessContext);\r\n    };\r\n\r\n    // --- Step 4: NEAT Algorithm Initialization ---\r\n    // Create a new instance of the Neat algorithm with a detailed configuration.\r\n    const neat = new Neat(inputSize, outputSize, neatFitnessCallback, {\r\n      popsize: popSize,\r\n      // Define the types of mutations that can occur, allowing for structural evolution.\r\n      mutation: [\r\n        methods.mutation.ADD_NODE,\r\n        methods.mutation.SUB_NODE,\r\n        methods.mutation.ADD_CONN,\r\n        methods.mutation.SUB_CONN,\r\n        methods.mutation.MOD_BIAS,\r\n        methods.mutation.MOD_ACTIVATION,\r\n        methods.mutation.MOD_CONNECTION,\r\n        methods.mutation.ADD_LSTM_NODE, // Allow adding LSTM nodes for more complex memory.\r\n      ],\r\n      mutationRate: 0.2,\r\n      mutationAmount: 0.3,\r\n      elitism: Math.max(1, Math.floor(popSize * 0.1)), // Preserve the top 10% of the population.\r\n      provenance: Math.max(1, Math.floor(popSize * 0.2)), // Keep a portion of the population from previous species.\r\n      allowRecurrent: allowRecurrent,\r\n      minHidden: 6, // Start with a minimum number of hidden nodes.\r\n      // Enable advanced features for more sophisticated evolution.\r\n      adaptiveMutation: { enabled: true, strategy: 'twoTier' },\r\n      multiObjective: {\r\n        enabled: true,\r\n        complexityMetric: 'nodes',\r\n        autoEntropy: true,\r\n      },\r\n      telemetry: {\r\n        enabled: true,\r\n        performance: true,\r\n        complexity: true,\r\n        hypervolume: true,\r\n      },\r\n      lineageTracking: true,\r\n      novelty: {\r\n        enabled: true,\r\n        descriptor: (g: any) => [g.nodes.length, g.connections.length],\r\n        blendFactor: 0.15,\r\n      },\r\n      targetSpecies: 10, // Aim for a target number of species to maintain diversity.\r\n      adaptiveTargetSpecies: {\r\n        enabled: true,\r\n        entropyRange: [0.3, 0.8],\r\n        speciesRange: [6, 14],\r\n        smooth: 0.5,\r\n      },\r\n    });\r\n\r\n    // If an initial population is provided, use it to seed the NEAT instance.\r\n    if (initialPopulation && initialPopulation.length > 0) {\r\n      neat.population = initialPopulation.map((net) =>\r\n        (net as Network).clone()\r\n      );\r\n    }\r\n    // If an initial best network is provided, inject it into the population.\r\n    if (initialBestNetwork) {\r\n      neat.population[0] = (initialBestNetwork as Network).clone();\r\n    }\r\n\r\n    // --- Step 5: Evolution State Tracking ---\r\n    // Initialize variables to track the progress of the evolution.\r\n    let bestNetwork: INetwork | undefined =\r\n      evolutionAlgorithmConfig.initialBestNetwork;\r\n    let bestFitness = -Infinity;\r\n    let bestResult: any;\r\n    let stagnantGenerations = 0;\r\n    let completedGenerations = 0;\r\n    let plateauCounter = 0;\r\n    let simplifyMode = false;\r\n    let simplifyRemaining = 0;\r\n    let lastBestFitnessForPlateau = -Infinity;\r\n\r\n    // --- Step 6: Filesystem and Persistence Setup ---\r\n    // Persistence uses Node fs/path. Guard the require calls so bundlers and browsers\r\n    // don't attempt to execute dynamic requires at runtime.\r\n    let fs: any = null;\r\n    let path: any = null;\r\n    try {\r\n      if (typeof window === 'undefined' && typeof require === 'function') {\r\n        // Running under Node.js environment\r\n        fs = require('fs');\r\n        path = require('path');\r\n      }\r\n    } catch {\r\n      // ignore - in browser environments require may not exist\r\n      fs = null;\r\n      path = null;\r\n    }\r\n\r\n    // Helper to yield to the browser frame so the DOM can repaint between heavy sync loops.\r\n    // In Node it falls back to setImmediate or setTimeout(0).\r\n    const flushToFrame = () => {\r\n      // Cooperative pause: if the host sets `window.asciiMazePaused = true`,\r\n      // the evolution loop will yield repeatedly without progressing. This keeps\r\n      // the UI responsive and allows the user to inspect the live state.\r\n      const rafPromise = () =>\r\n        new Promise<void>((resolve) =>\r\n          window.requestAnimationFrame(() => resolve())\r\n        );\r\n      const immediatePromise = () =>\r\n        new Promise<void>((resolve) =>\r\n          typeof setImmediate === 'function'\r\n            ? setImmediate(resolve)\r\n            : setTimeout(resolve, 0)\r\n        );\r\n\r\n      if (\r\n        typeof window !== 'undefined' &&\r\n        typeof window.requestAnimationFrame === 'function'\r\n      ) {\r\n        return new Promise<void>(async (resolve) => {\r\n          // If the pause flag is set, wait until it's cleared before resolving\r\n          const check = async () => {\r\n            if ((window as any).asciiMazePaused) {\r\n              // yield a frame and check again\r\n              await rafPromise();\r\n              setTimeout(check, 0);\r\n            } else {\r\n              rafPromise().then(() => resolve());\r\n            }\r\n          };\r\n          check();\r\n        });\r\n      }\r\n      if (typeof setImmediate === 'function') {\r\n        return new Promise<void>(async (resolve) => {\r\n          const check = async () => {\r\n            if ((globalThis as any).asciiMazePaused) {\r\n              await immediatePromise();\r\n              setTimeout(check, 0);\r\n            } else {\r\n              immediatePromise().then(() => resolve());\r\n            }\r\n          };\r\n          check();\r\n        });\r\n      }\r\n      return new Promise<void>((resolve) => setTimeout(resolve, 0));\r\n    };\r\n\r\n    if (fs && persistDir && !fs.existsSync(persistDir)) {\r\n      try {\r\n        fs.mkdirSync(persistDir, { recursive: true });\r\n      } catch (e) {\r\n        console.error(\r\n          `Could not create persistence directory: ${persistDir}`,\r\n          e\r\n        );\r\n      }\r\n    }\r\n\r\n    // --- Step 7: Lamarckian Learning Setup ---\r\n    // Define the supervised training set for the Lamarckian refinement process.\r\n    // This dataset consists of idealized sensory inputs and the corresponding optimal actions.\r\n    // It helps to quickly teach the networks basic, correct behaviors.\r\n    /**\r\n     * @const {Array<Object>} lamarckianTrainingSet\r\n     * Encodes idealized agent perceptions and the optimal action for each case.\r\n     * This is used for local search (backpropagation) to refine networks between generations.\r\n     *\r\n     * Input format: `[compassScalar, openN, openE, openS, openW, progressDelta]`\r\n     * - `compassScalar`: Direction to the exit (0=N, 0.25=E, 0.5=S, 0.75=W).\r\n     * - `openN/E/S/W`: Whether the path is open in that direction (1=open, 0=wall).\r\n     * - `progressDelta`: Change in distance to the exit ( >0.5 is good, <0.5 is bad).\r\n     *\r\n     * Output format: A one-hot encoded array representing the desired move `[N, E, S, W]`.\r\n     */\r\n    const lamarckianTrainingSet: {\r\n      input: number[];\r\n      output: number[];\r\n    }[] = (() => {\r\n      const ds: { input: number[]; output: number[] }[] = [];\r\n      // Helper to create a smoothed one-hot output vector.\r\n      const OUT = (d: number) =>\r\n        [0, 1, 2, 3].map((i) => (i === d ? 0.92 : 0.02));\r\n      // Helper to add a new training case.\r\n      const add = (inp: number[], dir: number) =>\r\n        ds.push({ input: inp, output: OUT(dir) });\r\n\r\n      // Cases: Single open path with good progress.\r\n      add([0, 1, 0, 0, 0, 0.7], 0); // Go North\r\n      add([0.25, 0, 1, 0, 0, 0.7], 1); // Go East\r\n      add([0.5, 0, 0, 1, 0, 0.7], 2); // Go South\r\n      add([0.75, 0, 0, 0, 1, 0.7], 3); // Go West\r\n\r\n      // Cases: Single open path with very strong progress.\r\n      add([0, 1, 0, 0, 0, 0.9], 0);\r\n      add([0.25, 0, 1, 0, 0, 0.9], 1);\r\n\r\n      // Cases: Two-way junctions, should follow the compass.\r\n      add([0, 1, 0.6, 0, 0, 0.6], 0);\r\n      add([0, 1, 0, 0.6, 0, 0.6], 0);\r\n      add([0.25, 0.6, 1, 0, 0, 0.6], 1);\r\n      add([0.25, 0, 1, 0.6, 0, 0.6], 1);\r\n      add([0.5, 0, 0.6, 1, 0, 0.6], 2);\r\n      add([0.5, 0, 0, 1, 0.6, 0.6], 2);\r\n      add([0.75, 0, 0, 0.6, 1, 0.6], 3);\r\n      add([0.75, 0.6, 0, 0, 1, 0.6], 3);\r\n\r\n      // Cases: Four-way junctions with slight progress, follow compass.\r\n      add([0, 1, 0.8, 0.5, 0.4, 0.55], 0);\r\n      add([0.25, 0.7, 1, 0.6, 0.5, 0.55], 1);\r\n      add([0.5, 0.6, 0.55, 1, 0.65, 0.55], 2);\r\n      add([0.75, 0.5, 0.45, 0.7, 1, 0.55], 3);\r\n\r\n      // Cases: Regressing (moving away from exit), should still follow compass to reorient.\r\n      add([0, 1, 0.3, 0, 0, 0.4], 0);\r\n      add([0.25, 0.5, 1, 0.4, 0, 0.4], 1);\r\n      add([0.5, 0, 0.3, 1, 0.2, 0.4], 2);\r\n      add([0.75, 0, 0.5, 0.4, 1, 0.4], 3);\r\n      // Back-only retreat pattern (only opposite available)\r\n      add([0, 0, 0, 0.001, 0, 0.45], 2);\r\n      // Mild augmentation (jitter openness & progress)\r\n      ds.forEach((p) => {\r\n        for (let i = 1; i <= 4; i++)\r\n          if (p.input[i] === 1 && Math.random() < 0.25)\r\n            p.input[i] = 0.95 + Math.random() * 0.05;\r\n        if (Math.random() < 0.35)\r\n          p.input[5] = Math.min(\r\n            1,\r\n            Math.max(0, p.input[5] + (Math.random() * 0.1 - 0.05))\r\n          );\r\n      });\r\n      return ds;\r\n    })();\r\n\r\n    // --- Pre-train generation 0 population on supervised compass dataset (Lamarckian warm start) ---\r\n    if (lamarckianTrainingSet.length) {\r\n      // Helper: recenters output node biases to avoid all outputs saturating high simultaneously.\r\n      const centerOutputBiases = (net: any) => {\r\n        try {\r\n          const outs = net.nodes?.filter((n: any) => n.type === 'output');\r\n          if (!outs?.length) return;\r\n          const mean =\r\n            outs.reduce((a: number, n: any) => a + n.bias, 0) / outs.length;\r\n          let varc = 0;\r\n          outs.forEach((n: any) => {\r\n            varc += Math.pow(n.bias - mean, 2);\r\n          });\r\n          varc /= outs.length;\r\n          const std = Math.sqrt(varc);\r\n          outs.forEach((n: any) => {\r\n            n.bias = Math.max(-5, Math.min(5, n.bias - mean)); // subtract mean & clamp\r\n          });\r\n          (net as any)._outputBiasStats = { mean, std };\r\n        } catch {\r\n          /* ignore */\r\n        }\r\n      };\r\n      neat.population.forEach((net: any, idx: number) => {\r\n        try {\r\n          net.train(lamarckianTrainingSet, {\r\n            iterations: Math.min(\r\n              60,\r\n              8 + Math.floor(lamarckianTrainingSet.length / 2)\r\n            ),\r\n            error: 0.01,\r\n            rate: 0.002,\r\n            momentum: 0.1,\r\n            batchSize: 4,\r\n            allowRecurrent: true,\r\n            cost: methods.Cost.softmaxCrossEntropy,\r\n          });\r\n          // Strengthen openness bits -> outputs mapping (inputs 1..4 correspond to N,E,S,W open flags)\r\n          try {\r\n            const outputNodes = net.nodes.filter(\r\n              (n: any) => n.type === 'output'\r\n            );\r\n            const inputNodes = net.nodes.filter((n: any) => n.type === 'input');\r\n            for (let d = 0; d < 4; d++) {\r\n              const inNode = inputNodes[d + 1]; // skip compass scalar at index 0\r\n              const outNode = outputNodes[d];\r\n              if (!inNode || !outNode) continue;\r\n              let conn = net.connections.find(\r\n                (c: any) => c.from === inNode && c.to === outNode\r\n              );\r\n              const w = Math.random() * 0.25 + 0.55; // 0.55..0.8\r\n              if (!conn) net.connect(inNode, outNode, w);\r\n              else conn.weight = w;\r\n            }\r\n            // Light compass scalar fan-out with small weights to allow direction discrimination learning\r\n            const compassNode = inputNodes[0];\r\n            if (compassNode) {\r\n              outputNodes.forEach((out: any, d: number) => {\r\n                let conn = net.connections.find(\r\n                  (c: any) => c.from === compassNode && c.to === out\r\n                );\r\n                const base = 0.05 + d * 0.01; // slight differentiation\r\n                if (!conn) net.connect(compassNode, out, base);\r\n                else conn.weight = base;\r\n              });\r\n            }\r\n          } catch {\r\n            /* ignore */\r\n          }\r\n          centerOutputBiases(net);\r\n        } catch {\r\n          /* ignore training errors */\r\n        }\r\n      });\r\n    }\r\n\r\n    // Lightweight profiling (opt-in): set env ASCII_MAZE_PROFILE=1 to enable\r\n    const doProfile =\r\n      typeof process !== 'undefined' &&\r\n      typeof process.env !== 'undefined' &&\r\n      process.env.ASCII_MAZE_PROFILE === '1';\r\n    let tEvolveTotal = 0;\r\n    let tLamarckTotal = 0;\r\n    let tSimTotal = 0;\r\n\r\n    // Safe writer: prefer Node stdout when available, else dashboard logger, else console.log\r\n    const safeWrite = (msg: string) => {\r\n      try {\r\n        if (\r\n          typeof process !== 'undefined' &&\r\n          process &&\r\n          process.stdout &&\r\n          typeof process.stdout.write === 'function'\r\n        ) {\r\n          process.stdout.write(msg);\r\n          return;\r\n        }\r\n      } catch {\r\n        /* ignore */\r\n      }\r\n      // Try to use dashboard manager logger if provided\r\n      try {\r\n        if (dashboardManager && (dashboardManager as any).logFunction) {\r\n          try {\r\n            (dashboardManager as any).logFunction(msg);\r\n            return;\r\n          } catch {\r\n            // fall through to console\r\n          }\r\n        }\r\n      } catch {\r\n        /* ignore */\r\n      }\r\n      if (typeof console !== 'undefined' && console.log)\r\n        console.log(msg.trim());\r\n    };\r\n\r\n    while (true) {\r\n      // === Evolutionary Loop ===\r\n      // 1. Darwinian evolution: evolve the population (shuffle genomes)\r\n      //    Evolve one generation and get the fittest network.\r\n      //    This applies selection, crossover, and mutation to produce the next population.\r\n      const t0 = doProfile ? Date.now() : 0;\r\n      const fittest = await neat.evolve();\r\n      if (doProfile) tEvolveTotal += Date.now() - t0;\r\n      // Force identity activation on output nodes; we apply softmax externally (improves gradient richness & avoids early saturation)\r\n      (neat.population || []).forEach((g: any) => {\r\n        g.nodes?.forEach((n: any) => {\r\n          if (n.type === 'output') n.squash = methods.Activation.identity;\r\n        });\r\n      });\r\n\r\n      // --- Diversity guardrail: if species collapsed to 1 for 20+ generations, temporarily boost mutation + novelty\r\n      (EvolutionEngine as any)._speciesHistory =\r\n        (EvolutionEngine as any)._speciesHistory || [];\r\n      const speciesCount =\r\n        (neat as any).population?.reduce((set: Set<any>, g: any) => {\r\n          if (g.species) set.add(g.species);\r\n          return set;\r\n        }, new Set()).size || 1;\r\n      (EvolutionEngine as any)._speciesHistory.push(speciesCount);\r\n      if ((EvolutionEngine as any)._speciesHistory.length > 50)\r\n        (EvolutionEngine as any)._speciesHistory.shift();\r\n      const recent = (EvolutionEngine as any)._speciesHistory.slice(-20);\r\n      const collapsed =\r\n        recent.length === 20 && recent.every((c: number) => c === 1);\r\n      if (collapsed) {\r\n        // Temporarily escalate mutation params and novelty blend to force exploration\r\n        const neatAny: any = neat as any;\r\n        if (typeof neatAny.mutationRate === 'number')\r\n          neatAny.mutationRate = Math.min(0.6, neatAny.mutationRate * 1.5);\r\n        if (typeof neatAny.mutationAmount === 'number')\r\n          neatAny.mutationAmount = Math.min(0.8, neatAny.mutationAmount * 1.3);\r\n        if (neatAny.config && neatAny.config.novelty) {\r\n          neatAny.config.novelty.blendFactor = Math.min(\r\n            0.4,\r\n            neatAny.config.novelty.blendFactor * 1.2\r\n          );\r\n        }\r\n      }\r\n\r\n      // --- Dynamic population expansion (only grows; does not shrink) ---\r\n      // Rationale: Start with smaller population for faster iterations; expand search space when stagnating.\r\n      if (\r\n        dynamicPopEnabled &&\r\n        completedGenerations > 0 &&\r\n        neat.population?.length &&\r\n        neat.population.length < dynamicPopMax\r\n      ) {\r\n        const plateauRatio =\r\n          plateauGenerations > 0 ? plateauCounter / plateauGenerations : 0;\r\n        const genTrigger =\r\n          completedGenerations % dynamicPopExpandInterval === 0;\r\n        if (genTrigger && plateauRatio >= dynamicPopPlateauSlack) {\r\n          const currentSize = neat.population.length;\r\n          const targetAdd = Math.min(\r\n            Math.max(1, Math.floor(currentSize * dynamicPopExpandFactor)),\r\n            dynamicPopMax - currentSize\r\n          );\r\n          if (targetAdd > 0) {\r\n            // Sort by score descending; use top quarter as parents\r\n            const sorted = neat.population\r\n              .slice()\r\n              .sort(\r\n                (a: any, b: any) =>\r\n                  (b.score || -Infinity) - (a.score || -Infinity)\r\n              );\r\n            const parentPool = sorted.slice(\r\n              0,\r\n              Math.max(2, Math.ceil(sorted.length * 0.25))\r\n            );\r\n            for (let i = 0; i < targetAdd; i++) {\r\n              const parent =\r\n                parentPool[Math.floor(Math.random() * parentPool.length)];\r\n              const clone = parent.clone ? parent.clone() : parent; // defensive\r\n              // Apply a few random mutations to diversify\r\n              const mutateCount = 1 + (Math.random() < 0.5 ? 1 : 0);\r\n              for (let m = 0; m < mutateCount; m++) {\r\n                try {\r\n                  const mutOps = neat.options.mutation || [];\r\n                  if (mutOps.length) {\r\n                    const op =\r\n                      mutOps[Math.floor(Math.random() * mutOps.length)];\r\n                    clone.mutate(op);\r\n                  }\r\n                } catch {\r\n                  /* ignore */\r\n                }\r\n              }\r\n              // Reset score so it will be evaluated newly\r\n              clone.score = undefined;\r\n              neat.population.push(clone);\r\n            }\r\n            neat.options.popsize = neat.population.length; // keep config consistent\r\n            safeWrite(\r\n              `[DYNAMIC_POP] Expanded population to ${neat.population.length} at gen ${completedGenerations}\\n`\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // 2. Lamarckian evolution: backprop refinement for each individual (everyone goes to school)\r\n      //    Each network is trained with a small number of supervised learning steps on the idealized set.\r\n      //    This directly modifies the weights that will be inherited by the next generation (Lamarckian).\r\n      if (lamarckianIterations > 0 && lamarckianTrainingSet.length) {\r\n        const t1 = doProfile ? Date.now() : 0;\r\n        // Optional sampling to cut cost\r\n        let trainingSetRef = lamarckianTrainingSet;\r\n        if (\r\n          lamarckianSampleSize &&\r\n          lamarckianSampleSize < lamarckianTrainingSet.length\r\n        ) {\r\n          // Reservoir sample simple approach\r\n          const picked: typeof lamarckianTrainingSet = [];\r\n          for (let i = 0; i < lamarckianSampleSize; i++) {\r\n            picked.push(\r\n              lamarckianTrainingSet[\r\n                (Math.random() * lamarckianTrainingSet.length) | 0\r\n              ]\r\n            );\r\n          }\r\n          trainingSetRef = picked;\r\n        }\r\n        let gradNormSum = 0;\r\n        let gradSamples = 0;\r\n        neat.population.forEach((network) => {\r\n          network.train(trainingSetRef, {\r\n            iterations: lamarckianIterations, // Small to preserve diversity\r\n            error: 0.01,\r\n            rate: 0.001,\r\n            momentum: 0.2,\r\n            batchSize: 2,\r\n            allowRecurrent: true, // allow recurrent connections\r\n            cost: methods.Cost.softmaxCrossEntropy,\r\n          });\r\n          // Re-center output biases after local refinement\r\n          try {\r\n            const outs = (network as any).nodes?.filter(\r\n              (n: any) => n.type === 'output'\r\n            );\r\n            if (outs?.length) {\r\n              const mean =\r\n                outs.reduce((a: number, n: any) => a + n.bias, 0) / outs.length;\r\n              let varc = 0;\r\n              outs.forEach((n: any) => {\r\n                varc += Math.pow(n.bias - mean, 2);\r\n              });\r\n              varc /= outs.length;\r\n              const std = Math.sqrt(varc);\r\n              outs.forEach((n: any) => {\r\n                let adjusted = n.bias - mean;\r\n                if (std < 0.25) adjusted *= 0.7; // compress if low variance cluster\r\n                n.bias = Math.max(-5, Math.min(5, adjusted));\r\n              });\r\n            }\r\n          } catch {\r\n            /* ignore */\r\n          }\r\n          // Capture gradient norm stats if available\r\n          try {\r\n            if (typeof (network as any).getTrainingStats === 'function') {\r\n              const ts = (network as any).getTrainingStats();\r\n              if (ts && Number.isFinite(ts.gradNorm)) {\r\n                gradNormSum += ts.gradNorm;\r\n                gradSamples++;\r\n              }\r\n            }\r\n          } catch {\r\n            /* ignore */\r\n          }\r\n        });\r\n        if (gradSamples > 0) {\r\n          safeWrite(\r\n            `[GRAD] gen=${completedGenerations} meanGradNorm=${(\r\n              gradNormSum / gradSamples\r\n            ).toFixed(4)} samples=${gradSamples}\\n`\r\n          );\r\n        }\r\n        if (doProfile) tLamarckTotal += Date.now() - t1;\r\n      }\r\n\r\n      // 3. Baldwinian refinement: further train the fittest individual for evaluation only.\r\n      //    This improves its performance for this generation's evaluation, but only the Lamarckian-trained\r\n      //    weights are inherited by offspring. (If you want pure Lamarckian, remove this step.)\r\n      /*\r\n      fittest.train(lamarckianTrainingSet, {\r\n        iterations: 1000, // More steps for the fittest\r\n        error: 0.01,\r\n        rate: 0.001,\r\n        momentum: 0.2,\r\n        batchSize: 20,\r\n        allowRecurrent: true, // allow recurrent connections\r\n      });\r\n      */\r\n\r\n      // 4. Evaluate and track progress\r\n      const fitness = fittest.score ?? 0;\r\n      completedGenerations++;\r\n\r\n      // Plateau detection logic\r\n      if (fitness > lastBestFitnessForPlateau + plateauImprovementThreshold) {\r\n        plateauCounter = 0;\r\n        lastBestFitnessForPlateau = fitness;\r\n      } else {\r\n        plateauCounter++;\r\n      }\r\n      // Enter simplify mode\r\n      if (!simplifyMode && plateauCounter >= plateauGenerations) {\r\n        simplifyMode = true;\r\n        simplifyRemaining = simplifyDuration;\r\n        plateauCounter = 0; // reset\r\n      }\r\n      // Apply simplify pruning if active\r\n      if (simplifyMode) {\r\n        // Disable weakest fraction of enabled connections in each genome\r\n        neat.population.forEach((g: any) => {\r\n          const enabledConns = g.connections.filter(\r\n            (c: any) => c.enabled !== false\r\n          );\r\n          if (!enabledConns.length) return;\r\n          const pruneCount = Math.max(\r\n            1,\r\n            Math.floor(enabledConns.length * simplifyPruneFraction)\r\n          );\r\n          let candidates = enabledConns.slice();\r\n          if (simplifyStrategy === 'weakRecurrentPreferred') {\r\n            // Identify recurrent (self-loop or cycle gating) connections first; heuristic: from===to or gater present\r\n            const recurrent = candidates.filter(\r\n              (c: any) => c.from === c.to || c.gater\r\n            );\r\n            const nonRecurrent = candidates.filter(\r\n              (c: any) => !(c.from === c.to || c.gater)\r\n            );\r\n            // Sort each group by absolute weight ascending\r\n            recurrent.sort(\r\n              (a: any, b: any) => Math.abs(a.weight) - Math.abs(b.weight)\r\n            );\r\n            nonRecurrent.sort(\r\n              (a: any, b: any) => Math.abs(a.weight) - Math.abs(b.weight)\r\n            );\r\n            // Prefer pruning weak recurrent connections first, then remaining weak weights\r\n            candidates = [...recurrent, ...nonRecurrent];\r\n          } else {\r\n            candidates.sort(\r\n              (a: any, b: any) => Math.abs(a.weight) - Math.abs(b.weight)\r\n            );\r\n          }\r\n          candidates\r\n            .slice(0, pruneCount)\r\n            .forEach((c: any) => (c.enabled = false));\r\n        });\r\n        simplifyRemaining--;\r\n        if (simplifyRemaining <= 0) simplifyMode = false;\r\n      }\r\n\r\n      // Simulate the agent using the fittest network\r\n      // This provides a detailed result (success, progress, steps, etc.)\r\n      const t2 = doProfile ? Date.now() : 0;\r\n      const generationResult = MazeMovement.simulateAgent(\r\n        fittest,\r\n        encodedMaze,\r\n        startPosition,\r\n        exitPosition,\r\n        distanceMap,\r\n        agentSimConfig.maxSteps\r\n      );\r\n      // Capture output history from simulation for telemetry (mazeMovement stores on network)\r\n      try {\r\n        (fittest as any)._lastStepOutputs =\r\n          (fittest as any)._lastStepOutputs ||\r\n          (fittest as any)._lastStepOutputs;\r\n      } catch {}\r\n      // Attach auxiliary metrics to fittest genome for potential external analysis\r\n      (fittest as any)._saturationFraction =\r\n        generationResult.saturationFraction;\r\n      (fittest as any)._actionEntropy = generationResult.actionEntropy;\r\n      // Saturation-based pruning heuristic: if outputs are chronically saturated reduce weak outgoing weights\r\n      if (\r\n        generationResult.saturationFraction &&\r\n        generationResult.saturationFraction > 0.5\r\n      ) {\r\n        try {\r\n          const outNodes = fittest.nodes.filter(\r\n            (n: any) => n.type === 'output'\r\n          );\r\n          // Identify hidden nodes whose outgoing weights converge to all outputs with similar large activations\r\n          const hidden = fittest.nodes.filter((n: any) => n.type === 'hidden');\r\n          hidden.forEach((h: any) => {\r\n            // Gather outgoing connections to outputs\r\n            const outs = h.connections.out.filter(\r\n              (c: any) => outNodes.includes(c.to) && c.enabled !== false\r\n            );\r\n            if (outs.length >= 2) {\r\n              // Compute absolute weight mean & variance\r\n              const weights = outs.map((c: any) => Math.abs(c.weight));\r\n              const mean =\r\n                weights.reduce((a: number, b: number) => a + b, 0) /\r\n                weights.length;\r\n              const varc =\r\n                weights.reduce(\r\n                  (a: number, b: number) => a + Math.pow(b - mean, 2),\r\n                  0\r\n                ) / weights.length;\r\n              if (mean < 0.5 && varc < 0.01) {\r\n                // Likely low-signal uniform fan-out: disable weakest half to force differentiation\r\n                outs.sort(\r\n                  (a: any, b: any) => Math.abs(a.weight) - Math.abs(b.weight)\r\n                );\r\n                const disableCount = Math.max(1, Math.floor(outs.length / 2));\r\n                for (let i = 0; i < disableCount; i++) outs[i].enabled = false;\r\n              }\r\n            }\r\n          });\r\n        } catch {\r\n          /* soft-fail */\r\n        }\r\n      }\r\n      // Instrumentation: log approximate action entropy (based on path move variety)\r\n      if (completedGenerations % logEvery === 0) {\r\n        try {\r\n          const movesRaw = generationResult.path.map(\r\n            (p: [number, number], idx: number, arr: any[]) => {\r\n              if (idx === 0) return null;\r\n              const prev = arr[idx - 1];\r\n              const dx = p[0] - prev[0];\r\n              const dy = p[1] - prev[1];\r\n              if (dx === 0 && dy === -1) return 0;\r\n              if (dx === 1 && dy === 0) return 1;\r\n              if (dx === 0 && dy === 1) return 2;\r\n              if (dx === -1 && dy === 0) return 3;\r\n              return null;\r\n            }\r\n          );\r\n          const moves: number[] = [];\r\n          for (const mv of movesRaw) {\r\n            if (mv !== null) moves.push(mv as number);\r\n          }\r\n          const counts = [0, 0, 0, 0];\r\n          moves.forEach((m: number) => counts[m]++);\r\n          const totalMoves = moves.length || 1;\r\n          const probs = counts.map((c) => c / totalMoves);\r\n          let entropy = 0;\r\n          probs.forEach((p) => {\r\n            if (p > 0) entropy += -p * Math.log(p);\r\n          });\r\n          // natural log entropy max ln(4)=1.386; normalize\r\n          const entropyNorm = entropy / Math.log(4);\r\n          safeWrite(\r\n            `[ACTION_ENTROPY] gen=${completedGenerations} entropyNorm=${entropyNorm.toFixed(\r\n              3\r\n            )} uniqueMoves=${counts.filter((c) => c > 0).length} pathLen=${\r\n              generationResult.path.length\r\n            }\\n`\r\n          );\r\n          // Output bias stats for fittest network\r\n          try {\r\n            const outs = fittest.nodes.filter((n: any) => n.type === 'output');\r\n            if (outs.length) {\r\n              const meanB =\r\n                outs.reduce((a: number, n: any) => a + n.bias, 0) / outs.length;\r\n              let varcB = 0;\r\n              outs.forEach((n: any) => {\r\n                varcB += Math.pow(n.bias - meanB, 2);\r\n              });\r\n              varcB /= outs.length;\r\n              const stdB = Math.sqrt(varcB);\r\n              safeWrite(\r\n                `[OUTPUT_BIAS] gen=${completedGenerations} mean=${meanB.toFixed(\r\n                  3\r\n                )} std=${stdB.toFixed(3)} biases=${outs\r\n                  .map((o: any) => o.bias.toFixed(2))\r\n                  .join(',')}\\n`\r\n              );\r\n            }\r\n          } catch {}\r\n          // Enhanced output logits / softmax telemetry (if last step outputs captured)\r\n          try {\r\n            const lastHist: number[][] =\r\n              (fittest as any)._lastStepOutputs || [];\r\n            if (lastHist.length) {\r\n              const recent = lastHist.slice(-40);\r\n              // Aggregate per-output mean & std\r\n              const k = 4;\r\n              const means = new Array(k).fill(0);\r\n              recent.forEach((v) => {\r\n                for (let i = 0; i < k; i++) means[i] += v[i];\r\n              });\r\n              for (let i = 0; i < k; i++) means[i] /= recent.length;\r\n              const stds = new Array(k).fill(0);\r\n              recent.forEach((v) => {\r\n                for (let i = 0; i < k; i++)\r\n                  stds[i] += Math.pow(v[i] - means[i], 2);\r\n              });\r\n              for (let i = 0; i < k; i++)\r\n                stds[i] = Math.sqrt(stds[i] / recent.length);\r\n              // Kurtosis (Fisher, subtract 3)\r\n              const kurt = new Array(k).fill(0);\r\n              recent.forEach((v) => {\r\n                for (let i = 0; i < k; i++)\r\n                  kurt[i] += Math.pow(v[i] - means[i], 4);\r\n              });\r\n              for (let i = 0; i < k; i++) {\r\n                const denom = Math.pow(stds[i] || 1e-9, 4) * recent.length;\r\n                kurt[i] = denom > 0 ? kurt[i] / denom - 3 : 0;\r\n              }\r\n              // Softmax distribution mean entropy over recent steps\r\n              let entAgg = 0;\r\n              recent.forEach((v) => {\r\n                const max = Math.max(...v);\r\n                const exps = v.map((x) => Math.exp(x - max));\r\n                const sum = exps.reduce((a, b) => a + b, 0) || 1;\r\n                const probs = exps.map((e) => e / sum);\r\n                let e = 0;\r\n                probs.forEach((p) => {\r\n                  if (p > 0) e += -p * Math.log(p);\r\n                });\r\n                entAgg += e / Math.log(4);\r\n              });\r\n              const entMean = entAgg / recent.length;\r\n              // Decision stability: fraction of consecutive identical argmax\r\n              let stable = 0,\r\n                totalTrans = 0;\r\n              let prevDir = -1;\r\n              recent.forEach((v) => {\r\n                const arg = v.indexOf(Math.max(...v));\r\n                if (prevDir === arg) stable++;\r\n                if (prevDir !== -1) totalTrans++;\r\n                prevDir = arg;\r\n              });\r\n              const stability = totalTrans ? stable / totalTrans : 0;\r\n              safeWrite(\r\n                `[LOGITS] gen=${completedGenerations} means=${means\r\n                  .map((m) => m.toFixed(3))\r\n                  .join(',')} stds=${stds\r\n                  .map((s) => s.toFixed(3))\r\n                  .join(',')} kurt=${kurt\r\n                  .map((kv) => kv.toFixed(2))\r\n                  .join(',')} entMean=${entMean.toFixed(\r\n                  3\r\n                )} stability=${stability.toFixed(3)} steps=${recent.length}\\n`\r\n              );\r\n              // Anti-collapse trigger: if all std below threshold & entropy low OR stability extremely high\r\n              (EvolutionEngine as any)._collapseStreak =\r\n                (EvolutionEngine as any)._collapseStreak || 0;\r\n              const collapsed =\r\n                stds.every((s) => s < 0.005) &&\r\n                (entMean < 0.35 || stability > 0.97);\r\n              if (collapsed) (EvolutionEngine as any)._collapseStreak++;\r\n              else (EvolutionEngine as any)._collapseStreak = 0;\r\n              if ((EvolutionEngine as any)._collapseStreak === 6) {\r\n                // Reinitialize a fraction of non-elite population's output weights to break collapse\r\n                try {\r\n                  const eliteCount = neat.options.elitism || 0;\r\n                  const pop = neat.population || [];\r\n                  const reinitTargets = pop\r\n                    .slice(eliteCount)\r\n                    .filter(() => Math.random() < 0.3);\r\n                  let connReset = 0,\r\n                    biasReset = 0;\r\n                  reinitTargets.forEach((g: any) => {\r\n                    const outs = g.nodes.filter(\r\n                      (n: any) => n.type === 'output'\r\n                    );\r\n                    // Reset biases\r\n                    outs.forEach((o: any) => {\r\n                      o.bias = Math.random() * 0.2 - 0.1;\r\n                      biasReset++;\r\n                    });\r\n                    // Reset incoming connection weights to outputs\r\n                    g.connections.forEach((c: any) => {\r\n                      if (outs.includes(c.to)) {\r\n                        c.weight = Math.random() * 0.4 - 0.2;\r\n                        connReset++;\r\n                      }\r\n                    });\r\n                  });\r\n                  safeWrite(\r\n                    `[ANTICOLLAPSE] gen=${completedGenerations} reinitGenomes=${reinitTargets.length} connReset=${connReset} biasReset=${biasReset}\\n`\r\n                  );\r\n                } catch {\r\n                  /* ignore */\r\n                }\r\n              }\r\n            }\r\n          } catch {}\r\n          // Exploration ratio (unique / path length)\r\n          try {\r\n            const unique = generationResult.path.length\r\n              ? new Set(generationResult.path.map((p: any) => p.join(','))).size\r\n              : 0;\r\n            const ratio = generationResult.path.length\r\n              ? unique / generationResult.path.length\r\n              : 0;\r\n            safeWrite(\r\n              `[EXPLORE] gen=${completedGenerations} unique=${unique} pathLen=${\r\n                generationResult.path.length\r\n              } ratio=${ratio.toFixed(\r\n                3\r\n              )} progress=${generationResult.progress.toFixed(\r\n                1\r\n              )} satFrac=${(generationResult as any).saturationFraction?.toFixed(\r\n                3\r\n              )}\\n`\r\n            );\r\n          } catch {}\r\n          // Diversity metrics (species distribution + basic connection weight variance)\r\n          try {\r\n            const pop: any[] = neat.population || [];\r\n            const speciesCounts: Record<string, number> = {};\r\n            pop.forEach((g) => {\r\n              const sid = g.species != null ? String(g.species) : 'none';\r\n              speciesCounts[sid] = (speciesCounts[sid] || 0) + 1;\r\n            });\r\n            const counts = Object.values(speciesCounts);\r\n            const total = counts.reduce((a, b) => a + b, 0) || 1;\r\n            const simpson =\r\n              1 - counts.reduce((a, b) => a + Math.pow(b / total, 2), 0); // Simpson diversity index\r\n            // Weight variance sample (subset for speed)\r\n            let wMean = 0,\r\n              wCount = 0;\r\n            const sample = pop.slice(0, Math.min(pop.length, 40));\r\n            sample.forEach((g) => {\r\n              g.connections.forEach((c: any) => {\r\n                if (c.enabled !== false) {\r\n                  wMean += c.weight;\r\n                  wCount++;\r\n                }\r\n              });\r\n            });\r\n            wMean = wCount ? wMean / wCount : 0;\r\n            let wVar = 0;\r\n            sample.forEach((g) => {\r\n              g.connections.forEach((c: any) => {\r\n                if (c.enabled !== false) wVar += Math.pow(c.weight - wMean, 2);\r\n              });\r\n            });\r\n            const wStd = wCount ? Math.sqrt(wVar / wCount) : 0;\r\n            safeWrite(\r\n              `[DIVERSITY] gen=${completedGenerations} species=${\r\n                Object.keys(speciesCounts).length\r\n              } simpson=${simpson.toFixed(3)} weightStd=${wStd.toFixed(3)}\\n`\r\n            );\r\n          } catch {}\r\n        } catch {}\r\n      }\r\n      if (doProfile) tSimTotal += Date.now() - t2;\r\n\r\n      // If new best, update tracking and dashboard\r\n      if (fitness > bestFitness) {\r\n        bestFitness = fitness;\r\n        bestNetwork = fittest;\r\n        bestResult = generationResult;\r\n        stagnantGenerations = 0;\r\n        dashboardManager.update(\r\n          maze,\r\n          generationResult,\r\n          fittest,\r\n          completedGenerations,\r\n          neat\r\n        );\r\n        try {\r\n          // yield to the browser to allow DOM paint\r\n          await flushToFrame();\r\n        } catch {}\r\n      } else {\r\n        stagnantGenerations++;\r\n        // Periodically update dashboard with current best\r\n        if (completedGenerations % logEvery === 0) {\r\n          if (bestNetwork && bestResult) {\r\n            dashboardManager.update(\r\n              maze,\r\n              bestResult,\r\n              bestNetwork,\r\n              completedGenerations,\r\n              neat\r\n            );\r\n            try {\r\n              await flushToFrame();\r\n            } catch {}\r\n          }\r\n        }\r\n      }\r\n\r\n      // Persistence snapshot\r\n      if (\r\n        persistEvery > 0 &&\r\n        completedGenerations % persistEvery === 0 &&\r\n        bestNetwork\r\n      ) {\r\n        try {\r\n          const snap: any = {\r\n            generation: completedGenerations,\r\n            bestFitness: bestFitness,\r\n            simplifyMode,\r\n            plateauCounter,\r\n            timestamp: Date.now(),\r\n            telemetryTail: neat.getTelemetry\r\n              ? neat.getTelemetry().slice(-5)\r\n              : undefined,\r\n          };\r\n          const popSorted = neat.population\r\n            .slice()\r\n            .sort(\r\n              (a: any, b: any) =>\r\n                (b.score || -Infinity) - (a.score || -Infinity)\r\n            );\r\n          const top = popSorted\r\n            .slice(0, persistTopK)\r\n            .map((g: any, idx: number) => ({\r\n              idx,\r\n              score: g.score,\r\n              nodes: g.nodes.length,\r\n              connections: g.connections.length,\r\n              json: g.toJSON ? g.toJSON() : undefined,\r\n            }));\r\n          snap.top = top;\r\n          const file = path.join(\r\n            persistDir,\r\n            `snapshot_gen${completedGenerations}.json`\r\n          );\r\n          fs.writeFileSync(file, JSON.stringify(snap, null, 2));\r\n        } catch (e) {\r\n          // ignore persistence errors\r\n        }\r\n      }\r\n\r\n      // Stop if solved or sufficient progress\r\n      if (bestResult?.success && bestResult.progress >= minProgressToPass) {\r\n        if (bestNetwork && bestResult) {\r\n          dashboardManager.update(\r\n            maze,\r\n            bestResult,\r\n            bestNetwork,\r\n            completedGenerations,\r\n            neat\r\n          );\r\n          try {\r\n            await flushToFrame();\r\n          } catch {}\r\n        }\r\n        break;\r\n      }\r\n\r\n      // Stop if stagnation limit reached\r\n      if (stagnantGenerations >= maxStagnantGenerations) {\r\n        if (bestNetwork && bestResult) {\r\n          dashboardManager.update(\r\n            maze,\r\n            bestResult,\r\n            bestNetwork,\r\n            completedGenerations,\r\n            neat\r\n          );\r\n          try {\r\n            await flushToFrame();\r\n          } catch {}\r\n        }\r\n        break;\r\n      }\r\n\r\n      // Safety cap on generations\r\n      if (completedGenerations >= maxGenerations) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (doProfile && completedGenerations > 0) {\r\n      const gen = completedGenerations;\r\n      const avgEvolve = (tEvolveTotal / gen).toFixed(2);\r\n      const avgLamarck = (tLamarckTotal / gen).toFixed(2);\r\n      const avgSim = (tSimTotal / gen).toFixed(2);\r\n      // Direct stdout to avoid jest buffering suppression\r\n      safeWrite(\r\n        `\\n[PROFILE] Generations=${gen} avg(ms): evolve=${avgEvolve} lamarck=${avgLamarck} sim=${avgSim} totalPerGen=${(\r\n          +avgEvolve +\r\n          +avgLamarck +\r\n          +avgSim\r\n        ).toFixed(2)}\\n`\r\n      );\r\n    }\r\n\r\n    // Return the best network, its result, and the NEAT instance\r\n    return {\r\n      bestNetwork,\r\n      bestResult,\r\n      neat,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Prints the structure of a given neural network to the console.\r\n   *\r\n   * This is useful for debugging and understanding the evolved architectures.\r\n   * It prints the number of nodes, their types, activation functions, and connection details.\r\n   *\r\n   * @param network - The neural network to inspect.\r\n   */\r\n  static printNetworkStructure(network: INetwork) {\r\n    // Print high-level network structure and statistics\r\n    console.log('Network Structure:');\r\n    console.log('Nodes: ', network.nodes?.length); // Total number of nodes\r\n    const inputNodes = network.nodes?.filter((n) => n.type === 'input');\r\n    const outputNodes = network.nodes?.filter((n) => n.type === 'output');\r\n    const hiddenNodes = network.nodes?.filter((n) => n.type === 'hidden');\r\n    console.log('Input nodes: ', inputNodes?.length); // Number of input nodes\r\n    console.log('Hidden nodes: ', hiddenNodes?.length); // Number of hidden nodes\r\n    console.log('Output nodes: ', outputNodes?.length); // Number of output nodes\r\n    console.log(\r\n      'Activation functions: ',\r\n      network.nodes?.map((n) => n.squash?.name || n.squash)\r\n    ); // List of activation functions\r\n    console.log('Connections: ', network.connections?.length); // Number of connections\r\n    const recurrent = network.connections?.some(\r\n      (c) => c.gater || c.from === c.to\r\n    ); // Whether there are recurrent/gated connections\r\n    console.log('Has recurrent/gated connections: ', recurrent);\r\n    // if (network.layers) { // Property 'layers' does not exist on type 'INetwork'.\r\n    //   Object.entries(network.layers).forEach(([name, layer]) => {\r\n    //     if (Array.isArray(layer)) {\r\n    //       console.log(`Layer ${name}:`, layer.length, ' nodes');\r\n    //     } else if (layer && typeof layer === 'object' && 'nodes' in layer) {\r\n    //       // For Neataptic Layer objects\r\n    //       // @ts-ignore\r\n    //       console.log(`Layer ${name}: `, layer.nodes.length, ' nodes');\r\n    //     }\r\n    //   });\r\n    // }\r\n  }\r\n}\r\n", "/**\r\n * Maze Definitions - Collection of test mazes with varying complexity\r\n *\r\n * This module contains predefined ASCII mazes used for testing and training\r\n * the neural network agents. The mazes range from simple to complex and demonstrate\r\n * different challenges for pathfinding algorithms.\r\n *\r\n * Maze symbols:\r\n * - '\u2551' = Wall (obstacle the agent cannot pass through)\r\n * - '.' = Open path\r\n * - 'S' = Start position\r\n * - 'E' = Exit/Goal position\r\n *\r\n * Each maze contains exactly one start ('S') and one exit ('E') position.\r\n */\r\n\r\n/** Very small maze for quick testing with minimal complexity */\r\nexport const tiny = [\r\n  '\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557',\r\n  '\u2551S...................\u2551',\r\n  '\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2551',\r\n  '\u2551....................\u2551',\r\n  '\u2551.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563',\r\n  '\u2551....................\u2551',\r\n  '\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557E\u2551',\r\n];\r\n\r\n/** Small spiral maze - tests the agent's ability to follow a continuous path */\r\nexport const spiralSmall = [\r\n  '\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557',\r\n  '\u2551...........\u2551',\r\n  '\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551',\r\n  '\u2551.\u2551.......\u2551.\u2551',\r\n  '\u2551.\u2551.\u2554\u2550\u2550\u2550\u2557.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551...\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551S\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u255A\u2550\u255D.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.....\u2551.\u2551.\u2551',\r\n  '\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551',\r\n  '\u2551.........\u2551.\u2551',\r\n  '\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563E\u2551',\r\n];\r\n\r\n/** Medium spiral maze - more challenging version requiring longer path following */\r\nexport const spiral = [\r\n  '\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557',\r\n  '\u2551...............\u2551',\r\n  '\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563',\r\n  '\u2551.\u2551.\u2551...........\u2551',\r\n  '\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.......\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2557.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551...\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551S\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u255D.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.....\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.........\u2551.\u2551',\r\n  '\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551',\r\n  '\u2551.\u2551.............\u2551',\r\n  '\u2551E\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D',\r\n];\r\n\r\n/** Small maze with multiple path options and dead ends */\r\nexport const small = [\r\n  '\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557',\r\n  '\u2551S......\u2551..........\u2551',\r\n  '\u2560\u2550\u2550.\u2554\u2550\u2550.\u2551.\u2554\u2550\u2550.\u2551.\u2551..\u2551',\r\n  '\u2551...\u2551...\u2551.\u2551...\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2550\u2550\u255D.\u255A\u2550\u2550\u2550\u255D.\u255A\u2550\u2550\u2563',\r\n  '\u2551.\u2551.\u2551..............\u2551',\r\n  '\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550.\u2550\u2550\u2566\u2550\u2557..\u2551',\r\n  '\u2551.\u2551...........\u2551.\u2551..\u2551',\r\n  '\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2557.\u2550\u2550\u2550\u2550\u2563.\u2551..\u2551',\r\n  '\u2551.......\u2551.....\u2551.\u2551..\u2551',\r\n  '\u2560\u2550\u2550\u2550\u2550\u2550\u2550.\u255A\u2550\u2550\u2550\u2557.\u2551.\u255A\u2550\u2550\u2563',\r\n  '\u2551...........\u2551.\u2551....\u2551',\r\n  '\u2551.\u2550\u2550\u2550.\u2554\u2550\u2550\u2550\u2550.\u2551.\u255A\u2550\u2550\u2550.\u2551',\r\n  '\u2551.....\u2551.....\u2551......\u2551',\r\n  '\u255A\u2550\u2550\u2550\u2550\u2550\u2563E\u2554\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u255D',\r\n];\r\n\r\n/** Medium-sized maze with branching paths and decision points */\r\nexport const medium = [\r\n  '\u2554\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557',\r\n  '\u2551S\u2551.......\u2551.............\u2551',\r\n  '\u2551.\u2551.\u2550\u2550\u2550\u2550\u2557.\u2560\u2550\u2550\u2550\u2550\u2550\u2557.\u2550\u2550\u2550\u2550\u2557.\u2551',\r\n  '\u2551.\u2551.....\u2551.\u2551.....\u2551.....\u2551.\u2551',\r\n  '\u2551.\u255A\u2550\u2550\u2550\u2557.\u2551.\u255A\u2550\u2550\u2550\u2557.\u255A\u2550\u2557.\u2551.\u2551.\u2551',\r\n  '\u2551.....\u2551.\u2551.....\u2551...\u2551.\u2551.\u2551.\u2551',\r\n  '\u2560\u2550\u2550\u2550\u2557.\u2551.\u255A\u2550\u2550\u2550\u2557.\u2560\u2550\u2550.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551...\u2551.\u2551.....\u2551.\u2551...\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2550\u2550\u255D.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.....\u2551.\u2551.\u2551.....\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u255A\u2550\u2550\u2550\u2557.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551',\r\n  '\u2551.\u2551.....\u2551.\u2551.\u2551.........\u2551.\u2551',\r\n  '\u2551.\u255A\u2550\u2550\u2550\u2557.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563.\u2551',\r\n  '\u2551.....\u2551.\u2551.\u2551...........\u2551.\u2551',\r\n  '\u2560\u2550\u2550\u2550\u2550.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2557.\u2551.\u2551',\r\n  '\u2551.....\u2551.........\u2551...\u2551.\u2551.\u2551',\r\n  '\u2551.\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.................\u2551.\u2551.\u2551.\u2551',\r\n  '\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551...............\u2551.\u2551...\u2551.\u2551',\r\n  '\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2569\u2550\u2550\u2550\u255D.\u2551',\r\n  '\u2551.......................\u2551',\r\n  '\u2551E\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D',\r\n];\r\n\r\n/** Medium-sized maze with branching paths and decision points */\r\nexport const medium2 = [\r\n  '\u2554\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557',\r\n  '\u2551S\u2551.......\u2551.....................\u2551.............\u2551',\r\n  '\u2551.\u2551.\u2550\u2550\u2550\u2550\u2557.\u2560\u2550\u2550\u2550\u2550\u2550\u2557.\u2550\u2550\u2550\u2550\u2557.\u2551.\u2550\u2550\u2550\u2550\u2557.\u2551.\u2550\u2550\u2550\u2550\u2557.\u2550\u2550\u2550\u2550\u2557.\u2551',\r\n  '\u2551.\u2551.....\u2551.\u2551.....\u2551.....\u2551.\u2551.....\u2551.\u2551.....\u2551.....\u2551.\u2551',\r\n  '\u2551.\u255A\u2550\u2550\u2550\u2557.\u2551.\u255A\u2550\u2550\u2550\u2557.\u255A\u2550\u2557.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2563.\u2551.\u255A\u2550\u2550\u2550\u2563.\u255A\u2550\u2557.\u2551.\u2551',\r\n  '\u2551.....\u2551.\u2551.....\u2551...\u2551.\u2551.\u2551.\u2551.....\u2551.\u2551.....\u2551...\u2551.\u2551.\u2551',\r\n  '\u2560\u2550\u2550\u2550\u2557.\u2551.\u255A\u2550\u2550\u2550\u2557.\u2560\u2550\u2550.\u2551.\u2551.\u2551.\u2560\u2550\u2550\u2550\u2557.\u2551.\u255A\u2550\u2550\u2550\u2557.\u2560\u2550\u2550.\u2551.\u2551.\u2551',\r\n  '\u2551...\u2551.\u2551.....\u2551.\u2551...\u2551.\u2551.\u2551.\u2551...\u2551.\u2551.....\u2551.\u2551...\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2550\u2550\u255D.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.....\u2551.\u2551.\u2551.....\u2551.\u2551.\u2551.\u2551.\u2551.....\u2551.\u2551.\u2551.....\u2551.\u2551',\r\n  '\u2551.\u2551.\u255A\u2550\u2550\u2550\u2557.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2557.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u255D.\u2551',\r\n  '\u2551.\u2551.....\u2551.\u2551.\u2551.........\u2551.\u2551.\u2551.....\u2551.\u2551.\u2551.........\u2551',\r\n  '\u2551.\u255A\u2550\u2550\u2550\u2557.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563.\u2551.\u255A\u2550\u2550\u2550\u2557.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563',\r\n  '\u2551.....\u2551.\u2551.\u2551...........\u2551.\u2551.....\u2551.\u2551.\u2551...........\u2551',\r\n  '\u2560\u2550\u2550\u2550\u2550.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2557.\u2551.\u2551\u2550\u2550\u2550\u2550\u2550\u2563.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2557.\u2551',\r\n  '\u2551.....\u2551.........\u2551...\u2551.\u2551.\u2551.....\u2551.........\u2551...\u2551.\u2551',\r\n  '\u2551.\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551',\r\n  '\u2551.................\u2551.\u2551.\u2551.\u2551.................\u2551.\u2551.\u2551',\r\n  '\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2551.\u2551.\u2551.\u2551.\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551...............\u2551.\u2551...\u2551.\u2551...............\u2551.\u2551...\u2551',\r\n  '\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u255A\u2550\u2550\u2550\u2563',\r\n  '\u2551.............................................\u2551',\r\n  '\u2551E\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D',\r\n];\r\n\r\n/** Large, complex maze with many intersections and potential paths */\r\nexport const large = [\r\n  '\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557',\r\n  '\u2551S.......................................\u2551................\u2551',\r\n  '\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2554\u2550\u2550\u2550\u2550\u2550.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550.\u2551',\r\n  '\u2551..........\u2551...................\u2551......................\u2551...\u2551',\r\n  '\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550.\u2554\u2569\u2550.\u2550\u2550\u2550\u2550\u2557.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2554\u2550\u2550\u2550\u2550\u2550\u2557.\u2550\u2569\u2550\u2550.\u2551',\r\n  '\u2551.\u2551.......\u2551.......\u2551.\u2551......................\u2551.\u2551.....\u2551......\u2551',\r\n  '\u2551.\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563.\u2551.\u2550\u2550\u2550\u2550\u256C\u2550\u2550.\u2550\u2550\u2550\u2563',\r\n  '\u2551.\u2551.................\u2551.\u2551.\u2551..................\u2551.\u2551.....\u2551......\u2551',\r\n  '\u2551.\u2551.\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563.\u2551.\u2551.\u2551.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2551.\u2560\u2550\u2550\u2550\u2550.\u2551.\u2550\u2550\u2550\u2550\u2550\u2563',\r\n  '\u2551.\u2551....\u2554\u2569\u2557..........\u255A\u2566\u255D.\u2551.\u2551..............\u2551.\u2551.\u2551.....\u2551......\u2551',\r\n  '\u2560\u2550\u255D..\u2551.\u2551.\u2560\u2550\u2550.\u2551.\u2551.\u2551...\u2551..\u255A\u2550\u2569\u2566\u2550\u2557.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2551.\u2551.\u2551.\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2563',\r\n  '\u2551....\u2551.\u2551.\u2551...\u2551.\u2551.\u2551.\u2551.\u2551.....\u2551.\u2551.......\u2551...\u2551.\u2551..............\u2551',\r\n  '\u2560\u2550.\u2550\u2550\u2569\u2550\u255D.\u255A\u2550\u2550\u2550\u2569\u2550\u255D.\u255A\u2550\u2569\u2566\u2569\u2550\u2550\u2550\u2550\u2566\u255D.\u2551.\u2550\u2550\u2550\u2566\u2550\u2550\u255D.\u2550\u2550\u2569\u2566\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2550\u2563',\r\n  '\u2551...................\u2551.....\u2551..\u2551....\u2551.......\u2551...............\u2551',\r\n  '\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2551.\u2551.\u2550\u2550\u2563.\u2554\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550.\u2554\u2550\u255D.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563',\r\n  '\u2551...................\u2551.\u2551...\u2551.\u2551...........\u2551.................\u2551',\r\n  '\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u255A\u2550\u2550\u2550\u255D.\u2551.\u2554\u2550\u2550.\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2566\u2550.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563',\r\n  '\u2551.\u2551.....................\u2551...\u2551.\u2551...............\u2551...........\u2551',\r\n  '\u2551.\u255A\u2550\u2557.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550.\u2551.\u2554\u2550\u255D.\u255A\u2550\u2557..\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2550\u2563',\r\n  '\u2551...\u2551.\u2551.......\u2551...\u2551.....\u2551.\u2551.....\u2551...........\u2551.\u2551...........\u2551',\r\n  '\u2560\u2550\u2557.\u2551.\u255A\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2550\u2550\u255D.\u2554\u2550\u2550.\u2554\u2550\u2569\u2550\u2550\u2550\u2550.\u2554\u2550\u2566\u2550\u2550.\u2551.\u2551.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2551',\r\n  '\u2551.\u2551.\u2551.....\u2551.\u2551...\u2551.\u2551.\u2551.....\u2551...\u2551.......\u2551.\u2551...\u2551.............\u2551',\r\n  '\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2563.\u2551.\u2554\u2550\u2563.\u255A\u2550\u255D.\u2554\u2550\u2550.\u2551.\u2554\u2550\u2569\u2550\u2550.\u2550\u2550\u2550\u2550\u255D.\u2551.\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563',\r\n  '\u2551.\u2551.......\u2551...\u2551.\u2551.....\u2551...\u2551.\u2551...........\u2551.................\u2551',\r\n  '\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550.\u255A\u2550\u2550.\u2551.\u2560\u2550\u2550\u2550\u2550.\u255A\u2550\u2550\u2550\u255D.\u255A\u2550\u2550.\u2550\u2566\u2550\u2566\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2551',\r\n  '\u2551.............\u2551.\u2551................\u2551.\u2551......................\u2551',\r\n  '\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2551.\u2551.\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550.\u2550\u2550\u2550\u255D.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563',\r\n  '\u2551.............\u2551.......\u2551............\u2551.\u2551....................\u2551',\r\n  '\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u255A\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2563.\u2554\u2550\u2566\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2569\u2557.\u2554\u2550\u2550\u2550\u2550\u2550\u2550.\u2551.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563',\r\n  '\u2551.\u2551...............\u2551...\u2551.\u2551.\u2551.\u2551.........\u2551.\u2551.......\u2551.........\u2551',\r\n  '\u2551.\u2560\u2550\u2557.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563',\r\n  '\u2551.\u2551.\u2551.....................\u2551.\u2551.\u2551.........\u2551.................\u2551',\r\n  '\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550...\u2551',\r\n  '\u2551.\u2551.......................................................\u2551',\r\n  '\u2560\u2550\u2569\u2550\u2566\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2566\u2550\u2557.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563',\r\n  '\u2551...\u2551...\u2551...\u2551...\u2551...\u2551...\u2551...\u2551.\u2551...........................\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2551',\r\n  '\u2551.\u2551...\u2551...\u2551...\u2551...\u2551...\u2551...\u2551...............................\u2551',\r\n  '\u2551E\u2554\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D',\r\n];\r\n\r\n/**\r\n * Extremely large and challenging \"Minotaur's Labyrinth\" maze\r\n * This maze represents the most complex challenge with many parallel paths,\r\n * symmetrical corridors, and a very long optimal solution path.\r\n */\r\nexport const minotaur = [\r\n  '\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557',\r\n  '\u2551..............................................................................\u2551',\r\n  '\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557..\u2551',\r\n  '\u2551.\u2551............\u2551.\u2551.........................................\u2551.\u2551..............\u2551..\u2551',\r\n  '\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551........\u2551.\u2551.\u2551.\u2551.....................................\u2551.\u2551.\u2551.\u2551........\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551....\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.................................\u2551.\u2551.\u2551.\u2551.\u2551.\u2551....\u2551.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2554\u2550.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550.\u2551.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551..\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.............................\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551..\u2551.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2550\u2563.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551....\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.........................\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551....\u2551.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551........\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.....................\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551........\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551............\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.................\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551............\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551..\u2551',\r\n  '\u2551.\u2551................\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.............\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551................\u2551..\u2551',\r\n  '\u2551.\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563..\u2551',\r\n  '\u2551.\u2551..................\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.........\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551..................\u2551..\u2551',\r\n  '\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551..................\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.....\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551..................\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551..................\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551S\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551..................\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551..................\u2551.\u2551.\u2551.\u2551.\u2551.\u2551...\u2551.\u2551.\u2551.\u2551.\u2551.\u2551..................\u2551.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2560\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551..................\u2551.\u2551.\u2551.\u2551.\u2551.....\u2551.\u2551.\u2551.\u2551.\u2551..................\u2551.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551..................\u2551.\u2551.\u2551.........\u2551.\u2551.\u2551..................\u2551.\u2551.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2551.\u2551.\u2551..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551..................\u2551................................\u2551.\u2551.\u2551.\u2551.\u2560\u2550\u255D..\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2554\u2569\u2566\u2569\u2566\u2569\u2566\u2569\u2566\u2569\u2557...\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551..............................................\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557..\u2551.\u2551...\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551..........\u2551.\u2551............................\u2551..\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u255A\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551......\u2551.\u2551.\u2551.\u2551........................\u2551..\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2560\u2550\u2550\u2557.\u2551.\u2551.\u2551.\u2551.\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557..\u2554\u2569\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551..\u2551.\u2551.\u2551.\u2551.\u2551.\u2551....................\u2551..\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u255A\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551....\u2551.\u2551.\u2551.\u2551.\u2551.\u2551................\u2551..\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u255A\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551........\u2551.\u2551.\u2551.\u2551.\u2551.\u2551............\u2551..\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550.\u2560\u2550.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551............\u2551.\u2551.\u2551.\u2551.\u2551.\u2551..........\u2551..\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2557.\u255A\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551....................\u2551.\u2551.\u2551.\u2551.\u2551.\u2551......\u2551..\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2554\u2550\u2550\u2557.\u255A\u2557.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u2551.\u2551......................\u2551.\u2551.\u2551.\u2551.\u2551.\u2551..\u2551..\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551.\u255A\u2550\u2569\u2550\u2550.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2550\u255D.\u2554\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u2551............................\u2551.\u2551.\u2551.\u2551.\u2551....\u2551..\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2551.\u255A\u2550.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2566\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551....................................\u2551.\u2551.\u2551........\u2551..\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2551.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2563.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551........................................\u2551.\u2551...........\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551.\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551.\u2551',\r\n  '\u2551..........................................................\u2551.....\u2551.\u2551.........\u2551.\u2551',\r\n  '\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563E\u2551',\r\n];\r\n", "import { BrowserTerminalUtility } from './browserTerminalUtility';\r\nimport { createBrowserLogger } from './browserLogger';\r\nimport { DashboardManager } from './dashboardManager';\r\nimport { EvolutionEngine } from './evolutionEngine';\r\nimport * as mazes from './mazes';\r\n\r\n// Small helper to create UI controls (start/stop) \u2014 minimal, unobtrusive\r\n// No UI controls in embedded mode; the demo will run automatically.\r\n\r\n// Exported start function for the bundle.\r\nexport async function start(containerId = 'ascii-maze-output') {\r\n  const host = document.getElementById(containerId);\r\n  const archiveEl = host\r\n    ? (host.querySelector('#ascii-maze-archive') as HTMLElement)\r\n    : null;\r\n  const liveEl = host\r\n    ? (host.querySelector('#ascii-maze-live') as HTMLElement)\r\n    : null;\r\n\r\n  // clearer will clear only the live area; archive remains\r\n  const clearFn = BrowserTerminalUtility.createTerminalClearer(\r\n    liveEl ?? undefined\r\n  );\r\n  const liveLogFn = createBrowserLogger(liveEl ?? undefined);\r\n  const archiveLogFn = createBrowserLogger(archiveEl ?? undefined);\r\n\r\n  // DashboardManager will use live logger for ongoing redraws and archive logger to append solved blocks\r\n  const dashboard = new DashboardManager(\r\n    clearFn,\r\n    liveLogFn as any,\r\n    archiveLogFn as any\r\n  );\r\n\r\n  // keep a global reference so the control can call it\r\n  (window as any).asciiMazeStart = async () => {\r\n    // Run mazes in the same curriculum order as the e2e test and mirror its\r\n    // evolution settings where practical. We intentionally disable the\r\n    // post-evolution backprop refinement (lamarckian iterations = 0) for\r\n    // the browser demo as requested.\r\n    const order = [\r\n      'tiny',\r\n      'spiralSmall',\r\n      'spiral',\r\n      'small',\r\n      'medium',\r\n      'medium2',\r\n      'large',\r\n      'minotaur',\r\n    ];\r\n\r\n    // Carry the winning network forward between phases (curriculum transfer)\r\n    let lastBestNetwork: any = undefined;\r\n\r\n    for (const key of order) {\r\n      const maze = (mazes as any)[key] as string[];\r\n      if (!Array.isArray(maze)) continue; // skip missing exports\r\n\r\n      // Per-phase settings copied from the e2e test with lamarckianIterations=0\r\n      let agentMaxSteps = 1000;\r\n      let maxGenerations = 500;\r\n      switch (key) {\r\n        case 'tiny':\r\n          agentMaxSteps = 100;\r\n          maxGenerations = 200;\r\n          break;\r\n        case 'spiralSmall':\r\n          agentMaxSteps = 100;\r\n          maxGenerations = 200;\r\n          break;\r\n        case 'spiral':\r\n          agentMaxSteps = 150;\r\n          maxGenerations = 300;\r\n          break;\r\n        case 'small':\r\n          agentMaxSteps = 50;\r\n          maxGenerations = 300;\r\n          break;\r\n        case 'medium':\r\n          agentMaxSteps = 250;\r\n          maxGenerations = 400;\r\n          break;\r\n        case 'medium2':\r\n          agentMaxSteps = 300;\r\n          maxGenerations = 400;\r\n          break;\r\n        case 'large':\r\n          agentMaxSteps = 400;\r\n          maxGenerations = 500;\r\n          break;\r\n        case 'minotaur':\r\n          agentMaxSteps = 700;\r\n          maxGenerations = 600;\r\n          break;\r\n      }\r\n\r\n      try {\r\n        const result = await EvolutionEngine.runMazeEvolution({\r\n          mazeConfig: { maze },\r\n          agentSimConfig: { maxSteps: agentMaxSteps },\r\n          evolutionAlgorithmConfig: {\r\n            allowRecurrent: true,\r\n            popSize: 40,\r\n            maxStagnantGenerations: 200,\r\n            minProgressToPass: 99,\r\n            maxGenerations: maxGenerations,\r\n            // Disable Lamarckian/backprop refinement for browser runs per request\r\n            lamarckianIterations: 0,\r\n            lamarckianSampleSize: 0,\r\n            // seed previous winner if available\r\n            initialBestNetwork: lastBestNetwork,\r\n          },\r\n          reportingConfig: {\r\n            dashboardManager: dashboard,\r\n            logEvery: 1,\r\n            label: `browser-${key}`,\r\n          },\r\n        });\r\n\r\n        if (result && (result as any).bestNetwork)\r\n          lastBestNetwork = (result as any).bestNetwork;\r\n      } catch (e) {\r\n        console.error('Error while running maze', key, e);\r\n      }\r\n    }\r\n  };\r\n\r\n  // auto-start for convenience\r\n  (window as any).asciiMazeStart();\r\n\r\n  // Setup a cooperative pause flag and UI wiring so users can pause/resume the demo.\r\n  try {\r\n    // Ensure the paused flag exists on window\r\n    (window as any).asciiMazePaused = false;\r\n\r\n    const playPauseBtn = document.getElementById(\r\n      'ascii-maze-playpause'\r\n    ) as HTMLButtonElement | null;\r\n    const updateUI = () => {\r\n      const paused = !!(window as any).asciiMazePaused;\r\n      if (playPauseBtn) {\r\n        playPauseBtn.textContent = paused ? 'Play' : 'Pause';\r\n        playPauseBtn.style.background = paused ? '#39632C' : '#2C3963';\r\n        playPauseBtn.setAttribute('aria-pressed', String(paused));\r\n      }\r\n    };\r\n\r\n    if (playPauseBtn) {\r\n      playPauseBtn.addEventListener('click', () => {\r\n        (window as any).asciiMazePaused = !(window as any).asciiMazePaused;\r\n        updateUI();\r\n      });\r\n    }\r\n    // initialize UI state\r\n    updateUI();\r\n  } catch {\r\n    // ignore DOM wiring errors in non-browser envs\r\n  }\r\n}\r\n\r\n// If loaded directly in a script tag, automatically start\r\nif (typeof window !== 'undefined' && (window as any).document) {\r\n  // Delay to allow DOM insertion\r\n  setTimeout(() => start(), 20);\r\n}\r\n"],
  "mappings": "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",
  "names": ["init_connection", "init_connection", "i", "prevGater", "hidden", "insertIndex", "c1", "c2", "Layer", "start", "x", "start", "path", "path", "testworker_exports", "TestWorker", "init_testworker", "TestWorker", "start", "Neat", "start", "raw", "noTraceActivate", "activateRaw", "activateBatch", "mutateImpl", "applyGradientClippingImpl", "trainImpl", "evolveNetwork", "window", "dist", "b", "from", "to", "selection", "index", "totalFitness", "minimalFitness", "random", "value", "tournament", "start", "path", "minutes", "path", "actionEntropy", "fitness", "MazeMovement", "path", "recent", "probs", "e", "collapsed", "counts"]
}
